"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/axios-cache-adapter";
exports.ids = ["vendor-chunks/axios-cache-adapter"];
exports.modules = {

/***/ "(ssr)/./node_modules/axios-cache-adapter/dist/cache.node.js":
/*!*************************************************************!*\
  !*** ./node_modules/axios-cache-adapter/dist/cache.node.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n(function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = factory(__webpack_require__(/*! axios */ \"(ssr)/./node_modules/axios/dist/node/axios.cjs\"));\n    else {}\n})(global, function(__WEBPACK_EXTERNAL_MODULE_axios__) {\n    return /******/ function(modules) {\n        /******/ // The module cache\n        /******/ var installedModules = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_692__(moduleId) {\n            /******/ /******/ // Check if module is in cache\n            /******/ if (installedModules[moduleId]) {\n                /******/ return installedModules[moduleId].exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = installedModules[moduleId] = {\n                /******/ i: moduleId,\n                /******/ l: false,\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ modules[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_692__);\n            /******/ /******/ // Flag the module as loaded\n            /******/ module1.l = true;\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /******/ /******/ // expose the modules object (__webpack_modules__)\n        /******/ __nested_webpack_require_692__.m = modules;\n        /******/ /******/ // expose the module cache\n        /******/ __nested_webpack_require_692__.c = installedModules;\n        /******/ /******/ // define getter function for harmony exports\n        /******/ __nested_webpack_require_692__.d = function(exports1, name, getter) {\n            /******/ if (!__nested_webpack_require_692__.o(exports1, name)) {\n                /******/ Object.defineProperty(exports1, name, {\n                    enumerable: true,\n                    get: getter\n                });\n            /******/ }\n        /******/ };\n        /******/ /******/ // define __esModule on exports\n        /******/ __nested_webpack_require_692__.r = function(exports1) {\n            /******/ if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n                /******/ Object.defineProperty(exports1, Symbol.toStringTag, {\n                    value: \"Module\"\n                });\n            /******/ }\n            /******/ Object.defineProperty(exports1, \"__esModule\", {\n                value: true\n            });\n        /******/ };\n        /******/ /******/ // create a fake namespace object\n        /******/ // mode & 1: value is a module id, require it\n        /******/ // mode & 2: merge all properties of value into the ns\n        /******/ // mode & 4: return value when already ns object\n        /******/ // mode & 8|1: behave like require\n        /******/ __nested_webpack_require_692__.t = function(value, mode) {\n            /******/ if (mode & 1) value = __nested_webpack_require_692__(value);\n            /******/ if (mode & 8) return value;\n            /******/ if (mode & 4 && typeof value === \"object\" && value && value.__esModule) return value;\n            /******/ var ns = Object.create(null);\n            /******/ __nested_webpack_require_692__.r(ns);\n            /******/ Object.defineProperty(ns, \"default\", {\n                enumerable: true,\n                value: value\n            });\n            /******/ if (mode & 2 && typeof value != \"string\") for(var key in value)__nested_webpack_require_692__.d(ns, key, (function(key) {\n                return value[key];\n            }).bind(null, key));\n            /******/ return ns;\n        /******/ };\n        /******/ /******/ // getDefaultExport function for compatibility with non-harmony modules\n        /******/ __nested_webpack_require_692__.n = function(module1) {\n            /******/ var getter = module1 && module1.__esModule ? /******/ function getDefault() {\n                return module1[\"default\"];\n            } : /******/ function getModuleExports() {\n                return module1;\n            };\n            /******/ __nested_webpack_require_692__.d(getter, \"a\", getter);\n            /******/ return getter;\n        /******/ };\n        /******/ /******/ // Object.prototype.hasOwnProperty.call\n        /******/ __nested_webpack_require_692__.o = function(object, property) {\n            return Object.prototype.hasOwnProperty.call(object, property);\n        };\n        /******/ /******/ // __webpack_public_path__\n        /******/ __nested_webpack_require_692__.p = \"\";\n        /******/ /******/ /******/ // Load entry module and return exports\n        /******/ return __nested_webpack_require_692__(__nested_webpack_require_692__.s = \"./src/index.node.js\");\n    /******/ }({\n        /***/ \"./node_modules/cache-control-esm/index.js\": /*!*************************************************!*\\\n  !*** ./node_modules/cache-control-esm/index.js ***!\n  \\*************************************************/ /*! exports provided: CacheControl, parse, format, default */ /***/ function(module1, __nested_webpack_exports__, __nested_webpack_require_5206__) {\n            \"use strict\";\n            __nested_webpack_require_5206__.r(__nested_webpack_exports__);\n            /* harmony export (binding) */ __nested_webpack_require_5206__.d(__nested_webpack_exports__, \"CacheControl\", function() {\n                return CacheControl;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_5206__.d(__nested_webpack_exports__, \"parse\", function() {\n                return parse;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_5206__.d(__nested_webpack_exports__, \"format\", function() {\n                return format;\n            });\n            /* harmony import */ var core_js_modules_es6_array_from__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_5206__(/*! core-js/modules/es6.array.from */ \"./node_modules/core-js/modules/es6.array.from.js\");\n            /* harmony import */ var core_js_modules_es6_array_from__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __nested_webpack_require_5206__.n(core_js_modules_es6_array_from__WEBPACK_IMPORTED_MODULE_0__);\n            /* harmony import */ var core_js_modules_es6_function_name__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_5206__(/*! core-js/modules/es6.function.name */ \"./node_modules/core-js/modules/es6.function.name.js\");\n            /* harmony import */ var core_js_modules_es6_function_name__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __nested_webpack_require_5206__.n(core_js_modules_es6_function_name__WEBPACK_IMPORTED_MODULE_1__);\n            /* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_5206__(/*! core-js/modules/es6.object.to-string */ \"./node_modules/core-js/modules/es6.object.to-string.js\");\n            /* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/ __nested_webpack_require_5206__.n(core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_2__);\n            /* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_5206__(/*! core-js/modules/web.dom.iterable */ \"./node_modules/core-js/modules/web.dom.iterable.js\");\n            /* harmony import */ var core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/ __nested_webpack_require_5206__.n(core_js_modules_web_dom_iterable__WEBPACK_IMPORTED_MODULE_3__);\n            /* harmony import */ var core_js_modules_es7_symbol_async_iterator__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_5206__(/*! core-js/modules/es7.symbol.async-iterator */ \"./node_modules/core-js/modules/es7.symbol.async-iterator.js\");\n            /* harmony import */ var core_js_modules_es7_symbol_async_iterator__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/ __nested_webpack_require_5206__.n(core_js_modules_es7_symbol_async_iterator__WEBPACK_IMPORTED_MODULE_4__);\n            /* harmony import */ var core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_5206__(/*! core-js/modules/es6.symbol */ \"./node_modules/core-js/modules/es6.symbol.js\");\n            /* harmony import */ var core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/ __nested_webpack_require_5206__.n(core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_5__);\n            /* harmony import */ var core_js_modules_es6_regexp_split__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_5206__(/*! core-js/modules/es6.regexp.split */ \"./node_modules/core-js/modules/es6.regexp.split.js\");\n            /* harmony import */ var core_js_modules_es6_regexp_split__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/ __nested_webpack_require_5206__.n(core_js_modules_es6_regexp_split__WEBPACK_IMPORTED_MODULE_6__);\n            /* harmony import */ var core_js_modules_es6_number_is_finite__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_5206__(/*! core-js/modules/es6.number.is-finite */ \"./node_modules/core-js/modules/es6.number.is-finite.js\");\n            /* harmony import */ var core_js_modules_es6_number_is_finite__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/ __nested_webpack_require_5206__.n(core_js_modules_es6_number_is_finite__WEBPACK_IMPORTED_MODULE_7__);\n            function _slicedToArray(arr, i) {\n                return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n            }\n            function _nonIterableRest() {\n                throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n            }\n            function _unsupportedIterableToArray(o, minLen) {\n                if (!o) return;\n                if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n                var n = Object.prototype.toString.call(o).slice(8, -1);\n                if (n === \"Object\" && o.constructor) n = o.constructor.name;\n                if (n === \"Map\" || n === \"Set\") return Array.from(o);\n                if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n            }\n            function _arrayLikeToArray(arr, len) {\n                if (len == null || len > arr.length) len = arr.length;\n                for(var i = 0, arr2 = new Array(len); i < len; i++){\n                    arr2[i] = arr[i];\n                }\n                return arr2;\n            }\n            function _iterableToArrayLimit(arr, i) {\n                if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n                var _arr = [];\n                var _n = true;\n                var _d = false;\n                var _e = undefined;\n                try {\n                    for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){\n                        _arr.push(_s.value);\n                        if (i && _arr.length === i) break;\n                    }\n                } catch (err) {\n                    _d = true;\n                    _e = err;\n                } finally{\n                    try {\n                        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n                    } finally{\n                        if (_d) throw _e;\n                    }\n                }\n                return _arr;\n            }\n            function _arrayWithHoles(arr) {\n                if (Array.isArray(arr)) return arr;\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function _createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) _defineProperties(Constructor, staticProps);\n                return Constructor;\n            }\n            var HEADER_REGEXP = /([a-zA-Z][a-zA-Z_-]*)\\s*(?:=(?:\"([^\"]*)\"|([^ \\t\",;]*)))?/g;\n            var STRINGS = {\n                maxAge: \"max-age\",\n                sharedMaxAge: \"s-maxage\",\n                maxStale: \"max-stale\",\n                minFresh: \"min-fresh\",\n                immutable: \"immutable\",\n                mustRevalidate: \"must-revalidate\",\n                noCache: \"no-cache\",\n                noStore: \"no-store\",\n                noTransform: \"no-transform\",\n                onlyIfCached: \"only-if-cached\",\n                \"private\": \"private\",\n                proxyRevalidate: \"proxy-revalidate\",\n                \"public\": \"public\"\n            };\n            function parseBooleanOnly(value) {\n                return value === null;\n            }\n            function parseDuration(value) {\n                if (!value) {\n                    return null;\n                }\n                var duration = parseInt(value, 10);\n                if (!Number.isFinite(duration) || duration < 0) {\n                    return null;\n                }\n                return duration;\n            }\n            var CacheControl = /*#__PURE__*/ function() {\n                function CacheControl() {\n                    _classCallCheck(this, CacheControl);\n                    this.maxAge = null;\n                    this.sharedMaxAge = null;\n                    this.maxStale = null;\n                    this.maxStaleDuration = null;\n                    this.minFresh = null;\n                    this.immutable = null;\n                    this.mustRevalidate = null;\n                    this.noCache = null;\n                    this.noStore = null;\n                    this.noTransform = null;\n                    this.onlyIfCached = null;\n                    this[\"private\"] = null;\n                    this.proxyRevalidate = null;\n                    this[\"public\"] = null;\n                }\n                _createClass(CacheControl, [\n                    {\n                        key: \"parse\",\n                        value: function parse(header) {\n                            if (!header || header.length === 0) {\n                                return this;\n                            }\n                            var values = {};\n                            var matches = header.match(HEADER_REGEXP) || [];\n                            Array.prototype.forEach.call(matches, function(match) {\n                                var tokens = match.split(\"=\", 2);\n                                var _tokens = _slicedToArray(tokens, 1), key = _tokens[0];\n                                var value = null;\n                                if (tokens.length > 1) {\n                                    value = tokens[1].trim();\n                                }\n                                values[key.toLowerCase()] = value;\n                            });\n                            this.maxAge = parseDuration(values[STRINGS.maxAge]);\n                            this.sharedMaxAge = parseDuration(values[STRINGS.sharedMaxAge]);\n                            this.maxStale = parseBooleanOnly(values[STRINGS.maxStale]);\n                            this.maxStaleDuration = parseDuration(values[STRINGS.maxStale]);\n                            if (this.maxStaleDuration) {\n                                this.maxStale = true;\n                            }\n                            this.minFresh = parseDuration(values[STRINGS.minFresh]);\n                            this.immutable = parseBooleanOnly(values[STRINGS.immutable]);\n                            this.mustRevalidate = parseBooleanOnly(values[STRINGS.mustRevalidate]);\n                            this.noCache = parseBooleanOnly(values[STRINGS.noCache]);\n                            this.noStore = parseBooleanOnly(values[STRINGS.noStore]);\n                            this.noTransform = parseBooleanOnly(values[STRINGS.noTransform]);\n                            this.onlyIfCached = parseBooleanOnly(values[STRINGS.onlyIfCached]);\n                            this[\"private\"] = parseBooleanOnly(values[STRINGS[\"private\"]]);\n                            this.proxyRevalidate = parseBooleanOnly(values[STRINGS.proxyRevalidate]);\n                            this[\"public\"] = parseBooleanOnly(values[STRINGS[\"public\"]]);\n                            return this;\n                        }\n                    },\n                    {\n                        key: \"format\",\n                        value: function format() {\n                            var tokens = [];\n                            if (this.maxAge) {\n                                tokens.push(\"\".concat(STRINGS.maxAge, \"=\").concat(this.maxAge));\n                            }\n                            if (this.sharedMaxAge) {\n                                tokens.push(\"\".concat(STRINGS.sharedMaxAge, \"=\").concat(this.sharedMaxAge));\n                            }\n                            if (this.maxStale) {\n                                if (this.maxStaleDuration) {\n                                    tokens.push(\"\".concat(STRINGS.maxStale, \"=\").concat(this.maxStaleDuration));\n                                } else {\n                                    tokens.push(STRINGS.maxStale);\n                                }\n                            }\n                            if (this.minFresh) {\n                                tokens.push(\"\".concat(STRINGS.minFresh, \"=\").concat(this.minFresh));\n                            }\n                            if (this.immutable) {\n                                tokens.push(STRINGS.immutable);\n                            }\n                            if (this.mustRevalidate) {\n                                tokens.push(STRINGS.mustRevalidate);\n                            }\n                            if (this.noCache) {\n                                tokens.push(STRINGS.noCache);\n                            }\n                            if (this.noStore) {\n                                tokens.push(STRINGS.noStore);\n                            }\n                            if (this.noTransform) {\n                                tokens.push(STRINGS.noTransform);\n                            }\n                            if (this.onlyIfCached) {\n                                tokens.push(STRINGS.onlyIfCached);\n                            }\n                            if (this[\"private\"]) {\n                                tokens.push(STRINGS[\"private\"]);\n                            }\n                            if (this.proxyRevalidate) {\n                                tokens.push(STRINGS.proxyRevalidate);\n                            }\n                            if (this[\"public\"]) {\n                                tokens.push(STRINGS[\"public\"]);\n                            }\n                            return tokens.join(\", \");\n                        }\n                    }\n                ]);\n                return CacheControl;\n            }();\n            function parse(header) {\n                var cc = new CacheControl();\n                return cc.parse(header);\n            }\n            function format(cc) {\n                if (!(cc instanceof CacheControl)) {\n                    return CacheControl.prototype.format.call(cc);\n                }\n                return cc.format();\n            }\n            /* harmony default export */ __nested_webpack_exports__[\"default\"] = {\n                CacheControl: CacheControl,\n                parse: parse,\n                format: format\n            };\n        /***/ },\n        /***/ \"./node_modules/charenc/charenc.js\": /*!*****************************************!*\\\n  !*** ./node_modules/charenc/charenc.js ***!\n  \\*****************************************/ /*! no static exports found */ /***/ function(module1, exports1) {\n            var charenc = {\n                // UTF-8 encoding\n                utf8: {\n                    // Convert a string to a byte array\n                    stringToBytes: function(str) {\n                        return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));\n                    },\n                    // Convert a byte array to a string\n                    bytesToString: function(bytes) {\n                        return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));\n                    }\n                },\n                // Binary encoding\n                bin: {\n                    // Convert a string to a byte array\n                    stringToBytes: function(str) {\n                        for(var bytes = [], i = 0; i < str.length; i++)bytes.push(str.charCodeAt(i) & 0xFF);\n                        return bytes;\n                    },\n                    // Convert a byte array to a string\n                    bytesToString: function(bytes) {\n                        for(var str = [], i = 0; i < bytes.length; i++)str.push(String.fromCharCode(bytes[i]));\n                        return str.join(\"\");\n                    }\n                }\n            };\n            module1.exports = charenc;\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_a-function.js\": /*!*****************************************************!*\\\n  !*** ./node_modules/core-js/modules/_a-function.js ***!\n  \\*****************************************************/ /*! no static exports found */ /***/ function(module1, exports1) {\n            module1.exports = function(it) {\n                if (typeof it != \"function\") throw TypeError(it + \" is not a function!\");\n                return it;\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_add-to-unscopables.js\": /*!*************************************************************!*\\\n  !*** ./node_modules/core-js/modules/_add-to-unscopables.js ***!\n  \\*************************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_22416__) {\n            // 22.1.3.31 Array.prototype[@@unscopables]\n            var UNSCOPABLES = __nested_webpack_require_22416__(/*! ./_wks */ \"./node_modules/core-js/modules/_wks.js\")(\"unscopables\");\n            var ArrayProto = Array.prototype;\n            if (ArrayProto[UNSCOPABLES] == undefined) __nested_webpack_require_22416__(/*! ./_hide */ \"./node_modules/core-js/modules/_hide.js\")(ArrayProto, UNSCOPABLES, {});\n            module1.exports = function(key) {\n                ArrayProto[UNSCOPABLES][key] = true;\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_advance-string-index.js\": /*!***************************************************************!*\\\n  !*** ./node_modules/core-js/modules/_advance-string-index.js ***!\n  \\***************************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_23300__) {\n            \"use strict\";\n            var at = __nested_webpack_require_23300__(/*! ./_string-at */ \"./node_modules/core-js/modules/_string-at.js\")(true);\n            // `AdvanceStringIndex` abstract operation\n            // https://tc39.github.io/ecma262/#sec-advancestringindex\n            module1.exports = function(S, index, unicode) {\n                return index + (unicode ? at(S, index).length : 1);\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_an-object.js\": /*!****************************************************!*\\\n  !*** ./node_modules/core-js/modules/_an-object.js ***!\n  \\****************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_24050__) {\n            var isObject = __nested_webpack_require_24050__(/*! ./_is-object */ \"./node_modules/core-js/modules/_is-object.js\");\n            module1.exports = function(it) {\n                if (!isObject(it)) throw TypeError(it + \" is not an object!\");\n                return it;\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_array-includes.js\": /*!*********************************************************!*\\\n  !*** ./node_modules/core-js/modules/_array-includes.js ***!\n  \\*********************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_24692__) {\n            // false -> Array#indexOf\n            // true  -> Array#includes\n            var toIObject = __nested_webpack_require_24692__(/*! ./_to-iobject */ \"./node_modules/core-js/modules/_to-iobject.js\");\n            var toLength = __nested_webpack_require_24692__(/*! ./_to-length */ \"./node_modules/core-js/modules/_to-length.js\");\n            var toAbsoluteIndex = __nested_webpack_require_24692__(/*! ./_to-absolute-index */ \"./node_modules/core-js/modules/_to-absolute-index.js\");\n            module1.exports = function(IS_INCLUDES) {\n                return function($this, el, fromIndex) {\n                    var O = toIObject($this);\n                    var length = toLength(O.length);\n                    var index = toAbsoluteIndex(fromIndex, length);\n                    var value;\n                    // Array#includes uses SameValueZero equality algorithm\n                    // eslint-disable-next-line no-self-compare\n                    if (IS_INCLUDES && el != el) while(length > index){\n                        value = O[index++];\n                        // eslint-disable-next-line no-self-compare\n                        if (value != value) return true;\n                    // Array#indexOf ignores holes, Array#includes - not\n                    }\n                    else for(; length > index; index++)if (IS_INCLUDES || index in O) {\n                        if (O[index] === el) return IS_INCLUDES || index || 0;\n                    }\n                    return !IS_INCLUDES && -1;\n                };\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_bind.js\": /*!***********************************************!*\\\n  !*** ./node_modules/core-js/modules/_bind.js ***!\n  \\***********************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_26517__) {\n            \"use strict\";\n            var aFunction = __nested_webpack_require_26517__(/*! ./_a-function */ \"./node_modules/core-js/modules/_a-function.js\");\n            var isObject = __nested_webpack_require_26517__(/*! ./_is-object */ \"./node_modules/core-js/modules/_is-object.js\");\n            var invoke = __nested_webpack_require_26517__(/*! ./_invoke */ \"./node_modules/core-js/modules/_invoke.js\");\n            var arraySlice = [].slice;\n            var factories = {};\n            var construct = function(F, len, args) {\n                if (!(len in factories)) {\n                    for(var n = [], i = 0; i < len; i++)n[i] = \"a[\" + i + \"]\";\n                    // eslint-disable-next-line no-new-func\n                    factories[len] = Function(\"F,a\", \"return new F(\" + n.join(\",\") + \")\");\n                }\n                return factories[len](F, args);\n            };\n            module1.exports = Function.bind || function bind(that /* , ...args */ ) {\n                var fn = aFunction(this);\n                var partArgs = arraySlice.call(arguments, 1);\n                var bound = function() {\n                    var args = partArgs.concat(arraySlice.call(arguments));\n                    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);\n                };\n                if (isObject(fn.prototype)) bound.prototype = fn.prototype;\n                return bound;\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_classof.js\": /*!**************************************************!*\\\n  !*** ./node_modules/core-js/modules/_classof.js ***!\n  \\**************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_28253__) {\n            // getting tag from 19.1.3.6 Object.prototype.toString()\n            var cof = __nested_webpack_require_28253__(/*! ./_cof */ \"./node_modules/core-js/modules/_cof.js\");\n            var TAG = __nested_webpack_require_28253__(/*! ./_wks */ \"./node_modules/core-js/modules/_wks.js\")(\"toStringTag\");\n            // ES3 wrong here\n            var ARG = cof(function() {\n                return arguments;\n            }()) == \"Arguments\";\n            // fallback for IE11 Script Access Denied error\n            var tryGet = function(it, key) {\n                try {\n                    return it[key];\n                } catch (e) {}\n            };\n            module1.exports = function(it) {\n                var O, T, B;\n                return it === undefined ? \"Undefined\" : it === null ? \"Null\" : typeof (T = tryGet(O = Object(it), TAG)) == \"string\" ? T : ARG ? cof(O) : (B = cof(O)) == \"Object\" && typeof O.callee == \"function\" ? \"Arguments\" : B;\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_cof.js\": /*!**********************************************!*\\\n  !*** ./node_modules/core-js/modules/_cof.js ***!\n  \\**********************************************/ /*! no static exports found */ /***/ function(module1, exports1) {\n            var toString = {}.toString;\n            module1.exports = function(it) {\n                return toString.call(it).slice(8, -1);\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_core.js\": /*!***********************************************!*\\\n  !*** ./node_modules/core-js/modules/_core.js ***!\n  \\***********************************************/ /*! no static exports found */ /***/ function(module1, exports1) {\n            var core = module1.exports = {\n                version: \"2.6.12\"\n            };\n            if (typeof __e == \"number\") __e = core; // eslint-disable-line no-undef\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_create-property.js\": /*!**********************************************************!*\\\n  !*** ./node_modules/core-js/modules/_create-property.js ***!\n  \\**********************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_30488__) {\n            \"use strict\";\n            var $defineProperty = __nested_webpack_require_30488__(/*! ./_object-dp */ \"./node_modules/core-js/modules/_object-dp.js\");\n            var createDesc = __nested_webpack_require_30488__(/*! ./_property-desc */ \"./node_modules/core-js/modules/_property-desc.js\");\n            module1.exports = function(object, index, value) {\n                if (index in object) $defineProperty.f(object, index, createDesc(0, value));\n                else object[index] = value;\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_ctx.js\": /*!**********************************************!*\\\n  !*** ./node_modules/core-js/modules/_ctx.js ***!\n  \\**********************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_31294__) {\n            // optional / simple context binding\n            var aFunction = __nested_webpack_require_31294__(/*! ./_a-function */ \"./node_modules/core-js/modules/_a-function.js\");\n            module1.exports = function(fn, that, length) {\n                aFunction(fn);\n                if (that === undefined) return fn;\n                switch(length){\n                    case 1:\n                        return function(a) {\n                            return fn.call(that, a);\n                        };\n                    case 2:\n                        return function(a, b) {\n                            return fn.call(that, a, b);\n                        };\n                    case 3:\n                        return function(a, b, c) {\n                            return fn.call(that, a, b, c);\n                        };\n                }\n                return function() {\n                    return fn.apply(that, arguments);\n                };\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_defined.js\": /*!**************************************************!*\\\n  !*** ./node_modules/core-js/modules/_defined.js ***!\n  \\**************************************************/ /*! no static exports found */ /***/ function(module1, exports1) {\n            // 7.2.1 RequireObjectCoercible(argument)\n            module1.exports = function(it) {\n                if (it == undefined) throw TypeError(\"Can't call method on  \" + it);\n                return it;\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_descriptors.js\": /*!******************************************************!*\\\n  !*** ./node_modules/core-js/modules/_descriptors.js ***!\n  \\******************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_33139__) {\n            // Thank's IE8 for his funny defineProperty\n            module1.exports = !__nested_webpack_require_33139__(/*! ./_fails */ \"./node_modules/core-js/modules/_fails.js\")(function() {\n                return Object.defineProperty({}, \"a\", {\n                    get: function() {\n                        return 7;\n                    }\n                }).a != 7;\n            });\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_dom-create.js\": /*!*****************************************************!*\\\n  !*** ./node_modules/core-js/modules/_dom-create.js ***!\n  \\*****************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_33856__) {\n            var isObject = __nested_webpack_require_33856__(/*! ./_is-object */ \"./node_modules/core-js/modules/_is-object.js\");\n            var document = __nested_webpack_require_33856__(/*! ./_global */ \"./node_modules/core-js/modules/_global.js\").document;\n            // typeof document.createElement is 'object' in old IE\n            var is = isObject(document) && isObject(document.createElement);\n            module1.exports = function(it) {\n                return is ? document.createElement(it) : {};\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_enum-bug-keys.js\": /*!********************************************************!*\\\n  !*** ./node_modules/core-js/modules/_enum-bug-keys.js ***!\n  \\********************************************************/ /*! no static exports found */ /***/ function(module1, exports1) {\n            // IE 8- don't enum bug keys\n            module1.exports = \"constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf\".split(\",\");\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_enum-keys.js\": /*!****************************************************!*\\\n  !*** ./node_modules/core-js/modules/_enum-keys.js ***!\n  \\****************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_35210__) {\n            // all enumerable object keys, includes symbols\n            var getKeys = __nested_webpack_require_35210__(/*! ./_object-keys */ \"./node_modules/core-js/modules/_object-keys.js\");\n            var gOPS = __nested_webpack_require_35210__(/*! ./_object-gops */ \"./node_modules/core-js/modules/_object-gops.js\");\n            var pIE = __nested_webpack_require_35210__(/*! ./_object-pie */ \"./node_modules/core-js/modules/_object-pie.js\");\n            module1.exports = function(it) {\n                var result = getKeys(it);\n                var getSymbols = gOPS.f;\n                if (getSymbols) {\n                    var symbols = getSymbols(it);\n                    var isEnum = pIE.f;\n                    var i = 0;\n                    var key;\n                    while(symbols.length > i)if (isEnum.call(it, key = symbols[i++])) result.push(key);\n                }\n                return result;\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_export.js\": /*!*************************************************!*\\\n  !*** ./node_modules/core-js/modules/_export.js ***!\n  \\*************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_36426__) {\n            var global1 = __nested_webpack_require_36426__(/*! ./_global */ \"./node_modules/core-js/modules/_global.js\");\n            var core = __nested_webpack_require_36426__(/*! ./_core */ \"./node_modules/core-js/modules/_core.js\");\n            var hide = __nested_webpack_require_36426__(/*! ./_hide */ \"./node_modules/core-js/modules/_hide.js\");\n            var redefine = __nested_webpack_require_36426__(/*! ./_redefine */ \"./node_modules/core-js/modules/_redefine.js\");\n            var ctx = __nested_webpack_require_36426__(/*! ./_ctx */ \"./node_modules/core-js/modules/_ctx.js\");\n            var PROTOTYPE = \"prototype\";\n            var $export = function(type, name, source) {\n                var IS_FORCED = type & $export.F;\n                var IS_GLOBAL = type & $export.G;\n                var IS_STATIC = type & $export.S;\n                var IS_PROTO = type & $export.P;\n                var IS_BIND = type & $export.B;\n                var target = IS_GLOBAL ? global1 : IS_STATIC ? global1[name] || (global1[name] = {}) : (global1[name] || {})[PROTOTYPE];\n                var exports1 = IS_GLOBAL ? core : core[name] || (core[name] = {});\n                var expProto = exports1[PROTOTYPE] || (exports1[PROTOTYPE] = {});\n                var key, own, out, exp;\n                if (IS_GLOBAL) source = name;\n                for(key in source){\n                    // contains in native\n                    own = !IS_FORCED && target && target[key] !== undefined;\n                    // export native or passed\n                    out = (own ? target : source)[key];\n                    // bind timers to global for call from export context\n                    exp = IS_BIND && own ? ctx(out, global1) : IS_PROTO && typeof out == \"function\" ? ctx(Function.call, out) : out;\n                    // extend global\n                    if (target) redefine(target, key, out, type & $export.U);\n                    // export\n                    if (exports1[key] != out) hide(exports1, key, exp);\n                    if (IS_PROTO && expProto[key] != out) expProto[key] = out;\n                }\n            };\n            global1.core = core;\n            // type bitmap\n            $export.F = 1; // forced\n            $export.G = 2; // global\n            $export.S = 4; // static\n            $export.P = 8; // proto\n            $export.B = 16; // bind\n            $export.W = 32; // wrap\n            $export.U = 64; // safe\n            $export.R = 128; // real proto method for `library`\n            module1.exports = $export;\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_fails-is-regexp.js\": /*!**********************************************************!*\\\n  !*** ./node_modules/core-js/modules/_fails-is-regexp.js ***!\n  \\**********************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_39261__) {\n            var MATCH = __nested_webpack_require_39261__(/*! ./_wks */ \"./node_modules/core-js/modules/_wks.js\")(\"match\");\n            module1.exports = function(KEY) {\n                var re = /./;\n                try {\n                    \"/./\"[KEY](re);\n                } catch (e) {\n                    try {\n                        re[MATCH] = false;\n                        return !\"/./\"[KEY](re);\n                    } catch (f) {}\n                }\n                return true;\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_fails.js\": /*!************************************************!*\\\n  !*** ./node_modules/core-js/modules/_fails.js ***!\n  \\************************************************/ /*! no static exports found */ /***/ function(module1, exports1) {\n            module1.exports = function(exec) {\n                try {\n                    return !!exec();\n                } catch (e) {\n                    return true;\n                }\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_fix-re-wks.js\": /*!*****************************************************!*\\\n  !*** ./node_modules/core-js/modules/_fix-re-wks.js ***!\n  \\*****************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_40598__) {\n            \"use strict\";\n            __nested_webpack_require_40598__(/*! ./es6.regexp.exec */ \"./node_modules/core-js/modules/es6.regexp.exec.js\");\n            var redefine = __nested_webpack_require_40598__(/*! ./_redefine */ \"./node_modules/core-js/modules/_redefine.js\");\n            var hide = __nested_webpack_require_40598__(/*! ./_hide */ \"./node_modules/core-js/modules/_hide.js\");\n            var fails = __nested_webpack_require_40598__(/*! ./_fails */ \"./node_modules/core-js/modules/_fails.js\");\n            var defined = __nested_webpack_require_40598__(/*! ./_defined */ \"./node_modules/core-js/modules/_defined.js\");\n            var wks = __nested_webpack_require_40598__(/*! ./_wks */ \"./node_modules/core-js/modules/_wks.js\");\n            var regexpExec = __nested_webpack_require_40598__(/*! ./_regexp-exec */ \"./node_modules/core-js/modules/_regexp-exec.js\");\n            var SPECIES = wks(\"species\");\n            var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function() {\n                // #replace needs built-in support for named groups.\n                // #match works fine because it just return the exec results, even if it has\n                // a \"grops\" property.\n                var re = /./;\n                re.exec = function() {\n                    var result = [];\n                    result.groups = {\n                        a: \"7\"\n                    };\n                    return result;\n                };\n                return \"\".replace(re, \"$<a>\") !== \"7\";\n            });\n            var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = function() {\n                // Chrome 51 has a buggy \"split\" implementation when RegExp#exec !== nativeExec\n                var re = /(?:)/;\n                var originalExec = re.exec;\n                re.exec = function() {\n                    return originalExec.apply(this, arguments);\n                };\n                var result = \"ab\".split(re);\n                return result.length === 2 && result[0] === \"a\" && result[1] === \"b\";\n            }();\n            module1.exports = function(KEY, length, exec) {\n                var SYMBOL = wks(KEY);\n                var DELEGATES_TO_SYMBOL = !fails(function() {\n                    // String methods call symbol-named RegEp methods\n                    var O = {};\n                    O[SYMBOL] = function() {\n                        return 7;\n                    };\n                    return \"\"[KEY](O) != 7;\n                });\n                var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function() {\n                    // Symbol-named RegExp methods call .exec\n                    var execCalled = false;\n                    var re = /a/;\n                    re.exec = function() {\n                        execCalled = true;\n                        return null;\n                    };\n                    if (KEY === \"split\") {\n                        // RegExp[@@split] doesn't call the regex's exec method, but first creates\n                        // a new one. We need to return the patched regex when creating the new one.\n                        re.constructor = {};\n                        re.constructor[SPECIES] = function() {\n                            return re;\n                        };\n                    }\n                    re[SYMBOL](\"\");\n                    return !execCalled;\n                }) : undefined;\n                if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === \"replace\" && !REPLACE_SUPPORTS_NAMED_GROUPS || KEY === \"split\" && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {\n                    var nativeRegExpMethod = /./[SYMBOL];\n                    var fns = exec(defined, SYMBOL, \"\"[KEY], function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {\n                        if (regexp.exec === regexpExec) {\n                            if (DELEGATES_TO_SYMBOL && !forceStringMethod) {\n                                // The native String method already delegates to @@method (this\n                                // polyfilled function), leasing to infinite recursion.\n                                // We avoid it by directly calling the native @@method method.\n                                return {\n                                    done: true,\n                                    value: nativeRegExpMethod.call(regexp, str, arg2)\n                                };\n                            }\n                            return {\n                                done: true,\n                                value: nativeMethod.call(str, regexp, arg2)\n                            };\n                        }\n                        return {\n                            done: false\n                        };\n                    });\n                    var strfn = fns[0];\n                    var rxfn = fns[1];\n                    redefine(String.prototype, KEY, strfn);\n                    hide(RegExp.prototype, SYMBOL, length == 2 ? function(string, arg) {\n                        return rxfn.call(string, this, arg);\n                    } : function(string) {\n                        return rxfn.call(string, this);\n                    });\n                }\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_flags.js\": /*!************************************************!*\\\n  !*** ./node_modules/core-js/modules/_flags.js ***!\n  \\************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_46011__) {\n            \"use strict\";\n            // 21.2.5.3 get RegExp.prototype.flags\n            var anObject = __nested_webpack_require_46011__(/*! ./_an-object */ \"./node_modules/core-js/modules/_an-object.js\");\n            module1.exports = function() {\n                var that = anObject(this);\n                var result = \"\";\n                if (that.global) result += \"g\";\n                if (that.ignoreCase) result += \"i\";\n                if (that.multiline) result += \"m\";\n                if (that.unicode) result += \"u\";\n                if (that.sticky) result += \"y\";\n                return result;\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_function-to-string.js\": /*!*************************************************************!*\\\n  !*** ./node_modules/core-js/modules/_function-to-string.js ***!\n  \\*************************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_46993__) {\n            module1.exports = __nested_webpack_require_46993__(/*! ./_shared */ \"./node_modules/core-js/modules/_shared.js\")(\"native-function-to-string\", Function.toString);\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_global.js\": /*!*************************************************!*\\\n  !*** ./node_modules/core-js/modules/_global.js ***!\n  \\*************************************************/ /*! no static exports found */ /***/ function(module1, exports1) {\n            // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n            var global1 = module1.exports =  false ? 0 : typeof self != \"undefined\" && self.Math == Math ? self : Function(\"return this\")();\n            if (typeof __g == \"number\") __g = global1; // eslint-disable-line no-undef\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_has.js\": /*!**********************************************!*\\\n  !*** ./node_modules/core-js/modules/_has.js ***!\n  \\**********************************************/ /*! no static exports found */ /***/ function(module1, exports1) {\n            var hasOwnProperty = {}.hasOwnProperty;\n            module1.exports = function(it, key) {\n                return hasOwnProperty.call(it, key);\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_hide.js\": /*!***********************************************!*\\\n  !*** ./node_modules/core-js/modules/_hide.js ***!\n  \\***********************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_48606__) {\n            var dP = __nested_webpack_require_48606__(/*! ./_object-dp */ \"./node_modules/core-js/modules/_object-dp.js\");\n            var createDesc = __nested_webpack_require_48606__(/*! ./_property-desc */ \"./node_modules/core-js/modules/_property-desc.js\");\n            module1.exports = __nested_webpack_require_48606__(/*! ./_descriptors */ \"./node_modules/core-js/modules/_descriptors.js\") ? function(object, key, value) {\n                return dP.f(object, key, createDesc(1, value));\n            } : function(object, key, value) {\n                object[key] = value;\n                return object;\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_html.js\": /*!***********************************************!*\\\n  !*** ./node_modules/core-js/modules/_html.js ***!\n  \\***********************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_49511__) {\n            var document = __nested_webpack_require_49511__(/*! ./_global */ \"./node_modules/core-js/modules/_global.js\").document;\n            module1.exports = document && document.documentElement;\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_ie8-dom-define.js\": /*!*********************************************************!*\\\n  !*** ./node_modules/core-js/modules/_ie8-dom-define.js ***!\n  \\*********************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_50058__) {\n            module1.exports = !__nested_webpack_require_50058__(/*! ./_descriptors */ \"./node_modules/core-js/modules/_descriptors.js\") && !__nested_webpack_require_50058__(/*! ./_fails */ \"./node_modules/core-js/modules/_fails.js\")(function() {\n                return Object.defineProperty(__nested_webpack_require_50058__(/*! ./_dom-create */ \"./node_modules/core-js/modules/_dom-create.js\")(\"div\"), \"a\", {\n                    get: function() {\n                        return 7;\n                    }\n                }).a != 7;\n            });\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_invoke.js\": /*!*************************************************!*\\\n  !*** ./node_modules/core-js/modules/_invoke.js ***!\n  \\*************************************************/ /*! no static exports found */ /***/ function(module1, exports1) {\n            // fast apply, http://jsperf.lnkit.com/fast-apply/5\n            module1.exports = function(fn, args, that) {\n                var un = that === undefined;\n                switch(args.length){\n                    case 0:\n                        return un ? fn() : fn.call(that);\n                    case 1:\n                        return un ? fn(args[0]) : fn.call(that, args[0]);\n                    case 2:\n                        return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);\n                    case 3:\n                        return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);\n                    case 4:\n                        return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);\n                }\n                return fn.apply(that, args);\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_iobject.js\": /*!**************************************************!*\\\n  !*** ./node_modules/core-js/modules/_iobject.js ***!\n  \\**************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_52087__) {\n            // fallback for non-array-like ES3 and non-enumerable old V8 strings\n            var cof = __nested_webpack_require_52087__(/*! ./_cof */ \"./node_modules/core-js/modules/_cof.js\");\n            // eslint-disable-next-line no-prototype-builtins\n            module1.exports = Object(\"z\").propertyIsEnumerable(0) ? Object : function(it) {\n                return cof(it) == \"String\" ? it.split(\"\") : Object(it);\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_is-array-iter.js\": /*!********************************************************!*\\\n  !*** ./node_modules/core-js/modules/_is-array-iter.js ***!\n  \\********************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_52864__) {\n            // check on default Array iterator\n            var Iterators = __nested_webpack_require_52864__(/*! ./_iterators */ \"./node_modules/core-js/modules/_iterators.js\");\n            var ITERATOR = __nested_webpack_require_52864__(/*! ./_wks */ \"./node_modules/core-js/modules/_wks.js\")(\"iterator\");\n            var ArrayProto = Array.prototype;\n            module1.exports = function(it) {\n                return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_is-array.js\": /*!***************************************************!*\\\n  !*** ./node_modules/core-js/modules/_is-array.js ***!\n  \\***************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_53686__) {\n            // 7.2.2 IsArray(argument)\n            var cof = __nested_webpack_require_53686__(/*! ./_cof */ \"./node_modules/core-js/modules/_cof.js\");\n            module1.exports = Array.isArray || function isArray(arg) {\n                return cof(arg) == \"Array\";\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_is-object.js\": /*!****************************************************!*\\\n  !*** ./node_modules/core-js/modules/_is-object.js ***!\n  \\****************************************************/ /*! no static exports found */ /***/ function(module1, exports1) {\n            module1.exports = function(it) {\n                return typeof it === \"object\" ? it !== null : typeof it === \"function\";\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_is-regexp.js\": /*!****************************************************!*\\\n  !*** ./node_modules/core-js/modules/_is-regexp.js ***!\n  \\****************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_54761__) {\n            // 7.2.8 IsRegExp(argument)\n            var isObject = __nested_webpack_require_54761__(/*! ./_is-object */ \"./node_modules/core-js/modules/_is-object.js\");\n            var cof = __nested_webpack_require_54761__(/*! ./_cof */ \"./node_modules/core-js/modules/_cof.js\");\n            var MATCH = __nested_webpack_require_54761__(/*! ./_wks */ \"./node_modules/core-js/modules/_wks.js\")(\"match\");\n            module1.exports = function(it) {\n                var isRegExp;\n                return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == \"RegExp\");\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_iter-call.js\": /*!****************************************************!*\\\n  !*** ./node_modules/core-js/modules/_iter-call.js ***!\n  \\****************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_55670__) {\n            // call something on iterator step with safe closing on error\n            var anObject = __nested_webpack_require_55670__(/*! ./_an-object */ \"./node_modules/core-js/modules/_an-object.js\");\n            module1.exports = function(iterator, fn, value, entries) {\n                try {\n                    return entries ? fn(anObject(value)[0], value[1]) : fn(value);\n                // 7.4.6 IteratorClose(iterator, completion)\n                } catch (e) {\n                    var ret = iterator[\"return\"];\n                    if (ret !== undefined) anObject(ret.call(iterator));\n                    throw e;\n                }\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_iter-create.js\": /*!******************************************************!*\\\n  !*** ./node_modules/core-js/modules/_iter-create.js ***!\n  \\******************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_56660__) {\n            \"use strict\";\n            var create = __nested_webpack_require_56660__(/*! ./_object-create */ \"./node_modules/core-js/modules/_object-create.js\");\n            var descriptor = __nested_webpack_require_56660__(/*! ./_property-desc */ \"./node_modules/core-js/modules/_property-desc.js\");\n            var setToStringTag = __nested_webpack_require_56660__(/*! ./_set-to-string-tag */ \"./node_modules/core-js/modules/_set-to-string-tag.js\");\n            var IteratorPrototype = {};\n            // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n            __nested_webpack_require_56660__(/*! ./_hide */ \"./node_modules/core-js/modules/_hide.js\")(IteratorPrototype, __nested_webpack_require_56660__(/*! ./_wks */ \"./node_modules/core-js/modules/_wks.js\")(\"iterator\"), function() {\n                return this;\n            });\n            module1.exports = function(Constructor, NAME, next) {\n                Constructor.prototype = create(IteratorPrototype, {\n                    next: descriptor(1, next)\n                });\n                setToStringTag(Constructor, NAME + \" Iterator\");\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_iter-define.js\": /*!******************************************************!*\\\n  !*** ./node_modules/core-js/modules/_iter-define.js ***!\n  \\******************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_58056__) {\n            \"use strict\";\n            var LIBRARY = __nested_webpack_require_58056__(/*! ./_library */ \"./node_modules/core-js/modules/_library.js\");\n            var $export = __nested_webpack_require_58056__(/*! ./_export */ \"./node_modules/core-js/modules/_export.js\");\n            var redefine = __nested_webpack_require_58056__(/*! ./_redefine */ \"./node_modules/core-js/modules/_redefine.js\");\n            var hide = __nested_webpack_require_58056__(/*! ./_hide */ \"./node_modules/core-js/modules/_hide.js\");\n            var Iterators = __nested_webpack_require_58056__(/*! ./_iterators */ \"./node_modules/core-js/modules/_iterators.js\");\n            var $iterCreate = __nested_webpack_require_58056__(/*! ./_iter-create */ \"./node_modules/core-js/modules/_iter-create.js\");\n            var setToStringTag = __nested_webpack_require_58056__(/*! ./_set-to-string-tag */ \"./node_modules/core-js/modules/_set-to-string-tag.js\");\n            var getPrototypeOf = __nested_webpack_require_58056__(/*! ./_object-gpo */ \"./node_modules/core-js/modules/_object-gpo.js\");\n            var ITERATOR = __nested_webpack_require_58056__(/*! ./_wks */ \"./node_modules/core-js/modules/_wks.js\")(\"iterator\");\n            var BUGGY = !([].keys && \"next\" in [].keys()); // Safari has buggy iterators w/o `next`\n            var FF_ITERATOR = \"@@iterator\";\n            var KEYS = \"keys\";\n            var VALUES = \"values\";\n            var returnThis = function() {\n                return this;\n            };\n            module1.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {\n                $iterCreate(Constructor, NAME, next);\n                var getMethod = function(kind) {\n                    if (!BUGGY && kind in proto) return proto[kind];\n                    switch(kind){\n                        case KEYS:\n                            return function keys() {\n                                return new Constructor(this, kind);\n                            };\n                        case VALUES:\n                            return function values() {\n                                return new Constructor(this, kind);\n                            };\n                    }\n                    return function entries() {\n                        return new Constructor(this, kind);\n                    };\n                };\n                var TAG = NAME + \" Iterator\";\n                var DEF_VALUES = DEFAULT == VALUES;\n                var VALUES_BUG = false;\n                var proto = Base.prototype;\n                var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];\n                var $default = $native || getMethod(DEFAULT);\n                var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod(\"entries\") : undefined;\n                var $anyNative = NAME == \"Array\" ? proto.entries || $native : $native;\n                var methods, key, IteratorPrototype;\n                // Fix native\n                if ($anyNative) {\n                    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));\n                    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {\n                        // Set @@toStringTag to native iterators\n                        setToStringTag(IteratorPrototype, TAG, true);\n                        // fix for some old engines\n                        if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != \"function\") hide(IteratorPrototype, ITERATOR, returnThis);\n                    }\n                }\n                // fix Array#{values, @@iterator}.name in V8 / FF\n                if (DEF_VALUES && $native && $native.name !== VALUES) {\n                    VALUES_BUG = true;\n                    $default = function values() {\n                        return $native.call(this);\n                    };\n                }\n                // Define iterator\n                if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {\n                    hide(proto, ITERATOR, $default);\n                }\n                // Plug for library\n                Iterators[NAME] = $default;\n                Iterators[TAG] = returnThis;\n                if (DEFAULT) {\n                    methods = {\n                        values: DEF_VALUES ? $default : getMethod(VALUES),\n                        keys: IS_SET ? $default : getMethod(KEYS),\n                        entries: $entries\n                    };\n                    if (FORCED) for(key in methods){\n                        if (!(key in proto)) redefine(proto, key, methods[key]);\n                    }\n                    else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n                }\n                return methods;\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_iter-detect.js\": /*!******************************************************!*\\\n  !*** ./node_modules/core-js/modules/_iter-detect.js ***!\n  \\******************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_63047__) {\n            var ITERATOR = __nested_webpack_require_63047__(/*! ./_wks */ \"./node_modules/core-js/modules/_wks.js\")(\"iterator\");\n            var SAFE_CLOSING = false;\n            try {\n                var riter = [\n                    7\n                ][ITERATOR]();\n                riter[\"return\"] = function() {\n                    SAFE_CLOSING = true;\n                };\n                // eslint-disable-next-line no-throw-literal\n                Array.from(riter, function() {\n                    throw 2;\n                });\n            } catch (e) {}\n            module1.exports = function(exec, skipClosing) {\n                if (!skipClosing && !SAFE_CLOSING) return false;\n                var safe = false;\n                try {\n                    var arr = [\n                        7\n                    ];\n                    var iter = arr[ITERATOR]();\n                    iter.next = function() {\n                        return {\n                            done: safe = true\n                        };\n                    };\n                    arr[ITERATOR] = function() {\n                        return iter;\n                    };\n                    exec(arr);\n                } catch (e) {}\n                return safe;\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_iter-step.js\": /*!****************************************************!*\\\n  !*** ./node_modules/core-js/modules/_iter-step.js ***!\n  \\****************************************************/ /*! no static exports found */ /***/ function(module1, exports1) {\n            module1.exports = function(done, value) {\n                return {\n                    value: value,\n                    done: !!done\n                };\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_iterators.js\": /*!****************************************************!*\\\n  !*** ./node_modules/core-js/modules/_iterators.js ***!\n  \\****************************************************/ /*! no static exports found */ /***/ function(module1, exports1) {\n            module1.exports = {};\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_library.js\": /*!**************************************************!*\\\n  !*** ./node_modules/core-js/modules/_library.js ***!\n  \\**************************************************/ /*! no static exports found */ /***/ function(module1, exports1) {\n            module1.exports = false;\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_meta.js\": /*!***********************************************!*\\\n  !*** ./node_modules/core-js/modules/_meta.js ***!\n  \\***********************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_65812__) {\n            var META = __nested_webpack_require_65812__(/*! ./_uid */ \"./node_modules/core-js/modules/_uid.js\")(\"meta\");\n            var isObject = __nested_webpack_require_65812__(/*! ./_is-object */ \"./node_modules/core-js/modules/_is-object.js\");\n            var has = __nested_webpack_require_65812__(/*! ./_has */ \"./node_modules/core-js/modules/_has.js\");\n            var setDesc = __nested_webpack_require_65812__(/*! ./_object-dp */ \"./node_modules/core-js/modules/_object-dp.js\").f;\n            var id = 0;\n            var isExtensible = Object.isExtensible || function() {\n                return true;\n            };\n            var FREEZE = !__nested_webpack_require_65812__(/*! ./_fails */ \"./node_modules/core-js/modules/_fails.js\")(function() {\n                return isExtensible(Object.preventExtensions({}));\n            });\n            var setMeta = function(it) {\n                setDesc(it, META, {\n                    value: {\n                        i: \"O\" + ++id,\n                        w: {} // weak collections IDs\n                    }\n                });\n            };\n            var fastKey = function(it, create) {\n                // return primitive with prefix\n                if (!isObject(it)) return typeof it == \"symbol\" ? it : (typeof it == \"string\" ? \"S\" : \"P\") + it;\n                if (!has(it, META)) {\n                    // can't set metadata to uncaught frozen object\n                    if (!isExtensible(it)) return \"F\";\n                    // not necessary to add metadata\n                    if (!create) return \"E\";\n                    // add missing metadata\n                    setMeta(it);\n                // return object ID\n                }\n                return it[META].i;\n            };\n            var getWeak = function(it, create) {\n                if (!has(it, META)) {\n                    // can't set metadata to uncaught frozen object\n                    if (!isExtensible(it)) return true;\n                    // not necessary to add metadata\n                    if (!create) return false;\n                    // add missing metadata\n                    setMeta(it);\n                // return hash weak collections IDs\n                }\n                return it[META].w;\n            };\n            // add metadata on freeze-family methods calling\n            var onFreeze = function(it) {\n                if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);\n                return it;\n            };\n            var meta = module1.exports = {\n                KEY: META,\n                NEED: false,\n                fastKey: fastKey,\n                getWeak: getWeak,\n                onFreeze: onFreeze\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_object-create.js\": /*!********************************************************!*\\\n  !*** ./node_modules/core-js/modules/_object-create.js ***!\n  \\********************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_68813__) {\n            // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\n            var anObject = __nested_webpack_require_68813__(/*! ./_an-object */ \"./node_modules/core-js/modules/_an-object.js\");\n            var dPs = __nested_webpack_require_68813__(/*! ./_object-dps */ \"./node_modules/core-js/modules/_object-dps.js\");\n            var enumBugKeys = __nested_webpack_require_68813__(/*! ./_enum-bug-keys */ \"./node_modules/core-js/modules/_enum-bug-keys.js\");\n            var IE_PROTO = __nested_webpack_require_68813__(/*! ./_shared-key */ \"./node_modules/core-js/modules/_shared-key.js\")(\"IE_PROTO\");\n            var Empty = function() {};\n            var PROTOTYPE = \"prototype\";\n            // Create object with fake `null` prototype: use iframe Object with cleared prototype\n            var createDict = function() {\n                // Thrash, waste and sodomy: IE GC bug\n                var iframe = __nested_webpack_require_68813__(/*! ./_dom-create */ \"./node_modules/core-js/modules/_dom-create.js\")(\"iframe\");\n                var i = enumBugKeys.length;\n                var lt = \"<\";\n                var gt = \">\";\n                var iframeDocument;\n                iframe.style.display = \"none\";\n                __nested_webpack_require_68813__(/*! ./_html */ \"./node_modules/core-js/modules/_html.js\").appendChild(iframe);\n                iframe.src = \"javascript:\"; // eslint-disable-line no-script-url\n                // createDict = iframe.contentWindow.Object;\n                // html.removeChild(iframe);\n                iframeDocument = iframe.contentWindow.document;\n                iframeDocument.open();\n                iframeDocument.write(lt + \"script\" + gt + \"document.F=Object\" + lt + \"/script\" + gt);\n                iframeDocument.close();\n                createDict = iframeDocument.F;\n                while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];\n                return createDict();\n            };\n            module1.exports = Object.create || function create(O, Properties) {\n                var result;\n                if (O !== null) {\n                    Empty[PROTOTYPE] = anObject(O);\n                    result = new Empty();\n                    Empty[PROTOTYPE] = null;\n                    // add \"__proto__\" for Object.getPrototypeOf polyfill\n                    result[IE_PROTO] = O;\n                } else result = createDict();\n                return Properties === undefined ? result : dPs(result, Properties);\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_object-dp.js\": /*!****************************************************!*\\\n  !*** ./node_modules/core-js/modules/_object-dp.js ***!\n  \\****************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_71558__) {\n            var anObject = __nested_webpack_require_71558__(/*! ./_an-object */ \"./node_modules/core-js/modules/_an-object.js\");\n            var IE8_DOM_DEFINE = __nested_webpack_require_71558__(/*! ./_ie8-dom-define */ \"./node_modules/core-js/modules/_ie8-dom-define.js\");\n            var toPrimitive = __nested_webpack_require_71558__(/*! ./_to-primitive */ \"./node_modules/core-js/modules/_to-primitive.js\");\n            var dP = Object.defineProperty;\n            exports1.f = __nested_webpack_require_71558__(/*! ./_descriptors */ \"./node_modules/core-js/modules/_descriptors.js\") ? Object.defineProperty : function defineProperty(O, P, Attributes) {\n                anObject(O);\n                P = toPrimitive(P, true);\n                anObject(Attributes);\n                if (IE8_DOM_DEFINE) try {\n                    return dP(O, P, Attributes);\n                } catch (e) {}\n                if (\"get\" in Attributes || \"set\" in Attributes) throw TypeError(\"Accessors not supported!\");\n                if (\"value\" in Attributes) O[P] = Attributes.value;\n                return O;\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_object-dps.js\": /*!*****************************************************!*\\\n  !*** ./node_modules/core-js/modules/_object-dps.js ***!\n  \\*****************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_72955__) {\n            var dP = __nested_webpack_require_72955__(/*! ./_object-dp */ \"./node_modules/core-js/modules/_object-dp.js\");\n            var anObject = __nested_webpack_require_72955__(/*! ./_an-object */ \"./node_modules/core-js/modules/_an-object.js\");\n            var getKeys = __nested_webpack_require_72955__(/*! ./_object-keys */ \"./node_modules/core-js/modules/_object-keys.js\");\n            module1.exports = __nested_webpack_require_72955__(/*! ./_descriptors */ \"./node_modules/core-js/modules/_descriptors.js\") ? Object.defineProperties : function defineProperties(O, Properties) {\n                anObject(O);\n                var keys = getKeys(Properties);\n                var length = keys.length;\n                var i = 0;\n                var P;\n                while(length > i)dP.f(O, P = keys[i++], Properties[P]);\n                return O;\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_object-gopd.js\": /*!******************************************************!*\\\n  !*** ./node_modules/core-js/modules/_object-gopd.js ***!\n  \\******************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_74123__) {\n            var pIE = __nested_webpack_require_74123__(/*! ./_object-pie */ \"./node_modules/core-js/modules/_object-pie.js\");\n            var createDesc = __nested_webpack_require_74123__(/*! ./_property-desc */ \"./node_modules/core-js/modules/_property-desc.js\");\n            var toIObject = __nested_webpack_require_74123__(/*! ./_to-iobject */ \"./node_modules/core-js/modules/_to-iobject.js\");\n            var toPrimitive = __nested_webpack_require_74123__(/*! ./_to-primitive */ \"./node_modules/core-js/modules/_to-primitive.js\");\n            var has = __nested_webpack_require_74123__(/*! ./_has */ \"./node_modules/core-js/modules/_has.js\");\n            var IE8_DOM_DEFINE = __nested_webpack_require_74123__(/*! ./_ie8-dom-define */ \"./node_modules/core-js/modules/_ie8-dom-define.js\");\n            var gOPD = Object.getOwnPropertyDescriptor;\n            exports1.f = __nested_webpack_require_74123__(/*! ./_descriptors */ \"./node_modules/core-js/modules/_descriptors.js\") ? gOPD : function getOwnPropertyDescriptor(O, P) {\n                O = toIObject(O);\n                P = toPrimitive(P, true);\n                if (IE8_DOM_DEFINE) try {\n                    return gOPD(O, P);\n                } catch (e) {}\n                if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_object-gopn-ext.js\": /*!**********************************************************!*\\\n  !*** ./node_modules/core-js/modules/_object-gopn-ext.js ***!\n  \\**********************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_75703__) {\n            // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\n            var toIObject = __nested_webpack_require_75703__(/*! ./_to-iobject */ \"./node_modules/core-js/modules/_to-iobject.js\");\n            var gOPN = __nested_webpack_require_75703__(/*! ./_object-gopn */ \"./node_modules/core-js/modules/_object-gopn.js\").f;\n            var toString = {}.toString;\n            var windowNames =  false ? 0 : [];\n            var getWindowNames = function(it) {\n                try {\n                    return gOPN(it);\n                } catch (e) {\n                    return windowNames.slice();\n                }\n            };\n            module1.exports.f = function getOwnPropertyNames(it) {\n                return windowNames && toString.call(it) == \"[object Window]\" ? getWindowNames(it) : gOPN(toIObject(it));\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_object-gopn.js\": /*!******************************************************!*\\\n  !*** ./node_modules/core-js/modules/_object-gopn.js ***!\n  \\******************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_76975__) {\n            // 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\n            var $keys = __nested_webpack_require_76975__(/*! ./_object-keys-internal */ \"./node_modules/core-js/modules/_object-keys-internal.js\");\n            var hiddenKeys = __nested_webpack_require_76975__(/*! ./_enum-bug-keys */ \"./node_modules/core-js/modules/_enum-bug-keys.js\").concat(\"length\", \"prototype\");\n            exports1.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n                return $keys(O, hiddenKeys);\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_object-gops.js\": /*!******************************************************!*\\\n  !*** ./node_modules/core-js/modules/_object-gops.js ***!\n  \\******************************************************/ /*! no static exports found */ /***/ function(module1, exports1) {\n            exports1.f = Object.getOwnPropertySymbols;\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_object-gpo.js\": /*!*****************************************************!*\\\n  !*** ./node_modules/core-js/modules/_object-gpo.js ***!\n  \\*****************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_78206__) {\n            // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\n            var has = __nested_webpack_require_78206__(/*! ./_has */ \"./node_modules/core-js/modules/_has.js\");\n            var toObject = __nested_webpack_require_78206__(/*! ./_to-object */ \"./node_modules/core-js/modules/_to-object.js\");\n            var IE_PROTO = __nested_webpack_require_78206__(/*! ./_shared-key */ \"./node_modules/core-js/modules/_shared-key.js\")(\"IE_PROTO\");\n            var ObjectProto = Object.prototype;\n            module1.exports = Object.getPrototypeOf || function(O) {\n                O = toObject(O);\n                if (has(O, IE_PROTO)) return O[IE_PROTO];\n                if (typeof O.constructor == \"function\" && O instanceof O.constructor) {\n                    return O.constructor.prototype;\n                }\n                return O instanceof Object ? ObjectProto : null;\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_object-keys-internal.js\": /*!***************************************************************!*\\\n  !*** ./node_modules/core-js/modules/_object-keys-internal.js ***!\n  \\***************************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_79441__) {\n            var has = __nested_webpack_require_79441__(/*! ./_has */ \"./node_modules/core-js/modules/_has.js\");\n            var toIObject = __nested_webpack_require_79441__(/*! ./_to-iobject */ \"./node_modules/core-js/modules/_to-iobject.js\");\n            var arrayIndexOf = __nested_webpack_require_79441__(/*! ./_array-includes */ \"./node_modules/core-js/modules/_array-includes.js\")(false);\n            var IE_PROTO = __nested_webpack_require_79441__(/*! ./_shared-key */ \"./node_modules/core-js/modules/_shared-key.js\")(\"IE_PROTO\");\n            module1.exports = function(object, names) {\n                var O = toIObject(object);\n                var i = 0;\n                var result = [];\n                var key;\n                for(key in O)if (key != IE_PROTO) has(O, key) && result.push(key);\n                // Don't enum bug & hidden keys\n                while(names.length > i)if (has(O, key = names[i++])) {\n                    ~arrayIndexOf(result, key) || result.push(key);\n                }\n                return result;\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_object-keys.js\": /*!******************************************************!*\\\n  !*** ./node_modules/core-js/modules/_object-keys.js ***!\n  \\******************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_80792__) {\n            // 19.1.2.14 / 15.2.3.14 Object.keys(O)\n            var $keys = __nested_webpack_require_80792__(/*! ./_object-keys-internal */ \"./node_modules/core-js/modules/_object-keys-internal.js\");\n            var enumBugKeys = __nested_webpack_require_80792__(/*! ./_enum-bug-keys */ \"./node_modules/core-js/modules/_enum-bug-keys.js\");\n            module1.exports = Object.keys || function keys(O) {\n                return $keys(O, enumBugKeys);\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_object-pie.js\": /*!*****************************************************!*\\\n  !*** ./node_modules/core-js/modules/_object-pie.js ***!\n  \\*****************************************************/ /*! no static exports found */ /***/ function(module1, exports1) {\n            exports1.f = ({}).propertyIsEnumerable;\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_own-keys.js\": /*!***************************************************!*\\\n  !*** ./node_modules/core-js/modules/_own-keys.js ***!\n  \\***************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_81942__) {\n            // all object keys, includes non-enumerable and symbols\n            var gOPN = __nested_webpack_require_81942__(/*! ./_object-gopn */ \"./node_modules/core-js/modules/_object-gopn.js\");\n            var gOPS = __nested_webpack_require_81942__(/*! ./_object-gops */ \"./node_modules/core-js/modules/_object-gops.js\");\n            var anObject = __nested_webpack_require_81942__(/*! ./_an-object */ \"./node_modules/core-js/modules/_an-object.js\");\n            var Reflect = __nested_webpack_require_81942__(/*! ./_global */ \"./node_modules/core-js/modules/_global.js\").Reflect;\n            module1.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {\n                var keys = gOPN.f(anObject(it));\n                var getSymbols = gOPS.f;\n                return getSymbols ? keys.concat(getSymbols(it)) : keys;\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_property-desc.js\": /*!********************************************************!*\\\n  !*** ./node_modules/core-js/modules/_property-desc.js ***!\n  \\********************************************************/ /*! no static exports found */ /***/ function(module1, exports1) {\n            module1.exports = function(bitmap, value) {\n                return {\n                    enumerable: !(bitmap & 1),\n                    configurable: !(bitmap & 2),\n                    writable: !(bitmap & 4),\n                    value: value\n                };\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_redefine.js\": /*!***************************************************!*\\\n  !*** ./node_modules/core-js/modules/_redefine.js ***!\n  \\***************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_83695__) {\n            var global1 = __nested_webpack_require_83695__(/*! ./_global */ \"./node_modules/core-js/modules/_global.js\");\n            var hide = __nested_webpack_require_83695__(/*! ./_hide */ \"./node_modules/core-js/modules/_hide.js\");\n            var has = __nested_webpack_require_83695__(/*! ./_has */ \"./node_modules/core-js/modules/_has.js\");\n            var SRC = __nested_webpack_require_83695__(/*! ./_uid */ \"./node_modules/core-js/modules/_uid.js\")(\"src\");\n            var $toString = __nested_webpack_require_83695__(/*! ./_function-to-string */ \"./node_modules/core-js/modules/_function-to-string.js\");\n            var TO_STRING = \"toString\";\n            var TPL = (\"\" + $toString).split(TO_STRING);\n            __nested_webpack_require_83695__(/*! ./_core */ \"./node_modules/core-js/modules/_core.js\").inspectSource = function(it) {\n                return $toString.call(it);\n            };\n            (module1.exports = function(O, key, val, safe) {\n                var isFunction = typeof val == \"function\";\n                if (isFunction) has(val, \"name\") || hide(val, \"name\", key);\n                if (O[key] === val) return;\n                if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? \"\" + O[key] : TPL.join(String(key)));\n                if (O === global1) {\n                    O[key] = val;\n                } else if (!safe) {\n                    delete O[key];\n                    hide(O, key, val);\n                } else if (O[key]) {\n                    O[key] = val;\n                } else {\n                    hide(O, key, val);\n                }\n            // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n            })(Function.prototype, TO_STRING, function toString() {\n                return typeof this == \"function\" && this[SRC] || $toString.call(this);\n            });\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_regexp-exec-abstract.js\": /*!***************************************************************!*\\\n  !*** ./node_modules/core-js/modules/_regexp-exec-abstract.js ***!\n  \\***************************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_85886__) {\n            \"use strict\";\n            var classof = __nested_webpack_require_85886__(/*! ./_classof */ \"./node_modules/core-js/modules/_classof.js\");\n            var builtinExec = RegExp.prototype.exec;\n            // `RegExpExec` abstract operation\n            // https://tc39.github.io/ecma262/#sec-regexpexec\n            module1.exports = function(R, S) {\n                var exec = R.exec;\n                if (typeof exec === \"function\") {\n                    var result = exec.call(R, S);\n                    if (typeof result !== \"object\") {\n                        throw new TypeError(\"RegExp exec method returned something other than an Object or null\");\n                    }\n                    return result;\n                }\n                if (classof(R) !== \"RegExp\") {\n                    throw new TypeError(\"RegExp#exec called on incompatible receiver\");\n                }\n                return builtinExec.call(R, S);\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_regexp-exec.js\": /*!******************************************************!*\\\n  !*** ./node_modules/core-js/modules/_regexp-exec.js ***!\n  \\******************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_87174__) {\n            \"use strict\";\n            var regexpFlags = __nested_webpack_require_87174__(/*! ./_flags */ \"./node_modules/core-js/modules/_flags.js\");\n            var nativeExec = RegExp.prototype.exec;\n            // This always refers to the native implementation, because the\n            // String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,\n            // which loads this file before patching the method.\n            var nativeReplace = String.prototype.replace;\n            var patchedExec = nativeExec;\n            var LAST_INDEX = \"lastIndex\";\n            var UPDATES_LAST_INDEX_WRONG = function() {\n                var re1 = /a/, re2 = /b*/g;\n                nativeExec.call(re1, \"a\");\n                nativeExec.call(re2, \"a\");\n                return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;\n            }();\n            // nonparticipating capturing group, copied from es5-shim's String#split patch.\n            var NPCG_INCLUDED = /()??/.exec(\"\")[1] !== undefined;\n            var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;\n            if (PATCH) {\n                patchedExec = function exec(str) {\n                    var re = this;\n                    var lastIndex, reCopy, match, i;\n                    if (NPCG_INCLUDED) {\n                        reCopy = new RegExp(\"^\" + re.source + \"$(?!\\\\s)\", regexpFlags.call(re));\n                    }\n                    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];\n                    match = nativeExec.call(re, str);\n                    if (UPDATES_LAST_INDEX_WRONG && match) {\n                        re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;\n                    }\n                    if (NPCG_INCLUDED && match && match.length > 1) {\n                        // Fix browsers whose `exec` methods don't consistently return `undefined`\n                        // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/\n                        // eslint-disable-next-line no-loop-func\n                        nativeReplace.call(match[0], reCopy, function() {\n                            for(i = 1; i < arguments.length - 2; i++){\n                                if (arguments[i] === undefined) match[i] = undefined;\n                            }\n                        });\n                    }\n                    return match;\n                };\n            }\n            module1.exports = patchedExec;\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_set-to-string-tag.js\": /*!************************************************************!*\\\n  !*** ./node_modules/core-js/modules/_set-to-string-tag.js ***!\n  \\************************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_89974__) {\n            var def = __nested_webpack_require_89974__(/*! ./_object-dp */ \"./node_modules/core-js/modules/_object-dp.js\").f;\n            var has = __nested_webpack_require_89974__(/*! ./_has */ \"./node_modules/core-js/modules/_has.js\");\n            var TAG = __nested_webpack_require_89974__(/*! ./_wks */ \"./node_modules/core-js/modules/_wks.js\")(\"toStringTag\");\n            module1.exports = function(it, tag, stat) {\n                if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, {\n                    configurable: true,\n                    value: tag\n                });\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_shared-key.js\": /*!*****************************************************!*\\\n  !*** ./node_modules/core-js/modules/_shared-key.js ***!\n  \\*****************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_90889__) {\n            var shared = __nested_webpack_require_90889__(/*! ./_shared */ \"./node_modules/core-js/modules/_shared.js\")(\"keys\");\n            var uid = __nested_webpack_require_90889__(/*! ./_uid */ \"./node_modules/core-js/modules/_uid.js\");\n            module1.exports = function(key) {\n                return shared[key] || (shared[key] = uid(key));\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_shared.js\": /*!*************************************************!*\\\n  !*** ./node_modules/core-js/modules/_shared.js ***!\n  \\*************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_91557__) {\n            var core = __nested_webpack_require_91557__(/*! ./_core */ \"./node_modules/core-js/modules/_core.js\");\n            var global1 = __nested_webpack_require_91557__(/*! ./_global */ \"./node_modules/core-js/modules/_global.js\");\n            var SHARED = \"__core-js_shared__\";\n            var store = global1[SHARED] || (global1[SHARED] = {});\n            (module1.exports = function(key, value) {\n                return store[key] || (store[key] = value !== undefined ? value : {});\n            })(\"versions\", []).push({\n                version: core.version,\n                mode: __nested_webpack_require_91557__(/*! ./_library */ \"./node_modules/core-js/modules/_library.js\") ? \"pure\" : \"global\",\n                copyright: \"\\xa9 2020 Denis Pushkarev (zloirock.ru)\"\n            });\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_species-constructor.js\": /*!**************************************************************!*\\\n  !*** ./node_modules/core-js/modules/_species-constructor.js ***!\n  \\**************************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_92691__) {\n            // 7.3.20 SpeciesConstructor(O, defaultConstructor)\n            var anObject = __nested_webpack_require_92691__(/*! ./_an-object */ \"./node_modules/core-js/modules/_an-object.js\");\n            var aFunction = __nested_webpack_require_92691__(/*! ./_a-function */ \"./node_modules/core-js/modules/_a-function.js\");\n            var SPECIES = __nested_webpack_require_92691__(/*! ./_wks */ \"./node_modules/core-js/modules/_wks.js\")(\"species\");\n            module1.exports = function(O, D) {\n                var C = anObject(O).constructor;\n                var S;\n                return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_string-at.js\": /*!****************************************************!*\\\n  !*** ./node_modules/core-js/modules/_string-at.js ***!\n  \\****************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_93680__) {\n            var toInteger = __nested_webpack_require_93680__(/*! ./_to-integer */ \"./node_modules/core-js/modules/_to-integer.js\");\n            var defined = __nested_webpack_require_93680__(/*! ./_defined */ \"./node_modules/core-js/modules/_defined.js\");\n            // true  -> String#at\n            // false -> String#codePointAt\n            module1.exports = function(TO_STRING) {\n                return function(that, pos) {\n                    var s = String(defined(that));\n                    var i = toInteger(pos);\n                    var l = s.length;\n                    var a, b;\n                    if (i < 0 || i >= l) return TO_STRING ? \"\" : undefined;\n                    a = s.charCodeAt(i);\n                    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n                };\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_string-context.js\": /*!*********************************************************!*\\\n  !*** ./node_modules/core-js/modules/_string-context.js ***!\n  \\*********************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_94986__) {\n            // helper for String#{startsWith, endsWith, includes}\n            var isRegExp = __nested_webpack_require_94986__(/*! ./_is-regexp */ \"./node_modules/core-js/modules/_is-regexp.js\");\n            var defined = __nested_webpack_require_94986__(/*! ./_defined */ \"./node_modules/core-js/modules/_defined.js\");\n            module1.exports = function(that, searchString, NAME) {\n                if (isRegExp(searchString)) throw TypeError(\"String#\" + NAME + \" doesn't accept regex!\");\n                return String(defined(that));\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_to-absolute-index.js\": /*!************************************************************!*\\\n  !*** ./node_modules/core-js/modules/_to-absolute-index.js ***!\n  \\************************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_95885__) {\n            var toInteger = __nested_webpack_require_95885__(/*! ./_to-integer */ \"./node_modules/core-js/modules/_to-integer.js\");\n            var max = Math.max;\n            var min = Math.min;\n            module1.exports = function(index, length) {\n                index = toInteger(index);\n                return index < 0 ? max(index + length, 0) : min(index, length);\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_to-integer.js\": /*!*****************************************************!*\\\n  !*** ./node_modules/core-js/modules/_to-integer.js ***!\n  \\*****************************************************/ /*! no static exports found */ /***/ function(module1, exports1) {\n            // 7.1.4 ToInteger\n            var ceil = Math.ceil;\n            var floor = Math.floor;\n            module1.exports = function(it) {\n                return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_to-iobject.js\": /*!*****************************************************!*\\\n  !*** ./node_modules/core-js/modules/_to-iobject.js ***!\n  \\*****************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_97163__) {\n            // to indexed object, toObject with fallback for non-array-like ES3 strings\n            var IObject = __nested_webpack_require_97163__(/*! ./_iobject */ \"./node_modules/core-js/modules/_iobject.js\");\n            var defined = __nested_webpack_require_97163__(/*! ./_defined */ \"./node_modules/core-js/modules/_defined.js\");\n            module1.exports = function(it) {\n                return IObject(defined(it));\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_to-length.js\": /*!****************************************************!*\\\n  !*** ./node_modules/core-js/modules/_to-length.js ***!\n  \\****************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_97918__) {\n            // 7.1.15 ToLength\n            var toInteger = __nested_webpack_require_97918__(/*! ./_to-integer */ \"./node_modules/core-js/modules/_to-integer.js\");\n            var min = Math.min;\n            module1.exports = function(it) {\n                return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_to-object.js\": /*!****************************************************!*\\\n  !*** ./node_modules/core-js/modules/_to-object.js ***!\n  \\****************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_98612__) {\n            // 7.1.13 ToObject(argument)\n            var defined = __nested_webpack_require_98612__(/*! ./_defined */ \"./node_modules/core-js/modules/_defined.js\");\n            module1.exports = function(it) {\n                return Object(defined(it));\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_to-primitive.js\": /*!*******************************************************!*\\\n  !*** ./node_modules/core-js/modules/_to-primitive.js ***!\n  \\*******************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_99220__) {\n            // 7.1.1 ToPrimitive(input [, PreferredType])\n            var isObject = __nested_webpack_require_99220__(/*! ./_is-object */ \"./node_modules/core-js/modules/_is-object.js\");\n            // instead of the ES6 spec version, we didn't implement @@toPrimitive case\n            // and the second argument - flag - preferred type is a string\n            module1.exports = function(it, S) {\n                if (!isObject(it)) return it;\n                var fn, val;\n                if (S && typeof (fn = it.toString) == \"function\" && !isObject(val = fn.call(it))) return val;\n                if (typeof (fn = it.valueOf) == \"function\" && !isObject(val = fn.call(it))) return val;\n                if (!S && typeof (fn = it.toString) == \"function\" && !isObject(val = fn.call(it))) return val;\n                throw TypeError(\"Can't convert object to primitive value\");\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_uid.js\": /*!**********************************************!*\\\n  !*** ./node_modules/core-js/modules/_uid.js ***!\n  \\**********************************************/ /*! no static exports found */ /***/ function(module1, exports1) {\n            var id = 0;\n            var px = Math.random();\n            module1.exports = function(key) {\n                return \"Symbol(\".concat(key === undefined ? \"\" : key, \")_\", (++id + px).toString(36));\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_wks-define.js\": /*!*****************************************************!*\\\n  !*** ./node_modules/core-js/modules/_wks-define.js ***!\n  \\*****************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_100958__) {\n            var global1 = __nested_webpack_require_100958__(/*! ./_global */ \"./node_modules/core-js/modules/_global.js\");\n            var core = __nested_webpack_require_100958__(/*! ./_core */ \"./node_modules/core-js/modules/_core.js\");\n            var LIBRARY = __nested_webpack_require_100958__(/*! ./_library */ \"./node_modules/core-js/modules/_library.js\");\n            var wksExt = __nested_webpack_require_100958__(/*! ./_wks-ext */ \"./node_modules/core-js/modules/_wks-ext.js\");\n            var defineProperty = __nested_webpack_require_100958__(/*! ./_object-dp */ \"./node_modules/core-js/modules/_object-dp.js\").f;\n            module1.exports = function(name) {\n                var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global1.Symbol || {});\n                if (name.charAt(0) != \"_\" && !(name in $Symbol)) defineProperty($Symbol, name, {\n                    value: wksExt.f(name)\n                });\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_wks-ext.js\": /*!**************************************************!*\\\n  !*** ./node_modules/core-js/modules/_wks-ext.js ***!\n  \\**************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_102165__) {\n            exports1.f = __nested_webpack_require_102165__(/*! ./_wks */ \"./node_modules/core-js/modules/_wks.js\");\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/_wks.js\": /*!**********************************************!*\\\n  !*** ./node_modules/core-js/modules/_wks.js ***!\n  \\**********************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_102583__) {\n            var store = __nested_webpack_require_102583__(/*! ./_shared */ \"./node_modules/core-js/modules/_shared.js\")(\"wks\");\n            var uid = __nested_webpack_require_102583__(/*! ./_uid */ \"./node_modules/core-js/modules/_uid.js\");\n            var Symbol1 = __nested_webpack_require_102583__(/*! ./_global */ \"./node_modules/core-js/modules/_global.js\").Symbol;\n            var USE_SYMBOL = typeof Symbol1 == \"function\";\n            var $exports = module1.exports = function(name) {\n                return store[name] || (store[name] = USE_SYMBOL && Symbol1[name] || (USE_SYMBOL ? Symbol1 : uid)(\"Symbol.\" + name));\n            };\n            $exports.store = store;\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/core.get-iterator-method.js\": /*!******************************************************************!*\\\n  !*** ./node_modules/core-js/modules/core.get-iterator-method.js ***!\n  \\******************************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_103613__) {\n            var classof = __nested_webpack_require_103613__(/*! ./_classof */ \"./node_modules/core-js/modules/_classof.js\");\n            var ITERATOR = __nested_webpack_require_103613__(/*! ./_wks */ \"./node_modules/core-js/modules/_wks.js\")(\"iterator\");\n            var Iterators = __nested_webpack_require_103613__(/*! ./_iterators */ \"./node_modules/core-js/modules/_iterators.js\");\n            module1.exports = __nested_webpack_require_103613__(/*! ./_core */ \"./node_modules/core-js/modules/_core.js\").getIteratorMethod = function(it) {\n                if (it != undefined) return it[ITERATOR] || it[\"@@iterator\"] || Iterators[classof(it)];\n            };\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/es6.array.from.js\": /*!********************************************************!*\\\n  !*** ./node_modules/core-js/modules/es6.array.from.js ***!\n  \\********************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_104575__) {\n            \"use strict\";\n            var ctx = __nested_webpack_require_104575__(/*! ./_ctx */ \"./node_modules/core-js/modules/_ctx.js\");\n            var $export = __nested_webpack_require_104575__(/*! ./_export */ \"./node_modules/core-js/modules/_export.js\");\n            var toObject = __nested_webpack_require_104575__(/*! ./_to-object */ \"./node_modules/core-js/modules/_to-object.js\");\n            var call = __nested_webpack_require_104575__(/*! ./_iter-call */ \"./node_modules/core-js/modules/_iter-call.js\");\n            var isArrayIter = __nested_webpack_require_104575__(/*! ./_is-array-iter */ \"./node_modules/core-js/modules/_is-array-iter.js\");\n            var toLength = __nested_webpack_require_104575__(/*! ./_to-length */ \"./node_modules/core-js/modules/_to-length.js\");\n            var createProperty = __nested_webpack_require_104575__(/*! ./_create-property */ \"./node_modules/core-js/modules/_create-property.js\");\n            var getIterFn = __nested_webpack_require_104575__(/*! ./core.get-iterator-method */ \"./node_modules/core-js/modules/core.get-iterator-method.js\");\n            $export($export.S + $export.F * !__nested_webpack_require_104575__(/*! ./_iter-detect */ \"./node_modules/core-js/modules/_iter-detect.js\")(function(iter) {\n                Array.from(iter);\n            }), \"Array\", {\n                // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)\n                from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */ ) {\n                    var O = toObject(arrayLike);\n                    var C = typeof this == \"function\" ? this : Array;\n                    var aLen = arguments.length;\n                    var mapfn = aLen > 1 ? arguments[1] : undefined;\n                    var mapping = mapfn !== undefined;\n                    var index = 0;\n                    var iterFn = getIterFn(O);\n                    var length, result, step, iterator;\n                    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);\n                    // if object isn't iterable or it's array with default iterator - use simple case\n                    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {\n                        for(iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++){\n                            createProperty(result, index, mapping ? call(iterator, mapfn, [\n                                step.value,\n                                index\n                            ], true) : step.value);\n                        }\n                    } else {\n                        length = toLength(O.length);\n                        for(result = new C(length); length > index; index++){\n                            createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);\n                        }\n                    }\n                    result.length = index;\n                    return result;\n                }\n            });\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/es6.array.iterator.js\": /*!************************************************************!*\\\n  !*** ./node_modules/core-js/modules/es6.array.iterator.js ***!\n  \\************************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_107836__) {\n            \"use strict\";\n            var addToUnscopables = __nested_webpack_require_107836__(/*! ./_add-to-unscopables */ \"./node_modules/core-js/modules/_add-to-unscopables.js\");\n            var step = __nested_webpack_require_107836__(/*! ./_iter-step */ \"./node_modules/core-js/modules/_iter-step.js\");\n            var Iterators = __nested_webpack_require_107836__(/*! ./_iterators */ \"./node_modules/core-js/modules/_iterators.js\");\n            var toIObject = __nested_webpack_require_107836__(/*! ./_to-iobject */ \"./node_modules/core-js/modules/_to-iobject.js\");\n            // 22.1.3.4 Array.prototype.entries()\n            // 22.1.3.13 Array.prototype.keys()\n            // 22.1.3.29 Array.prototype.values()\n            // 22.1.3.30 Array.prototype[@@iterator]()\n            module1.exports = __nested_webpack_require_107836__(/*! ./_iter-define */ \"./node_modules/core-js/modules/_iter-define.js\")(Array, \"Array\", function(iterated, kind) {\n                this._t = toIObject(iterated); // target\n                this._i = 0; // next index\n                this._k = kind; // kind\n            // 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n            }, function() {\n                var O = this._t;\n                var kind = this._k;\n                var index = this._i++;\n                if (!O || index >= O.length) {\n                    this._t = undefined;\n                    return step(1);\n                }\n                if (kind == \"keys\") return step(0, index);\n                if (kind == \"values\") return step(0, O[index]);\n                return step(0, [\n                    index,\n                    O[index]\n                ]);\n            }, \"values\");\n            // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\n            Iterators.Arguments = Iterators.Array;\n            addToUnscopables(\"keys\");\n            addToUnscopables(\"values\");\n            addToUnscopables(\"entries\");\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/es6.function.bind.js\": /*!***********************************************************!*\\\n  !*** ./node_modules/core-js/modules/es6.function.bind.js ***!\n  \\***********************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_110075__) {\n            // 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)\n            var $export = __nested_webpack_require_110075__(/*! ./_export */ \"./node_modules/core-js/modules/_export.js\");\n            $export($export.P, \"Function\", {\n                bind: __nested_webpack_require_110075__(/*! ./_bind */ \"./node_modules/core-js/modules/_bind.js\")\n            });\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/es6.function.name.js\": /*!***********************************************************!*\\\n  !*** ./node_modules/core-js/modules/es6.function.name.js ***!\n  \\***********************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_110790__) {\n            var dP = __nested_webpack_require_110790__(/*! ./_object-dp */ \"./node_modules/core-js/modules/_object-dp.js\").f;\n            var FProto = Function.prototype;\n            var nameRE = /^\\s*function ([^ (]*)/;\n            var NAME = \"name\";\n            // 19.2.4.2 name\n            NAME in FProto || __nested_webpack_require_110790__(/*! ./_descriptors */ \"./node_modules/core-js/modules/_descriptors.js\") && dP(FProto, NAME, {\n                configurable: true,\n                get: function() {\n                    try {\n                        return (\"\" + this).match(nameRE)[1];\n                    } catch (e) {\n                        return \"\";\n                    }\n                }\n            });\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/es6.number.is-finite.js\": /*!**************************************************************!*\\\n  !*** ./node_modules/core-js/modules/es6.number.is-finite.js ***!\n  \\**************************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_111863__) {\n            // 20.1.2.2 Number.isFinite(number)\n            var $export = __nested_webpack_require_111863__(/*! ./_export */ \"./node_modules/core-js/modules/_export.js\");\n            var _isFinite = __nested_webpack_require_111863__(/*! ./_global */ \"./node_modules/core-js/modules/_global.js\").isFinite;\n            $export($export.S, \"Number\", {\n                isFinite: function isFinite(it) {\n                    return typeof it == \"number\" && _isFinite(it);\n                }\n            });\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/es6.object.to-string.js\": /*!**************************************************************!*\\\n  !*** ./node_modules/core-js/modules/es6.object.to-string.js ***!\n  \\**************************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_112714__) {\n            \"use strict\";\n            // 19.1.3.6 Object.prototype.toString()\n            var classof = __nested_webpack_require_112714__(/*! ./_classof */ \"./node_modules/core-js/modules/_classof.js\");\n            var test = {};\n            test[__nested_webpack_require_112714__(/*! ./_wks */ \"./node_modules/core-js/modules/_wks.js\")(\"toStringTag\")] = \"z\";\n            if (test + \"\" != \"[object z]\") {\n                __nested_webpack_require_112714__(/*! ./_redefine */ \"./node_modules/core-js/modules/_redefine.js\")(Object.prototype, \"toString\", function toString() {\n                    return \"[object \" + classof(this) + \"]\";\n                }, true);\n            }\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/es6.regexp.exec.js\": /*!*********************************************************!*\\\n  !*** ./node_modules/core-js/modules/es6.regexp.exec.js ***!\n  \\*********************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_113706__) {\n            \"use strict\";\n            var regexpExec = __nested_webpack_require_113706__(/*! ./_regexp-exec */ \"./node_modules/core-js/modules/_regexp-exec.js\");\n            __nested_webpack_require_113706__(/*! ./_export */ \"./node_modules/core-js/modules/_export.js\")({\n                target: \"RegExp\",\n                proto: true,\n                forced: regexpExec !== /./.exec\n            }, {\n                exec: regexpExec\n            });\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/es6.regexp.split.js\": /*!**********************************************************!*\\\n  !*** ./node_modules/core-js/modules/es6.regexp.split.js ***!\n  \\**********************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_114491__) {\n            \"use strict\";\n            var isRegExp = __nested_webpack_require_114491__(/*! ./_is-regexp */ \"./node_modules/core-js/modules/_is-regexp.js\");\n            var anObject = __nested_webpack_require_114491__(/*! ./_an-object */ \"./node_modules/core-js/modules/_an-object.js\");\n            var speciesConstructor = __nested_webpack_require_114491__(/*! ./_species-constructor */ \"./node_modules/core-js/modules/_species-constructor.js\");\n            var advanceStringIndex = __nested_webpack_require_114491__(/*! ./_advance-string-index */ \"./node_modules/core-js/modules/_advance-string-index.js\");\n            var toLength = __nested_webpack_require_114491__(/*! ./_to-length */ \"./node_modules/core-js/modules/_to-length.js\");\n            var callRegExpExec = __nested_webpack_require_114491__(/*! ./_regexp-exec-abstract */ \"./node_modules/core-js/modules/_regexp-exec-abstract.js\");\n            var regexpExec = __nested_webpack_require_114491__(/*! ./_regexp-exec */ \"./node_modules/core-js/modules/_regexp-exec.js\");\n            var fails = __nested_webpack_require_114491__(/*! ./_fails */ \"./node_modules/core-js/modules/_fails.js\");\n            var $min = Math.min;\n            var $push = [].push;\n            var $SPLIT = \"split\";\n            var LENGTH = \"length\";\n            var LAST_INDEX = \"lastIndex\";\n            var MAX_UINT32 = 0xffffffff;\n            // babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError\n            var SUPPORTS_Y = !fails(function() {\n                RegExp(MAX_UINT32, \"y\");\n            });\n            // @@split logic\n            __nested_webpack_require_114491__(/*! ./_fix-re-wks */ \"./node_modules/core-js/modules/_fix-re-wks.js\")(\"split\", 2, function(defined, SPLIT, $split, maybeCallNative) {\n                var internalSplit;\n                if (\"abbc\"[$SPLIT](/(b)*/)[1] == \"c\" || \"test\"[$SPLIT](/(?:)/, -1)[LENGTH] != 4 || \"ab\"[$SPLIT](/(?:ab)*/)[LENGTH] != 2 || \".\"[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 || \".\"[$SPLIT](/()()/)[LENGTH] > 1 || \"\"[$SPLIT](/.?/)[LENGTH]) {\n                    // based on es5-shim implementation, need to rework it\n                    internalSplit = function(separator, limit) {\n                        var string = String(this);\n                        if (separator === undefined && limit === 0) return [];\n                        // If `separator` is not a regex, use native split\n                        if (!isRegExp(separator)) return $split.call(string, separator, limit);\n                        var output = [];\n                        var flags = (separator.ignoreCase ? \"i\" : \"\") + (separator.multiline ? \"m\" : \"\") + (separator.unicode ? \"u\" : \"\") + (separator.sticky ? \"y\" : \"\");\n                        var lastLastIndex = 0;\n                        var splitLimit = limit === undefined ? MAX_UINT32 : limit >>> 0;\n                        // Make `global` and avoid `lastIndex` issues by working with a copy\n                        var separatorCopy = new RegExp(separator.source, flags + \"g\");\n                        var match, lastIndex, lastLength;\n                        while(match = regexpExec.call(separatorCopy, string)){\n                            lastIndex = separatorCopy[LAST_INDEX];\n                            if (lastIndex > lastLastIndex) {\n                                output.push(string.slice(lastLastIndex, match.index));\n                                if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));\n                                lastLength = match[0][LENGTH];\n                                lastLastIndex = lastIndex;\n                                if (output[LENGTH] >= splitLimit) break;\n                            }\n                            if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop\n                        }\n                        if (lastLastIndex === string[LENGTH]) {\n                            if (lastLength || !separatorCopy.test(\"\")) output.push(\"\");\n                        } else output.push(string.slice(lastLastIndex));\n                        return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;\n                    };\n                // Chakra, V8\n                } else if (\"0\"[$SPLIT](undefined, 0)[LENGTH]) {\n                    internalSplit = function(separator, limit) {\n                        return separator === undefined && limit === 0 ? [] : $split.call(this, separator, limit);\n                    };\n                } else {\n                    internalSplit = $split;\n                }\n                return [\n                    // `String.prototype.split` method\n                    // https://tc39.github.io/ecma262/#sec-string.prototype.split\n                    function split(separator, limit) {\n                        var O = defined(this);\n                        var splitter = separator == undefined ? undefined : separator[SPLIT];\n                        return splitter !== undefined ? splitter.call(separator, O, limit) : internalSplit.call(String(O), separator, limit);\n                    },\n                    // `RegExp.prototype[@@split]` method\n                    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split\n                    //\n                    // NOTE: This cannot be properly polyfilled in engines that don't support\n                    // the 'y' flag.\n                    function(regexp, limit) {\n                        var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split);\n                        if (res.done) return res.value;\n                        var rx = anObject(regexp);\n                        var S = String(this);\n                        var C = speciesConstructor(rx, RegExp);\n                        var unicodeMatching = rx.unicode;\n                        var flags = (rx.ignoreCase ? \"i\" : \"\") + (rx.multiline ? \"m\" : \"\") + (rx.unicode ? \"u\" : \"\") + (SUPPORTS_Y ? \"y\" : \"g\");\n                        // ^(? + rx + ) is needed, in combination with some S slicing, to\n                        // simulate the 'y' flag.\n                        var splitter = new C(SUPPORTS_Y ? rx : \"^(?:\" + rx.source + \")\", flags);\n                        var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;\n                        if (lim === 0) return [];\n                        if (S.length === 0) return callRegExpExec(splitter, S) === null ? [\n                            S\n                        ] : [];\n                        var p = 0;\n                        var q = 0;\n                        var A = [];\n                        while(q < S.length){\n                            splitter.lastIndex = SUPPORTS_Y ? q : 0;\n                            var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));\n                            var e;\n                            if (z === null || (e = $min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p) {\n                                q = advanceStringIndex(S, q, unicodeMatching);\n                            } else {\n                                A.push(S.slice(p, q));\n                                if (A.length === lim) return A;\n                                for(var i = 1; i <= z.length - 1; i++){\n                                    A.push(z[i]);\n                                    if (A.length === lim) return A;\n                                }\n                                q = p = e;\n                            }\n                        }\n                        A.push(S.slice(p));\n                        return A;\n                    }\n                ];\n            });\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/es6.string.includes.js\": /*!*************************************************************!*\\\n  !*** ./node_modules/core-js/modules/es6.string.includes.js ***!\n  \\*************************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_122437__) {\n            \"use strict\";\n            // 21.1.3.7 String.prototype.includes(searchString, position = 0)\n            var $export = __nested_webpack_require_122437__(/*! ./_export */ \"./node_modules/core-js/modules/_export.js\");\n            var context = __nested_webpack_require_122437__(/*! ./_string-context */ \"./node_modules/core-js/modules/_string-context.js\");\n            var INCLUDES = \"includes\";\n            $export($export.P + $export.F * __nested_webpack_require_122437__(/*! ./_fails-is-regexp */ \"./node_modules/core-js/modules/_fails-is-regexp.js\")(INCLUDES), \"String\", {\n                includes: function includes(searchString /* , position = 0 */ ) {\n                    return !!~context(this, searchString, INCLUDES).indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);\n                }\n            });\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/es6.symbol.js\": /*!****************************************************!*\\\n  !*** ./node_modules/core-js/modules/es6.symbol.js ***!\n  \\****************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_123577__) {\n            \"use strict\";\n            // ECMAScript 6 symbols shim\n            var global1 = __nested_webpack_require_123577__(/*! ./_global */ \"./node_modules/core-js/modules/_global.js\");\n            var has = __nested_webpack_require_123577__(/*! ./_has */ \"./node_modules/core-js/modules/_has.js\");\n            var DESCRIPTORS = __nested_webpack_require_123577__(/*! ./_descriptors */ \"./node_modules/core-js/modules/_descriptors.js\");\n            var $export = __nested_webpack_require_123577__(/*! ./_export */ \"./node_modules/core-js/modules/_export.js\");\n            var redefine = __nested_webpack_require_123577__(/*! ./_redefine */ \"./node_modules/core-js/modules/_redefine.js\");\n            var META = __nested_webpack_require_123577__(/*! ./_meta */ \"./node_modules/core-js/modules/_meta.js\").KEY;\n            var $fails = __nested_webpack_require_123577__(/*! ./_fails */ \"./node_modules/core-js/modules/_fails.js\");\n            var shared = __nested_webpack_require_123577__(/*! ./_shared */ \"./node_modules/core-js/modules/_shared.js\");\n            var setToStringTag = __nested_webpack_require_123577__(/*! ./_set-to-string-tag */ \"./node_modules/core-js/modules/_set-to-string-tag.js\");\n            var uid = __nested_webpack_require_123577__(/*! ./_uid */ \"./node_modules/core-js/modules/_uid.js\");\n            var wks = __nested_webpack_require_123577__(/*! ./_wks */ \"./node_modules/core-js/modules/_wks.js\");\n            var wksExt = __nested_webpack_require_123577__(/*! ./_wks-ext */ \"./node_modules/core-js/modules/_wks-ext.js\");\n            var wksDefine = __nested_webpack_require_123577__(/*! ./_wks-define */ \"./node_modules/core-js/modules/_wks-define.js\");\n            var enumKeys = __nested_webpack_require_123577__(/*! ./_enum-keys */ \"./node_modules/core-js/modules/_enum-keys.js\");\n            var isArray = __nested_webpack_require_123577__(/*! ./_is-array */ \"./node_modules/core-js/modules/_is-array.js\");\n            var anObject = __nested_webpack_require_123577__(/*! ./_an-object */ \"./node_modules/core-js/modules/_an-object.js\");\n            var isObject = __nested_webpack_require_123577__(/*! ./_is-object */ \"./node_modules/core-js/modules/_is-object.js\");\n            var toObject = __nested_webpack_require_123577__(/*! ./_to-object */ \"./node_modules/core-js/modules/_to-object.js\");\n            var toIObject = __nested_webpack_require_123577__(/*! ./_to-iobject */ \"./node_modules/core-js/modules/_to-iobject.js\");\n            var toPrimitive = __nested_webpack_require_123577__(/*! ./_to-primitive */ \"./node_modules/core-js/modules/_to-primitive.js\");\n            var createDesc = __nested_webpack_require_123577__(/*! ./_property-desc */ \"./node_modules/core-js/modules/_property-desc.js\");\n            var _create = __nested_webpack_require_123577__(/*! ./_object-create */ \"./node_modules/core-js/modules/_object-create.js\");\n            var gOPNExt = __nested_webpack_require_123577__(/*! ./_object-gopn-ext */ \"./node_modules/core-js/modules/_object-gopn-ext.js\");\n            var $GOPD = __nested_webpack_require_123577__(/*! ./_object-gopd */ \"./node_modules/core-js/modules/_object-gopd.js\");\n            var $GOPS = __nested_webpack_require_123577__(/*! ./_object-gops */ \"./node_modules/core-js/modules/_object-gops.js\");\n            var $DP = __nested_webpack_require_123577__(/*! ./_object-dp */ \"./node_modules/core-js/modules/_object-dp.js\");\n            var $keys = __nested_webpack_require_123577__(/*! ./_object-keys */ \"./node_modules/core-js/modules/_object-keys.js\");\n            var gOPD = $GOPD.f;\n            var dP = $DP.f;\n            var gOPN = gOPNExt.f;\n            var $Symbol = global1.Symbol;\n            var $JSON = global1.JSON;\n            var _stringify = $JSON && $JSON.stringify;\n            var PROTOTYPE = \"prototype\";\n            var HIDDEN = wks(\"_hidden\");\n            var TO_PRIMITIVE = wks(\"toPrimitive\");\n            var isEnum = {}.propertyIsEnumerable;\n            var SymbolRegistry = shared(\"symbol-registry\");\n            var AllSymbols = shared(\"symbols\");\n            var OPSymbols = shared(\"op-symbols\");\n            var ObjectProto = Object[PROTOTYPE];\n            var USE_NATIVE = typeof $Symbol == \"function\" && !!$GOPS.f;\n            var QObject = global1.QObject;\n            // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\n            var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;\n            // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\n            var setSymbolDesc = DESCRIPTORS && $fails(function() {\n                return _create(dP({}, \"a\", {\n                    get: function() {\n                        return dP(this, \"a\", {\n                            value: 7\n                        }).a;\n                    }\n                })).a != 7;\n            }) ? function(it, key, D) {\n                var protoDesc = gOPD(ObjectProto, key);\n                if (protoDesc) delete ObjectProto[key];\n                dP(it, key, D);\n                if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);\n            } : dP;\n            var wrap = function(tag) {\n                var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);\n                sym._k = tag;\n                return sym;\n            };\n            var isSymbol = USE_NATIVE && typeof $Symbol.iterator == \"symbol\" ? function(it) {\n                return typeof it == \"symbol\";\n            } : function(it) {\n                return it instanceof $Symbol;\n            };\n            var $defineProperty = function defineProperty(it, key, D) {\n                if (it === ObjectProto) $defineProperty(OPSymbols, key, D);\n                anObject(it);\n                key = toPrimitive(key, true);\n                anObject(D);\n                if (has(AllSymbols, key)) {\n                    if (!D.enumerable) {\n                        if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));\n                        it[HIDDEN][key] = true;\n                    } else {\n                        if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;\n                        D = _create(D, {\n                            enumerable: createDesc(0, false)\n                        });\n                    }\n                    return setSymbolDesc(it, key, D);\n                }\n                return dP(it, key, D);\n            };\n            var $defineProperties = function defineProperties(it, P) {\n                anObject(it);\n                var keys = enumKeys(P = toIObject(P));\n                var i = 0;\n                var l = keys.length;\n                var key;\n                while(l > i)$defineProperty(it, key = keys[i++], P[key]);\n                return it;\n            };\n            var $create = function create(it, P) {\n                return P === undefined ? _create(it) : $defineProperties(_create(it), P);\n            };\n            var $propertyIsEnumerable = function propertyIsEnumerable(key) {\n                var E = isEnum.call(this, key = toPrimitive(key, true));\n                if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;\n                return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;\n            };\n            var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {\n                it = toIObject(it);\n                key = toPrimitive(key, true);\n                if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;\n                var D = gOPD(it, key);\n                if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;\n                return D;\n            };\n            var $getOwnPropertyNames = function getOwnPropertyNames(it) {\n                var names = gOPN(toIObject(it));\n                var result = [];\n                var i = 0;\n                var key;\n                while(names.length > i){\n                    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);\n                }\n                return result;\n            };\n            var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {\n                var IS_OP = it === ObjectProto;\n                var names = gOPN(IS_OP ? OPSymbols : toIObject(it));\n                var result = [];\n                var i = 0;\n                var key;\n                while(names.length > i){\n                    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);\n                }\n                return result;\n            };\n            // 19.4.1.1 Symbol([description])\n            if (!USE_NATIVE) {\n                $Symbol = function Symbol1() {\n                    if (this instanceof $Symbol) throw TypeError(\"Symbol is not a constructor!\");\n                    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);\n                    var $set = function(value) {\n                        if (this === ObjectProto) $set.call(OPSymbols, value);\n                        if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;\n                        setSymbolDesc(this, tag, createDesc(1, value));\n                    };\n                    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, {\n                        configurable: true,\n                        set: $set\n                    });\n                    return wrap(tag);\n                };\n                redefine($Symbol[PROTOTYPE], \"toString\", function toString() {\n                    return this._k;\n                });\n                $GOPD.f = $getOwnPropertyDescriptor;\n                $DP.f = $defineProperty;\n                __nested_webpack_require_123577__(/*! ./_object-gopn */ \"./node_modules/core-js/modules/_object-gopn.js\").f = gOPNExt.f = $getOwnPropertyNames;\n                __nested_webpack_require_123577__(/*! ./_object-pie */ \"./node_modules/core-js/modules/_object-pie.js\").f = $propertyIsEnumerable;\n                $GOPS.f = $getOwnPropertySymbols;\n                if (DESCRIPTORS && !__nested_webpack_require_123577__(/*! ./_library */ \"./node_modules/core-js/modules/_library.js\")) {\n                    redefine(ObjectProto, \"propertyIsEnumerable\", $propertyIsEnumerable, true);\n                }\n                wksExt.f = function(name) {\n                    return wrap(wks(name));\n                };\n            }\n            $export($export.G + $export.W + $export.F * !USE_NATIVE, {\n                Symbol: $Symbol\n            });\n            for(var es6Symbols = // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14\n            \"hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables\".split(\",\"), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);\n            for(var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;)wksDefine(wellKnownSymbols[k++]);\n            $export($export.S + $export.F * !USE_NATIVE, \"Symbol\", {\n                // 19.4.2.1 Symbol.for(key)\n                \"for\": function(key) {\n                    return has(SymbolRegistry, key += \"\") ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);\n                },\n                // 19.4.2.5 Symbol.keyFor(sym)\n                keyFor: function keyFor(sym) {\n                    if (!isSymbol(sym)) throw TypeError(sym + \" is not a symbol!\");\n                    for(var key in SymbolRegistry)if (SymbolRegistry[key] === sym) return key;\n                },\n                useSetter: function() {\n                    setter = true;\n                },\n                useSimple: function() {\n                    setter = false;\n                }\n            });\n            $export($export.S + $export.F * !USE_NATIVE, \"Object\", {\n                // 19.1.2.2 Object.create(O [, Properties])\n                create: $create,\n                // 19.1.2.4 Object.defineProperty(O, P, Attributes)\n                defineProperty: $defineProperty,\n                // 19.1.2.3 Object.defineProperties(O, Properties)\n                defineProperties: $defineProperties,\n                // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\n                getOwnPropertyDescriptor: $getOwnPropertyDescriptor,\n                // 19.1.2.7 Object.getOwnPropertyNames(O)\n                getOwnPropertyNames: $getOwnPropertyNames,\n                // 19.1.2.8 Object.getOwnPropertySymbols(O)\n                getOwnPropertySymbols: $getOwnPropertySymbols\n            });\n            // Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives\n            // https://bugs.chromium.org/p/v8/issues/detail?id=3443\n            var FAILS_ON_PRIMITIVES = $fails(function() {\n                $GOPS.f(1);\n            });\n            $export($export.S + $export.F * FAILS_ON_PRIMITIVES, \"Object\", {\n                getOwnPropertySymbols: function getOwnPropertySymbols(it) {\n                    return $GOPS.f(toObject(it));\n                }\n            });\n            // 24.3.2 JSON.stringify(value [, replacer [, space]])\n            $JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function() {\n                var S = $Symbol();\n                // MS Edge converts symbol values to JSON as {}\n                // WebKit converts symbol values to JSON as null\n                // V8 throws on boxed symbols\n                return _stringify([\n                    S\n                ]) != \"[null]\" || _stringify({\n                    a: S\n                }) != \"{}\" || _stringify(Object(S)) != \"{}\";\n            })), \"JSON\", {\n                stringify: function stringify(it) {\n                    var args = [\n                        it\n                    ];\n                    var i = 1;\n                    var replacer, $replacer;\n                    while(arguments.length > i)args.push(arguments[i++]);\n                    $replacer = replacer = args[1];\n                    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined\n                    if (!isArray(replacer)) replacer = function(key, value) {\n                        if (typeof $replacer == \"function\") value = $replacer.call(this, key, value);\n                        if (!isSymbol(value)) return value;\n                    };\n                    args[1] = replacer;\n                    return _stringify.apply($JSON, args);\n                }\n            });\n            // 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)\n            $Symbol[PROTOTYPE][TO_PRIMITIVE] || __nested_webpack_require_123577__(/*! ./_hide */ \"./node_modules/core-js/modules/_hide.js\")($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);\n            // 19.4.3.5 Symbol.prototype[@@toStringTag]\n            setToStringTag($Symbol, \"Symbol\");\n            // 20.2.1.9 Math[@@toStringTag]\n            setToStringTag(Math, \"Math\", true);\n            // 24.3.3 JSON[@@toStringTag]\n            setToStringTag(global1.JSON, \"JSON\", true);\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/es7.array.includes.js\": /*!************************************************************!*\\\n  !*** ./node_modules/core-js/modules/es7.array.includes.js ***!\n  \\************************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_138730__) {\n            \"use strict\";\n            // https://github.com/tc39/Array.prototype.includes\n            var $export = __nested_webpack_require_138730__(/*! ./_export */ \"./node_modules/core-js/modules/_export.js\");\n            var $includes = __nested_webpack_require_138730__(/*! ./_array-includes */ \"./node_modules/core-js/modules/_array-includes.js\")(true);\n            $export($export.P, \"Array\", {\n                includes: function includes(el /* , fromIndex = 0 */ ) {\n                    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);\n                }\n            });\n            __nested_webpack_require_138730__(/*! ./_add-to-unscopables */ \"./node_modules/core-js/modules/_add-to-unscopables.js\")(\"includes\");\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/es7.object.get-own-property-descriptors.js\": /*!*********************************************************************************!*\\\n  !*** ./node_modules/core-js/modules/es7.object.get-own-property-descriptors.js ***!\n  \\*********************************************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_139895__) {\n            // https://github.com/tc39/proposal-object-getownpropertydescriptors\n            var $export = __nested_webpack_require_139895__(/*! ./_export */ \"./node_modules/core-js/modules/_export.js\");\n            var ownKeys = __nested_webpack_require_139895__(/*! ./_own-keys */ \"./node_modules/core-js/modules/_own-keys.js\");\n            var toIObject = __nested_webpack_require_139895__(/*! ./_to-iobject */ \"./node_modules/core-js/modules/_to-iobject.js\");\n            var gOPD = __nested_webpack_require_139895__(/*! ./_object-gopd */ \"./node_modules/core-js/modules/_object-gopd.js\");\n            var createProperty = __nested_webpack_require_139895__(/*! ./_create-property */ \"./node_modules/core-js/modules/_create-property.js\");\n            $export($export.S, \"Object\", {\n                getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {\n                    var O = toIObject(object);\n                    var getDesc = gOPD.f;\n                    var keys = ownKeys(O);\n                    var result = {};\n                    var i = 0;\n                    var key, desc;\n                    while(keys.length > i){\n                        desc = getDesc(O, key = keys[i++]);\n                        if (desc !== undefined) createProperty(result, key, desc);\n                    }\n                    return result;\n                }\n            });\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/es7.symbol.async-iterator.js\": /*!*******************************************************************!*\\\n  !*** ./node_modules/core-js/modules/es7.symbol.async-iterator.js ***!\n  \\*******************************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_141611__) {\n            __nested_webpack_require_141611__(/*! ./_wks-define */ \"./node_modules/core-js/modules/_wks-define.js\")(\"asyncIterator\");\n        /***/ },\n        /***/ \"./node_modules/core-js/modules/web.dom.iterable.js\": /*!**********************************************************!*\\\n  !*** ./node_modules/core-js/modules/web.dom.iterable.js ***!\n  \\**********************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_142095__) {\n            var $iterators = __nested_webpack_require_142095__(/*! ./es6.array.iterator */ \"./node_modules/core-js/modules/es6.array.iterator.js\");\n            var getKeys = __nested_webpack_require_142095__(/*! ./_object-keys */ \"./node_modules/core-js/modules/_object-keys.js\");\n            var redefine = __nested_webpack_require_142095__(/*! ./_redefine */ \"./node_modules/core-js/modules/_redefine.js\");\n            var global1 = __nested_webpack_require_142095__(/*! ./_global */ \"./node_modules/core-js/modules/_global.js\");\n            var hide = __nested_webpack_require_142095__(/*! ./_hide */ \"./node_modules/core-js/modules/_hide.js\");\n            var Iterators = __nested_webpack_require_142095__(/*! ./_iterators */ \"./node_modules/core-js/modules/_iterators.js\");\n            var wks = __nested_webpack_require_142095__(/*! ./_wks */ \"./node_modules/core-js/modules/_wks.js\");\n            var ITERATOR = wks(\"iterator\");\n            var TO_STRING_TAG = wks(\"toStringTag\");\n            var ArrayValues = Iterators.Array;\n            var DOMIterables = {\n                CSSRuleList: true,\n                CSSStyleDeclaration: false,\n                CSSValueList: false,\n                ClientRectList: false,\n                DOMRectList: false,\n                DOMStringList: false,\n                DOMTokenList: true,\n                DataTransferItemList: false,\n                FileList: false,\n                HTMLAllCollection: false,\n                HTMLCollection: false,\n                HTMLFormElement: false,\n                HTMLSelectElement: false,\n                MediaList: true,\n                MimeTypeArray: false,\n                NamedNodeMap: false,\n                NodeList: true,\n                PaintRequestList: false,\n                Plugin: false,\n                PluginArray: false,\n                SVGLengthList: false,\n                SVGNumberList: false,\n                SVGPathSegList: false,\n                SVGPointList: false,\n                SVGStringList: false,\n                SVGTransformList: false,\n                SourceBufferList: false,\n                StyleSheetList: true,\n                TextTrackCueList: false,\n                TextTrackList: false,\n                TouchList: false\n            };\n            for(var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++){\n                var NAME = collections[i];\n                var explicit = DOMIterables[NAME];\n                var Collection = global1[NAME];\n                var proto = Collection && Collection.prototype;\n                var key;\n                if (proto) {\n                    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);\n                    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);\n                    Iterators[NAME] = ArrayValues;\n                    if (explicit) {\n                        for(key in $iterators)if (!proto[key]) redefine(proto, key, $iterators[key], true);\n                    }\n                }\n            }\n        /***/ },\n        /***/ \"./node_modules/crypt/crypt.js\": /*!*************************************!*\\\n  !*** ./node_modules/crypt/crypt.js ***!\n  \\*************************************/ /*! no static exports found */ /***/ function(module1, exports1) {\n            (function() {\n                var base64map = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\", crypt = {\n                    // Bit-wise rotation left\n                    rotl: function(n, b) {\n                        return n << b | n >>> 32 - b;\n                    },\n                    // Bit-wise rotation right\n                    rotr: function(n, b) {\n                        return n << 32 - b | n >>> b;\n                    },\n                    // Swap big-endian to little-endian and vice versa\n                    endian: function(n) {\n                        // If number given, swap endian\n                        if (n.constructor == Number) {\n                            return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;\n                        }\n                        // Else, assume array and swap all items\n                        for(var i = 0; i < n.length; i++)n[i] = crypt.endian(n[i]);\n                        return n;\n                    },\n                    // Generate an array of any length of random bytes\n                    randomBytes: function(n) {\n                        for(var bytes = []; n > 0; n--)bytes.push(Math.floor(Math.random() * 256));\n                        return bytes;\n                    },\n                    // Convert a byte array to big-endian 32-bit words\n                    bytesToWords: function(bytes) {\n                        for(var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)words[b >>> 5] |= bytes[i] << 24 - b % 32;\n                        return words;\n                    },\n                    // Convert big-endian 32-bit words to a byte array\n                    wordsToBytes: function(words) {\n                        for(var bytes = [], b = 0; b < words.length * 32; b += 8)bytes.push(words[b >>> 5] >>> 24 - b % 32 & 0xFF);\n                        return bytes;\n                    },\n                    // Convert a byte array to a hex string\n                    bytesToHex: function(bytes) {\n                        for(var hex = [], i = 0; i < bytes.length; i++){\n                            hex.push((bytes[i] >>> 4).toString(16));\n                            hex.push((bytes[i] & 0xF).toString(16));\n                        }\n                        return hex.join(\"\");\n                    },\n                    // Convert a hex string to a byte array\n                    hexToBytes: function(hex) {\n                        for(var bytes = [], c = 0; c < hex.length; c += 2)bytes.push(parseInt(hex.substr(c, 2), 16));\n                        return bytes;\n                    },\n                    // Convert a byte array to a base-64 string\n                    bytesToBase64: function(bytes) {\n                        for(var base64 = [], i = 0; i < bytes.length; i += 3){\n                            var triplet = bytes[i] << 16 | bytes[i + 1] << 8 | bytes[i + 2];\n                            for(var j = 0; j < 4; j++)if (i * 8 + j * 6 <= bytes.length * 8) base64.push(base64map.charAt(triplet >>> 6 * (3 - j) & 0x3F));\n                            else base64.push(\"=\");\n                        }\n                        return base64.join(\"\");\n                    },\n                    // Convert a base-64 string to a byte array\n                    base64ToBytes: function(base64) {\n                        // Remove non-base-64 characters\n                        base64 = base64.replace(/[^A-Z0-9+\\/]/ig, \"\");\n                        for(var bytes = [], i = 0, imod4 = 0; i < base64.length; imod4 = ++i % 4){\n                            if (imod4 == 0) continue;\n                            bytes.push((base64map.indexOf(base64.charAt(i - 1)) & Math.pow(2, -2 * imod4 + 8) - 1) << imod4 * 2 | base64map.indexOf(base64.charAt(i)) >>> 6 - imod4 * 2);\n                        }\n                        return bytes;\n                    }\n                };\n                module1.exports = crypt;\n            })();\n        /***/ },\n        /***/ \"./node_modules/is-buffer/index.js\": /*!*****************************************!*\\\n  !*** ./node_modules/is-buffer/index.js ***!\n  \\*****************************************/ /*! no static exports found */ /***/ function(module1, exports1) {\n            /*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */ // The _isBuffer check is for Safari 5-7 support, because it's missing\n            // Object.prototype.constructor. Remove this eventually\n            module1.exports = function(obj) {\n                return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);\n            };\n            function isBuffer(obj) {\n                return !!obj.constructor && typeof obj.constructor.isBuffer === \"function\" && obj.constructor.isBuffer(obj);\n            }\n            // For Node v0.10 support. Remove this eventually.\n            function isSlowBuffer(obj) {\n                return typeof obj.readFloatLE === \"function\" && typeof obj.slice === \"function\" && isBuffer(obj.slice(0, 0));\n            }\n        /***/ },\n        /***/ \"./node_modules/md5/md5.js\": /*!*********************************!*\\\n  !*** ./node_modules/md5/md5.js ***!\n  \\*********************************/ /*! no static exports found */ /***/ function(module1, exports1, __nested_webpack_require_150641__) {\n            (function() {\n                var crypt = __nested_webpack_require_150641__(/*! crypt */ \"./node_modules/crypt/crypt.js\"), utf8 = __nested_webpack_require_150641__(/*! charenc */ \"./node_modules/charenc/charenc.js\").utf8, isBuffer = __nested_webpack_require_150641__(/*! is-buffer */ \"./node_modules/is-buffer/index.js\"), bin = __nested_webpack_require_150641__(/*! charenc */ \"./node_modules/charenc/charenc.js\").bin, // The core\n                md5 = function(message, options) {\n                    // Convert to byte array\n                    if (message.constructor == String) if (options && options.encoding === \"binary\") message = bin.stringToBytes(message);\n                    else message = utf8.stringToBytes(message);\n                    else if (isBuffer(message)) message = Array.prototype.slice.call(message, 0);\n                    else if (!Array.isArray(message) && message.constructor !== Uint8Array) message = message.toString();\n                    // else, assume byte array already\n                    var m = crypt.bytesToWords(message), l = message.length * 8, a = 1732584193, b = -271733879, c = -1732584194, d = 271733878;\n                    // Swap endian\n                    for(var i = 0; i < m.length; i++){\n                        m[i] = (m[i] << 8 | m[i] >>> 24) & 0x00FF00FF | (m[i] << 24 | m[i] >>> 8) & 0xFF00FF00;\n                    }\n                    // Padding\n                    m[l >>> 5] |= 0x80 << l % 32;\n                    m[(l + 64 >>> 9 << 4) + 14] = l;\n                    // Method shortcuts\n                    var FF = md5._ff, GG = md5._gg, HH = md5._hh, II = md5._ii;\n                    for(var i = 0; i < m.length; i += 16){\n                        var aa = a, bb = b, cc = c, dd = d;\n                        a = FF(a, b, c, d, m[i + 0], 7, -680876936);\n                        d = FF(d, a, b, c, m[i + 1], 12, -389564586);\n                        c = FF(c, d, a, b, m[i + 2], 17, 606105819);\n                        b = FF(b, c, d, a, m[i + 3], 22, -1044525330);\n                        a = FF(a, b, c, d, m[i + 4], 7, -176418897);\n                        d = FF(d, a, b, c, m[i + 5], 12, 1200080426);\n                        c = FF(c, d, a, b, m[i + 6], 17, -1473231341);\n                        b = FF(b, c, d, a, m[i + 7], 22, -45705983);\n                        a = FF(a, b, c, d, m[i + 8], 7, 1770035416);\n                        d = FF(d, a, b, c, m[i + 9], 12, -1958414417);\n                        c = FF(c, d, a, b, m[i + 10], 17, -42063);\n                        b = FF(b, c, d, a, m[i + 11], 22, -1990404162);\n                        a = FF(a, b, c, d, m[i + 12], 7, 1804603682);\n                        d = FF(d, a, b, c, m[i + 13], 12, -40341101);\n                        c = FF(c, d, a, b, m[i + 14], 17, -1502002290);\n                        b = FF(b, c, d, a, m[i + 15], 22, 1236535329);\n                        a = GG(a, b, c, d, m[i + 1], 5, -165796510);\n                        d = GG(d, a, b, c, m[i + 6], 9, -1069501632);\n                        c = GG(c, d, a, b, m[i + 11], 14, 643717713);\n                        b = GG(b, c, d, a, m[i + 0], 20, -373897302);\n                        a = GG(a, b, c, d, m[i + 5], 5, -701558691);\n                        d = GG(d, a, b, c, m[i + 10], 9, 38016083);\n                        c = GG(c, d, a, b, m[i + 15], 14, -660478335);\n                        b = GG(b, c, d, a, m[i + 4], 20, -405537848);\n                        a = GG(a, b, c, d, m[i + 9], 5, 568446438);\n                        d = GG(d, a, b, c, m[i + 14], 9, -1019803690);\n                        c = GG(c, d, a, b, m[i + 3], 14, -187363961);\n                        b = GG(b, c, d, a, m[i + 8], 20, 1163531501);\n                        a = GG(a, b, c, d, m[i + 13], 5, -1444681467);\n                        d = GG(d, a, b, c, m[i + 2], 9, -51403784);\n                        c = GG(c, d, a, b, m[i + 7], 14, 1735328473);\n                        b = GG(b, c, d, a, m[i + 12], 20, -1926607734);\n                        a = HH(a, b, c, d, m[i + 5], 4, -378558);\n                        d = HH(d, a, b, c, m[i + 8], 11, -2022574463);\n                        c = HH(c, d, a, b, m[i + 11], 16, 1839030562);\n                        b = HH(b, c, d, a, m[i + 14], 23, -35309556);\n                        a = HH(a, b, c, d, m[i + 1], 4, -1530992060);\n                        d = HH(d, a, b, c, m[i + 4], 11, 1272893353);\n                        c = HH(c, d, a, b, m[i + 7], 16, -155497632);\n                        b = HH(b, c, d, a, m[i + 10], 23, -1094730640);\n                        a = HH(a, b, c, d, m[i + 13], 4, 681279174);\n                        d = HH(d, a, b, c, m[i + 0], 11, -358537222);\n                        c = HH(c, d, a, b, m[i + 3], 16, -722521979);\n                        b = HH(b, c, d, a, m[i + 6], 23, 76029189);\n                        a = HH(a, b, c, d, m[i + 9], 4, -640364487);\n                        d = HH(d, a, b, c, m[i + 12], 11, -421815835);\n                        c = HH(c, d, a, b, m[i + 15], 16, 530742520);\n                        b = HH(b, c, d, a, m[i + 2], 23, -995338651);\n                        a = II(a, b, c, d, m[i + 0], 6, -198630844);\n                        d = II(d, a, b, c, m[i + 7], 10, 1126891415);\n                        c = II(c, d, a, b, m[i + 14], 15, -1416354905);\n                        b = II(b, c, d, a, m[i + 5], 21, -57434055);\n                        a = II(a, b, c, d, m[i + 12], 6, 1700485571);\n                        d = II(d, a, b, c, m[i + 3], 10, -1894986606);\n                        c = II(c, d, a, b, m[i + 10], 15, -1051523);\n                        b = II(b, c, d, a, m[i + 1], 21, -2054922799);\n                        a = II(a, b, c, d, m[i + 8], 6, 1873313359);\n                        d = II(d, a, b, c, m[i + 15], 10, -30611744);\n                        c = II(c, d, a, b, m[i + 6], 15, -1560198380);\n                        b = II(b, c, d, a, m[i + 13], 21, 1309151649);\n                        a = II(a, b, c, d, m[i + 4], 6, -145523070);\n                        d = II(d, a, b, c, m[i + 11], 10, -1120210379);\n                        c = II(c, d, a, b, m[i + 2], 15, 718787259);\n                        b = II(b, c, d, a, m[i + 9], 21, -343485551);\n                        a = a + aa >>> 0;\n                        b = b + bb >>> 0;\n                        c = c + cc >>> 0;\n                        d = d + dd >>> 0;\n                    }\n                    return crypt.endian([\n                        a,\n                        b,\n                        c,\n                        d\n                    ]);\n                };\n                // Auxiliary functions\n                md5._ff = function(a, b, c, d, x, s, t) {\n                    var n = a + (b & c | ~b & d) + (x >>> 0) + t;\n                    return (n << s | n >>> 32 - s) + b;\n                };\n                md5._gg = function(a, b, c, d, x, s, t) {\n                    var n = a + (b & d | c & ~d) + (x >>> 0) + t;\n                    return (n << s | n >>> 32 - s) + b;\n                };\n                md5._hh = function(a, b, c, d, x, s, t) {\n                    var n = a + (b ^ c ^ d) + (x >>> 0) + t;\n                    return (n << s | n >>> 32 - s) + b;\n                };\n                md5._ii = function(a, b, c, d, x, s, t) {\n                    var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;\n                    return (n << s | n >>> 32 - s) + b;\n                };\n                // Package private blocksize\n                md5._blocksize = 16;\n                md5._digestsize = 16;\n                module1.exports = function(message, options) {\n                    if (message === undefined || message === null) throw new Error(\"Illegal argument \" + message);\n                    var digestbytes = crypt.wordsToBytes(md5(message, options));\n                    return options && options.asBytes ? digestbytes : options && options.asString ? bin.bytesToString(digestbytes) : crypt.bytesToHex(digestbytes);\n                };\n            })();\n        /***/ },\n        /***/ \"./node_modules/regenerator-runtime/runtime.js\": /*!*****************************************************!*\\\n  !*** ./node_modules/regenerator-runtime/runtime.js ***!\n  \\*****************************************************/ /*! no static exports found */ /***/ function(module1, exports1, __webpack_require__) {\n            /**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ var runtime = function(exports1) {\n                \"use strict\";\n                var Op = Object.prototype;\n                var hasOwn = Op.hasOwnProperty;\n                var undefined1; // More compressible than void 0.\n                var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n                var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n                var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n                var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n                function define1(obj, key, value) {\n                    Object.defineProperty(obj, key, {\n                        value: value,\n                        enumerable: true,\n                        configurable: true,\n                        writable: true\n                    });\n                    return obj[key];\n                }\n                try {\n                    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n                    define1({}, \"\");\n                } catch (err) {\n                    define1 = function(obj, key, value) {\n                        return obj[key] = value;\n                    };\n                }\n                function wrap(innerFn, outerFn, self1, tryLocsList) {\n                    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n                    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n                    var generator = Object.create(protoGenerator.prototype);\n                    var context = new Context(tryLocsList || []);\n                    // The ._invoke method unifies the implementations of the .next,\n                    // .throw, and .return methods.\n                    generator._invoke = makeInvokeMethod(innerFn, self1, context);\n                    return generator;\n                }\n                exports1.wrap = wrap;\n                // Try/catch helper to minimize deoptimizations. Returns a completion\n                // record like context.tryEntries[i].completion. This interface could\n                // have been (and was previously) designed to take a closure to be\n                // invoked without arguments, but in all the cases we care about we\n                // already have an existing method we want to call, so there's no need\n                // to create a new function object. We can even get away with assuming\n                // the method takes exactly one argument, since that happens to be true\n                // in every case, so we don't have to touch the arguments object. The\n                // only additional allocation required is the completion record, which\n                // has a stable shape and so hopefully should be cheap to allocate.\n                function tryCatch(fn, obj, arg) {\n                    try {\n                        return {\n                            type: \"normal\",\n                            arg: fn.call(obj, arg)\n                        };\n                    } catch (err) {\n                        return {\n                            type: \"throw\",\n                            arg: err\n                        };\n                    }\n                }\n                var GenStateSuspendedStart = \"suspendedStart\";\n                var GenStateSuspendedYield = \"suspendedYield\";\n                var GenStateExecuting = \"executing\";\n                var GenStateCompleted = \"completed\";\n                // Returning this object from the innerFn has the same effect as\n                // breaking out of the dispatch switch statement.\n                var ContinueSentinel = {};\n                // Dummy constructor functions that we use as the .constructor and\n                // .constructor.prototype properties for functions that return Generator\n                // objects. For full spec compliance, you may wish to configure your\n                // minifier not to mangle the names of these two functions.\n                function Generator() {}\n                function GeneratorFunction() {}\n                function GeneratorFunctionPrototype() {}\n                // This is a polyfill for %IteratorPrototype% for environments that\n                // don't natively support it.\n                var IteratorPrototype = {};\n                IteratorPrototype[iteratorSymbol] = function() {\n                    return this;\n                };\n                var getProto = Object.getPrototypeOf;\n                var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n                if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n                    // This environment has a native %IteratorPrototype%; use it instead\n                    // of the polyfill.\n                    IteratorPrototype = NativeIteratorPrototype;\n                }\n                var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n                GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n                GeneratorFunctionPrototype.constructor = GeneratorFunction;\n                GeneratorFunction.displayName = define1(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\");\n                // Helper for defining the .next, .throw, and .return methods of the\n                // Iterator interface in terms of a single ._invoke method.\n                function defineIteratorMethods(prototype) {\n                    [\n                        \"next\",\n                        \"throw\",\n                        \"return\"\n                    ].forEach(function(method) {\n                        define1(prototype, method, function(arg) {\n                            return this._invoke(method, arg);\n                        });\n                    });\n                }\n                exports1.isGeneratorFunction = function(genFun) {\n                    var ctor = typeof genFun === \"function\" && genFun.constructor;\n                    return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can\n                    // do is to check its .name property.\n                    (ctor.displayName || ctor.name) === \"GeneratorFunction\" : false;\n                };\n                exports1.mark = function(genFun) {\n                    if (Object.setPrototypeOf) {\n                        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n                    } else {\n                        genFun.__proto__ = GeneratorFunctionPrototype;\n                        define1(genFun, toStringTagSymbol, \"GeneratorFunction\");\n                    }\n                    genFun.prototype = Object.create(Gp);\n                    return genFun;\n                };\n                // Within the body of any async function, `await x` is transformed to\n                // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n                // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n                // meant to be awaited.\n                exports1.awrap = function(arg) {\n                    return {\n                        __await: arg\n                    };\n                };\n                function AsyncIterator(generator, PromiseImpl) {\n                    function invoke(method, arg, resolve, reject) {\n                        var record = tryCatch(generator[method], generator, arg);\n                        if (record.type === \"throw\") {\n                            reject(record.arg);\n                        } else {\n                            var result = record.arg;\n                            var value = result.value;\n                            if (value && typeof value === \"object\" && hasOwn.call(value, \"__await\")) {\n                                return PromiseImpl.resolve(value.__await).then(function(value) {\n                                    invoke(\"next\", value, resolve, reject);\n                                }, function(err) {\n                                    invoke(\"throw\", err, resolve, reject);\n                                });\n                            }\n                            return PromiseImpl.resolve(value).then(function(unwrapped) {\n                                // When a yielded Promise is resolved, its final value becomes\n                                // the .value of the Promise<{value,done}> result for the\n                                // current iteration.\n                                result.value = unwrapped;\n                                resolve(result);\n                            }, function(error) {\n                                // If a rejected Promise was yielded, throw the rejection back\n                                // into the async generator function so it can be handled there.\n                                return invoke(\"throw\", error, resolve, reject);\n                            });\n                        }\n                    }\n                    var previousPromise;\n                    function enqueue(method, arg) {\n                        function callInvokeWithMethodAndArg() {\n                            return new PromiseImpl(function(resolve, reject) {\n                                invoke(method, arg, resolve, reject);\n                            });\n                        }\n                        return previousPromise = // If enqueue has been called before, then we want to wait until\n                        // all previous Promises have been resolved before calling invoke,\n                        // so that results are always delivered in the correct order. If\n                        // enqueue has not been called before, then it is important to\n                        // call invoke immediately, without waiting on a callback to fire,\n                        // so that the async generator function has the opportunity to do\n                        // any necessary setup in a predictable way. This predictability\n                        // is why the Promise constructor synchronously invokes its\n                        // executor callback, and why async functions synchronously\n                        // execute code before the first await. Since we implement simple\n                        // async functions in terms of async generators, it is especially\n                        // important to get this right, even though it requires care.\n                        previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later\n                        // invocations of the iterator.\n                        callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n                    }\n                    // Define the unified helper method that is used to implement .next,\n                    // .throw, and .return (see defineIteratorMethods).\n                    this._invoke = enqueue;\n                }\n                defineIteratorMethods(AsyncIterator.prototype);\n                AsyncIterator.prototype[asyncIteratorSymbol] = function() {\n                    return this;\n                };\n                exports1.AsyncIterator = AsyncIterator;\n                // Note that simple async functions are implemented on top of\n                // AsyncIterator objects; they just return a Promise for the value of\n                // the final result produced by the iterator.\n                exports1.async = function(innerFn, outerFn, self1, tryLocsList, PromiseImpl) {\n                    if (PromiseImpl === void 0) PromiseImpl = Promise;\n                    var iter = new AsyncIterator(wrap(innerFn, outerFn, self1, tryLocsList), PromiseImpl);\n                    return exports1.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.\n                     : iter.next().then(function(result) {\n                        return result.done ? result.value : iter.next();\n                    });\n                };\n                function makeInvokeMethod(innerFn, self1, context) {\n                    var state = GenStateSuspendedStart;\n                    return function invoke(method, arg) {\n                        if (state === GenStateExecuting) {\n                            throw new Error(\"Generator is already running\");\n                        }\n                        if (state === GenStateCompleted) {\n                            if (method === \"throw\") {\n                                throw arg;\n                            }\n                            // Be forgiving, per 25.3.3.3.3 of the spec:\n                            // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n                            return doneResult();\n                        }\n                        context.method = method;\n                        context.arg = arg;\n                        while(true){\n                            var delegate = context.delegate;\n                            if (delegate) {\n                                var delegateResult = maybeInvokeDelegate(delegate, context);\n                                if (delegateResult) {\n                                    if (delegateResult === ContinueSentinel) continue;\n                                    return delegateResult;\n                                }\n                            }\n                            if (context.method === \"next\") {\n                                // Setting context._sent for legacy support of Babel's\n                                // function.sent implementation.\n                                context.sent = context._sent = context.arg;\n                            } else if (context.method === \"throw\") {\n                                if (state === GenStateSuspendedStart) {\n                                    state = GenStateCompleted;\n                                    throw context.arg;\n                                }\n                                context.dispatchException(context.arg);\n                            } else if (context.method === \"return\") {\n                                context.abrupt(\"return\", context.arg);\n                            }\n                            state = GenStateExecuting;\n                            var record = tryCatch(innerFn, self1, context);\n                            if (record.type === \"normal\") {\n                                // If an exception is thrown from innerFn, we leave state ===\n                                // GenStateExecuting and loop back for another invocation.\n                                state = context.done ? GenStateCompleted : GenStateSuspendedYield;\n                                if (record.arg === ContinueSentinel) {\n                                    continue;\n                                }\n                                return {\n                                    value: record.arg,\n                                    done: context.done\n                                };\n                            } else if (record.type === \"throw\") {\n                                state = GenStateCompleted;\n                                // Dispatch the exception by looping back around to the\n                                // context.dispatchException(context.arg) call above.\n                                context.method = \"throw\";\n                                context.arg = record.arg;\n                            }\n                        }\n                    };\n                }\n                // Call delegate.iterator[context.method](context.arg) and handle the\n                // result, either by returning a { value, done } result from the\n                // delegate iterator, or by modifying context.method and context.arg,\n                // setting context.delegate to null, and returning the ContinueSentinel.\n                function maybeInvokeDelegate(delegate, context) {\n                    var method = delegate.iterator[context.method];\n                    if (method === undefined1) {\n                        // A .throw or .return when the delegate iterator has no .throw\n                        // method always terminates the yield* loop.\n                        context.delegate = null;\n                        if (context.method === \"throw\") {\n                            // Note: [\"return\"] must be used for ES3 parsing compatibility.\n                            if (delegate.iterator[\"return\"]) {\n                                // If the delegate iterator has a return method, give it a\n                                // chance to clean up.\n                                context.method = \"return\";\n                                context.arg = undefined1;\n                                maybeInvokeDelegate(delegate, context);\n                                if (context.method === \"throw\") {\n                                    // If maybeInvokeDelegate(context) changed context.method from\n                                    // \"return\" to \"throw\", let that override the TypeError below.\n                                    return ContinueSentinel;\n                                }\n                            }\n                            context.method = \"throw\";\n                            context.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n                        }\n                        return ContinueSentinel;\n                    }\n                    var record = tryCatch(method, delegate.iterator, context.arg);\n                    if (record.type === \"throw\") {\n                        context.method = \"throw\";\n                        context.arg = record.arg;\n                        context.delegate = null;\n                        return ContinueSentinel;\n                    }\n                    var info = record.arg;\n                    if (!info) {\n                        context.method = \"throw\";\n                        context.arg = new TypeError(\"iterator result is not an object\");\n                        context.delegate = null;\n                        return ContinueSentinel;\n                    }\n                    if (info.done) {\n                        // Assign the result of the finished delegate to the temporary\n                        // variable specified by delegate.resultName (see delegateYield).\n                        context[delegate.resultName] = info.value;\n                        // Resume execution at the desired location (see delegateYield).\n                        context.next = delegate.nextLoc;\n                        // If context.method was \"throw\" but the delegate handled the\n                        // exception, let the outer generator proceed normally. If\n                        // context.method was \"next\", forget context.arg since it has been\n                        // \"consumed\" by the delegate iterator. If context.method was\n                        // \"return\", allow the original .return call to continue in the\n                        // outer generator.\n                        if (context.method !== \"return\") {\n                            context.method = \"next\";\n                            context.arg = undefined1;\n                        }\n                    } else {\n                        // Re-yield the result returned by the delegate method.\n                        return info;\n                    }\n                    // The delegate iterator is finished, so forget it and continue with\n                    // the outer generator.\n                    context.delegate = null;\n                    return ContinueSentinel;\n                }\n                // Define Generator.prototype.{next,throw,return} in terms of the\n                // unified ._invoke helper method.\n                defineIteratorMethods(Gp);\n                define1(Gp, toStringTagSymbol, \"Generator\");\n                // A Generator should always return itself as the iterator object when the\n                // @@iterator function is called on it. Some browsers' implementations of the\n                // iterator prototype chain incorrectly implement this, causing the Generator\n                // object to not be returned from this call. This ensures that doesn't happen.\n                // See https://github.com/facebook/regenerator/issues/274 for more details.\n                Gp[iteratorSymbol] = function() {\n                    return this;\n                };\n                Gp.toString = function() {\n                    return \"[object Generator]\";\n                };\n                function pushTryEntry(locs) {\n                    var entry = {\n                        tryLoc: locs[0]\n                    };\n                    if (1 in locs) {\n                        entry.catchLoc = locs[1];\n                    }\n                    if (2 in locs) {\n                        entry.finallyLoc = locs[2];\n                        entry.afterLoc = locs[3];\n                    }\n                    this.tryEntries.push(entry);\n                }\n                function resetTryEntry(entry) {\n                    var record = entry.completion || {};\n                    record.type = \"normal\";\n                    delete record.arg;\n                    entry.completion = record;\n                }\n                function Context(tryLocsList) {\n                    // The root entry object (effectively a try statement without a catch\n                    // or a finally block) gives us a place to store values thrown from\n                    // locations where there is no enclosing try statement.\n                    this.tryEntries = [\n                        {\n                            tryLoc: \"root\"\n                        }\n                    ];\n                    tryLocsList.forEach(pushTryEntry, this);\n                    this.reset(true);\n                }\n                exports1.keys = function(object) {\n                    var keys = [];\n                    for(var key in object){\n                        keys.push(key);\n                    }\n                    keys.reverse();\n                    // Rather than returning an object with a next method, we keep\n                    // things simple and return the next function itself.\n                    return function next() {\n                        while(keys.length){\n                            var key = keys.pop();\n                            if (key in object) {\n                                next.value = key;\n                                next.done = false;\n                                return next;\n                            }\n                        }\n                        // To avoid creating an additional object, we just hang the .value\n                        // and .done properties off the next function object itself. This\n                        // also ensures that the minifier will not anonymize the function.\n                        next.done = true;\n                        return next;\n                    };\n                };\n                function values(iterable) {\n                    if (iterable) {\n                        var iteratorMethod = iterable[iteratorSymbol];\n                        if (iteratorMethod) {\n                            return iteratorMethod.call(iterable);\n                        }\n                        if (typeof iterable.next === \"function\") {\n                            return iterable;\n                        }\n                        if (!isNaN(iterable.length)) {\n                            var i = -1, next = function next() {\n                                while(++i < iterable.length){\n                                    if (hasOwn.call(iterable, i)) {\n                                        next.value = iterable[i];\n                                        next.done = false;\n                                        return next;\n                                    }\n                                }\n                                next.value = undefined1;\n                                next.done = true;\n                                return next;\n                            };\n                            return next.next = next;\n                        }\n                    }\n                    // Return an iterator with no values.\n                    return {\n                        next: doneResult\n                    };\n                }\n                exports1.values = values;\n                function doneResult() {\n                    return {\n                        value: undefined1,\n                        done: true\n                    };\n                }\n                Context.prototype = {\n                    constructor: Context,\n                    reset: function(skipTempReset) {\n                        this.prev = 0;\n                        this.next = 0;\n                        // Resetting context._sent for legacy support of Babel's\n                        // function.sent implementation.\n                        this.sent = this._sent = undefined1;\n                        this.done = false;\n                        this.delegate = null;\n                        this.method = \"next\";\n                        this.arg = undefined1;\n                        this.tryEntries.forEach(resetTryEntry);\n                        if (!skipTempReset) {\n                            for(var name in this){\n                                // Not sure about the optimal order of these conditions:\n                                if (name.charAt(0) === \"t\" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {\n                                    this[name] = undefined1;\n                                }\n                            }\n                        }\n                    },\n                    stop: function() {\n                        this.done = true;\n                        var rootEntry = this.tryEntries[0];\n                        var rootRecord = rootEntry.completion;\n                        if (rootRecord.type === \"throw\") {\n                            throw rootRecord.arg;\n                        }\n                        return this.rval;\n                    },\n                    dispatchException: function(exception) {\n                        if (this.done) {\n                            throw exception;\n                        }\n                        var context = this;\n                        function handle(loc, caught) {\n                            record.type = \"throw\";\n                            record.arg = exception;\n                            context.next = loc;\n                            if (caught) {\n                                // If the dispatched exception was caught by a catch block,\n                                // then let that catch block handle the exception normally.\n                                context.method = \"next\";\n                                context.arg = undefined1;\n                            }\n                            return !!caught;\n                        }\n                        for(var i = this.tryEntries.length - 1; i >= 0; --i){\n                            var entry = this.tryEntries[i];\n                            var record = entry.completion;\n                            if (entry.tryLoc === \"root\") {\n                                // Exception thrown outside of any try block that could handle\n                                // it, so set the completion value of the entire function to\n                                // throw the exception.\n                                return handle(\"end\");\n                            }\n                            if (entry.tryLoc <= this.prev) {\n                                var hasCatch = hasOwn.call(entry, \"catchLoc\");\n                                var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n                                if (hasCatch && hasFinally) {\n                                    if (this.prev < entry.catchLoc) {\n                                        return handle(entry.catchLoc, true);\n                                    } else if (this.prev < entry.finallyLoc) {\n                                        return handle(entry.finallyLoc);\n                                    }\n                                } else if (hasCatch) {\n                                    if (this.prev < entry.catchLoc) {\n                                        return handle(entry.catchLoc, true);\n                                    }\n                                } else if (hasFinally) {\n                                    if (this.prev < entry.finallyLoc) {\n                                        return handle(entry.finallyLoc);\n                                    }\n                                } else {\n                                    throw new Error(\"try statement without catch or finally\");\n                                }\n                            }\n                        }\n                    },\n                    abrupt: function(type, arg) {\n                        for(var i = this.tryEntries.length - 1; i >= 0; --i){\n                            var entry = this.tryEntries[i];\n                            if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n                                var finallyEntry = entry;\n                                break;\n                            }\n                        }\n                        if (finallyEntry && (type === \"break\" || type === \"continue\") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {\n                            // Ignore the finally entry if control is not jumping to a\n                            // location outside the try/catch block.\n                            finallyEntry = null;\n                        }\n                        var record = finallyEntry ? finallyEntry.completion : {};\n                        record.type = type;\n                        record.arg = arg;\n                        if (finallyEntry) {\n                            this.method = \"next\";\n                            this.next = finallyEntry.finallyLoc;\n                            return ContinueSentinel;\n                        }\n                        return this.complete(record);\n                    },\n                    complete: function(record, afterLoc) {\n                        if (record.type === \"throw\") {\n                            throw record.arg;\n                        }\n                        if (record.type === \"break\" || record.type === \"continue\") {\n                            this.next = record.arg;\n                        } else if (record.type === \"return\") {\n                            this.rval = this.arg = record.arg;\n                            this.method = \"return\";\n                            this.next = \"end\";\n                        } else if (record.type === \"normal\" && afterLoc) {\n                            this.next = afterLoc;\n                        }\n                        return ContinueSentinel;\n                    },\n                    finish: function(finallyLoc) {\n                        for(var i = this.tryEntries.length - 1; i >= 0; --i){\n                            var entry = this.tryEntries[i];\n                            if (entry.finallyLoc === finallyLoc) {\n                                this.complete(entry.completion, entry.afterLoc);\n                                resetTryEntry(entry);\n                                return ContinueSentinel;\n                            }\n                        }\n                    },\n                    \"catch\": function(tryLoc) {\n                        for(var i = this.tryEntries.length - 1; i >= 0; --i){\n                            var entry = this.tryEntries[i];\n                            if (entry.tryLoc === tryLoc) {\n                                var record = entry.completion;\n                                if (record.type === \"throw\") {\n                                    var thrown = record.arg;\n                                    resetTryEntry(entry);\n                                }\n                                return thrown;\n                            }\n                        }\n                        // The context.catch method must only be called with a location\n                        // argument that corresponds to a known catch block.\n                        throw new Error(\"illegal catch attempt\");\n                    },\n                    delegateYield: function(iterable, resultName, nextLoc) {\n                        this.delegate = {\n                            iterator: values(iterable),\n                            resultName: resultName,\n                            nextLoc: nextLoc\n                        };\n                        if (this.method === \"next\") {\n                            // Deliberately forget the last sent value so that we don't\n                            // accidentally pass it on to the delegate.\n                            this.arg = undefined1;\n                        }\n                        return ContinueSentinel;\n                    }\n                };\n                // Regardless of whether this script is executing as a CommonJS module\n                // or not, return the runtime object so that we can declare the variable\n                // regeneratorRuntime in the outer scope, which allows this module to be\n                // injected easily by `bin/regenerator --include-runtime script.js`.\n                return exports1;\n            }(// If this script is executing as a CommonJS module, use module.exports\n            // as the regeneratorRuntime namespace. Otherwise create a new empty\n            // object. Either way, the resulting object will be used to initialize\n            // the regeneratorRuntime variable at the top of this file.\n             true ? module1.exports : 0);\n            try {\n                regeneratorRuntime = runtime;\n            } catch (accidentalStrictMode) {\n                // This module should not be running in strict mode, so the above\n                // assignment should always work unless something is misconfigured. Just\n                // in case runtime.js accidentally runs in strict mode, we can escape\n                // strict mode using a global Function call. This could conceivably fail\n                // if a Content Security Policy forbids using Function, but in that case\n                // the proper solution is to fix the accidental strict mode problem. If\n                // you've misconfigured your bundler to force strict mode and applied a\n                // CSP to forbid Function, and you're not willing to fix either of those\n                // problems, please detail your unique predicament in a GitHub issue.\n                Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n            }\n        /***/ },\n        /***/ \"./src/api.js\": /*!********************!*\\\n  !*** ./src/api.js ***!\n  \\********************/ /*! exports provided: setup, setupCache, serializeQuery, default */ /***/ function(module1, __nested_webpack_exports__, __nested_webpack_require_194481__) {\n            \"use strict\";\n            __nested_webpack_require_194481__.r(__nested_webpack_exports__);\n            /* harmony export (binding) */ __nested_webpack_require_194481__.d(__nested_webpack_exports__, \"setup\", function() {\n                return setup;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_194481__.d(__nested_webpack_exports__, \"setupCache\", function() {\n                return setupCache;\n            });\n            /* harmony import */ var core_js_modules_es7_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_194481__(/*! core-js/modules/es7.object.get-own-property-descriptors */ \"./node_modules/core-js/modules/es7.object.get-own-property-descriptors.js\");\n            /* harmony import */ var core_js_modules_es7_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __nested_webpack_require_194481__.n(core_js_modules_es7_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_0__);\n            /* harmony import */ var core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_194481__(/*! core-js/modules/es6.symbol */ \"./node_modules/core-js/modules/es6.symbol.js\");\n            /* harmony import */ var core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __nested_webpack_require_194481__.n(core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_1__);\n            /* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_194481__(/*! core-js/modules/es6.array.iterator */ \"./node_modules/core-js/modules/es6.array.iterator.js\");\n            /* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/ __nested_webpack_require_194481__.n(core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_2__);\n            /* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_194481__(/*! core-js/modules/es6.object.to-string */ \"./node_modules/core-js/modules/es6.object.to-string.js\");\n            /* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/ __nested_webpack_require_194481__.n(core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_3__);\n            /* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_194481__(/*! regenerator-runtime/runtime */ \"./node_modules/regenerator-runtime/runtime.js\");\n            /* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/ __nested_webpack_require_194481__.n(regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_4__);\n            /* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_194481__(/*! axios */ \"axios\");\n            /* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/ __nested_webpack_require_194481__.n(axios__WEBPACK_IMPORTED_MODULE_5__);\n            /* harmony import */ var _request__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_194481__(/*! ./request */ \"./src/request.js\");\n            /* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_194481__(/*! ./cache */ \"./src/cache.js\");\n            /* harmony reexport (safe) */ __nested_webpack_require_194481__.d(__nested_webpack_exports__, \"serializeQuery\", function() {\n                return _cache__WEBPACK_IMPORTED_MODULE_7__[\"serializeQuery\"];\n            });\n            /* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_194481__(/*! ./config */ \"./src/config.js\");\n            /* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_194481__(/*! ./utilities */ \"./src/utilities.js\");\n            function _objectWithoutProperties(source, excluded) {\n                if (source == null) return {};\n                var target = _objectWithoutPropertiesLoose(source, excluded);\n                var key, i;\n                if (Object.getOwnPropertySymbols) {\n                    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n                    for(i = 0; i < sourceSymbolKeys.length; i++){\n                        key = sourceSymbolKeys[i];\n                        if (excluded.indexOf(key) >= 0) continue;\n                        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n                        target[key] = source[key];\n                    }\n                }\n                return target;\n            }\n            function _objectWithoutPropertiesLoose(source, excluded) {\n                if (source == null) return {};\n                var target = {};\n                var sourceKeys = Object.keys(source);\n                var key, i;\n                for(i = 0; i < sourceKeys.length; i++){\n                    key = sourceKeys[i];\n                    if (excluded.indexOf(key) >= 0) continue;\n                    target[key] = source[key];\n                }\n                return target;\n            }\n            function ownKeys(object, enumerableOnly) {\n                var keys = Object.keys(object);\n                if (Object.getOwnPropertySymbols) {\n                    var symbols = Object.getOwnPropertySymbols(object);\n                    if (enumerableOnly) symbols = symbols.filter(function(sym) {\n                        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n                    });\n                    keys.push.apply(keys, symbols);\n                }\n                return keys;\n            }\n            function _objectSpread(target) {\n                for(var i = 1; i < arguments.length; i++){\n                    var source = arguments[i] != null ? arguments[i] : {};\n                    if (i % 2) {\n                        ownKeys(Object(source), true).forEach(function(key) {\n                            _defineProperty(target, key, source[key]);\n                        });\n                    } else if (Object.getOwnPropertyDescriptors) {\n                        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n                    } else {\n                        ownKeys(Object(source)).forEach(function(key) {\n                            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n                        });\n                    }\n                }\n                return target;\n            }\n            function _defineProperty(obj, key, value) {\n                if (key in obj) {\n                    Object.defineProperty(obj, key, {\n                        value: value,\n                        enumerable: true,\n                        configurable: true,\n                        writable: true\n                    });\n                } else {\n                    obj[key] = value;\n                }\n                return obj;\n            }\n            function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n                try {\n                    var info = gen[key](arg);\n                    var value = info.value;\n                } catch (error) {\n                    reject(error);\n                    return;\n                }\n                if (info.done) {\n                    resolve(value);\n                } else {\n                    Promise.resolve(value).then(_next, _throw);\n                }\n            }\n            function _asyncToGenerator(fn) {\n                return function() {\n                    var self1 = this, args = arguments;\n                    return new Promise(function(resolve, reject) {\n                        var gen = fn.apply(self1, args);\n                        function _next(value) {\n                            asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n                        }\n                        function _throw(err) {\n                            asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n                        }\n                        _next(undefined);\n                    });\n                };\n            }\n            /**\n * Configure cache adapter\n *\n * @param   {object} [config={}] Cache adapter options\n * @returns {object} Object containing cache `adapter` and `store`\n */ function setupCache() {\n                var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n                // Extend default configuration\n                config = Object(_config__WEBPACK_IMPORTED_MODULE_8__[\"makeConfig\"])(config); // Axios adapter. Receives the axios request configuration as only parameter\n                function adapter(_x) {\n                    return _adapter.apply(this, arguments);\n                } // Return adapter and store instance\n                function _adapter() {\n                    _adapter = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee(req) {\n                        var reqConfig, res, next, networkError, readOnError;\n                        return regeneratorRuntime.wrap(function _callee$(_context) {\n                            while(1){\n                                switch(_context.prev = _context.next){\n                                    case 0:\n                                        // Merge the per-request config with the instance config.\n                                        reqConfig = Object(_config__WEBPACK_IMPORTED_MODULE_8__[\"mergeRequestConfig\"])(config, req); // Execute request against local cache\n                                        _context.next = 3;\n                                        return Object(_request__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(reqConfig, req);\n                                    case 3:\n                                        res = _context.sent;\n                                        next = res.next; // Response is not function, something was in cache, return it\n                                        if (Object(_utilities__WEBPACK_IMPORTED_MODULE_9__[\"isFunction\"])(next)) {\n                                            _context.next = 7;\n                                            break;\n                                        }\n                                        return _context.abrupt(\"return\", next);\n                                    case 7:\n                                        _context.prev = 7;\n                                        _context.next = 10;\n                                        return reqConfig.adapter(req);\n                                    case 10:\n                                        res = _context.sent;\n                                        _context.next = 16;\n                                        break;\n                                    case 13:\n                                        _context.prev = 13;\n                                        _context.t0 = _context[\"catch\"](7);\n                                        networkError = _context.t0;\n                                    case 16:\n                                        if (!networkError) {\n                                            _context.next = 31;\n                                            break;\n                                        }\n                                        // Check if we should attempt reading stale cache data\n                                        readOnError = Object(_utilities__WEBPACK_IMPORTED_MODULE_9__[\"isFunction\"])(reqConfig.readOnError) ? reqConfig.readOnError(networkError, req) : reqConfig.readOnError;\n                                        if (!readOnError) {\n                                            _context.next = 30;\n                                            break;\n                                        }\n                                        _context.prev = 19;\n                                        // Force cache tu return stale data\n                                        reqConfig.acceptStale = true; // Try to read from cache again\n                                        _context.next = 23;\n                                        return Object(_request__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(reqConfig, req);\n                                    case 23:\n                                        res = _context.sent;\n                                        // Signal that data is from stale cache\n                                        res.next.request.stale = true; // No need to check if `next` is a function just return cache data\n                                        return _context.abrupt(\"return\", res.next);\n                                    case 28:\n                                        _context.prev = 28;\n                                        _context.t1 = _context[\"catch\"](19);\n                                    case 30:\n                                        throw networkError;\n                                    case 31:\n                                        return _context.abrupt(\"return\", next(res));\n                                    case 32:\n                                    case \"end\":\n                                        return _context.stop();\n                                }\n                            }\n                        }, _callee, null, [\n                            [\n                                7,\n                                13\n                            ],\n                            [\n                                19,\n                                28\n                            ]\n                        ]);\n                    }));\n                    return _adapter.apply(this, arguments);\n                }\n                return {\n                    adapter: adapter,\n                    config: config,\n                    store: config.store\n                };\n            } // ---------------------\n            // Easy API Setup\n            // ---------------------\n            /**\n * Setup an axios instance with the cache adapter pre-configured\n *\n * @param {object} [options={}] Axios and cache adapter options\n * @returns {object} Instance of Axios\n */ function setup() {\n                var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n                var instanceConfig = _objectSpread(_objectSpread(_objectSpread({}, _config__WEBPACK_IMPORTED_MODULE_8__[\"defaults\"].axios), config), {}, {\n                    cache: _objectSpread(_objectSpread({}, _config__WEBPACK_IMPORTED_MODULE_8__[\"defaults\"].axios.cache), config.cache)\n                });\n                var cache = setupCache(instanceConfig.cache);\n                var _ = instanceConfig.cache, axiosConfig = _objectWithoutProperties(instanceConfig, [\n                    \"cache\"\n                ]);\n                var api = axios__WEBPACK_IMPORTED_MODULE_5___default.a.create(_objectSpread(_objectSpread({}, axiosConfig), {}, {\n                    adapter: cache.adapter\n                }));\n                api.cache = cache.store;\n                return api;\n            }\n            /* harmony default export */ __nested_webpack_exports__[\"default\"] = {\n                setup: setup,\n                setupCache: setupCache,\n                serializeQuery: _cache__WEBPACK_IMPORTED_MODULE_7__[\"serializeQuery\"]\n            };\n        /***/ },\n        /***/ \"./src/cache.js\": /*!**********************!*\\\n  !*** ./src/cache.js ***!\n  \\**********************/ /*! exports provided: read, write, key, invalidate, serializeQuery, default */ /***/ function(module1, __nested_webpack_exports__, __nested_webpack_require_209903__) {\n            \"use strict\";\n            __nested_webpack_require_209903__.r(__nested_webpack_exports__);\n            /* harmony export (binding) */ __nested_webpack_require_209903__.d(__nested_webpack_exports__, \"read\", function() {\n                return read;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_209903__.d(__nested_webpack_exports__, \"write\", function() {\n                return write;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_209903__.d(__nested_webpack_exports__, \"key\", function() {\n                return key;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_209903__.d(__nested_webpack_exports__, \"invalidate\", function() {\n                return invalidate;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_209903__.d(__nested_webpack_exports__, \"serializeQuery\", function() {\n                return serializeQuery;\n            });\n            /* harmony import */ var core_js_modules_es7_array_includes__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_209903__(/*! core-js/modules/es7.array.includes */ \"./node_modules/core-js/modules/es7.array.includes.js\");\n            /* harmony import */ var core_js_modules_es7_array_includes__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __nested_webpack_require_209903__.n(core_js_modules_es7_array_includes__WEBPACK_IMPORTED_MODULE_0__);\n            /* harmony import */ var core_js_modules_es6_string_includes__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_209903__(/*! core-js/modules/es6.string.includes */ \"./node_modules/core-js/modules/es6.string.includes.js\");\n            /* harmony import */ var core_js_modules_es6_string_includes__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __nested_webpack_require_209903__.n(core_js_modules_es6_string_includes__WEBPACK_IMPORTED_MODULE_1__);\n            /* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_209903__(/*! regenerator-runtime/runtime */ \"./node_modules/regenerator-runtime/runtime.js\");\n            /* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/ __nested_webpack_require_209903__.n(regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_2__);\n            /* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_209903__(/*! core-js/modules/es6.array.iterator */ \"./node_modules/core-js/modules/es6.array.iterator.js\");\n            /* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/ __nested_webpack_require_209903__.n(core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_3__);\n            /* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_209903__(/*! core-js/modules/es6.object.to-string */ \"./node_modules/core-js/modules/es6.object.to-string.js\");\n            /* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/ __nested_webpack_require_209903__.n(core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_4__);\n            /* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_209903__(/*! ./utilities */ \"./src/utilities.js\");\n            /* harmony import */ var md5__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_209903__(/*! md5 */ \"./node_modules/md5/md5.js\");\n            /* harmony import */ var md5__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/ __nested_webpack_require_209903__.n(md5__WEBPACK_IMPORTED_MODULE_6__);\n            /* harmony import */ var _serialize__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_209903__(/*! ./serialize */ \"./src/serialize.js\");\n            function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n                try {\n                    var info = gen[key](arg);\n                    var value = info.value;\n                } catch (error) {\n                    reject(error);\n                    return;\n                }\n                if (info.done) {\n                    resolve(value);\n                } else {\n                    Promise.resolve(value).then(_next, _throw);\n                }\n            }\n            function _asyncToGenerator(fn) {\n                return function() {\n                    var self1 = this, args = arguments;\n                    return new Promise(function(resolve, reject) {\n                        var gen = fn.apply(self1, args);\n                        function _next(value) {\n                            asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n                        }\n                        function _throw(err) {\n                            asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n                        }\n                        _next(undefined);\n                    });\n                };\n            }\n            function write(_x, _x2, _x3) {\n                return _write.apply(this, arguments);\n            }\n            function _write() {\n                _write = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee(config, req, res) {\n                    var entry;\n                    return regeneratorRuntime.wrap(function _callee$(_context) {\n                        while(1){\n                            switch(_context.prev = _context.next){\n                                case 0:\n                                    _context.prev = 0;\n                                    entry = {\n                                        expires: config.expires,\n                                        data: Object(_serialize__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(config, req, res)\n                                    };\n                                    _context.next = 4;\n                                    return config.store.setItem(config.uuid, entry);\n                                case 4:\n                                    _context.next = 19;\n                                    break;\n                                case 6:\n                                    _context.prev = 6;\n                                    _context.t0 = _context[\"catch\"](0);\n                                    config.debug(\"Could not store response\", _context.t0);\n                                    if (!config.clearOnError) {\n                                        _context.next = 18;\n                                        break;\n                                    }\n                                    _context.prev = 10;\n                                    _context.next = 13;\n                                    return config.store.clear();\n                                case 13:\n                                    _context.next = 18;\n                                    break;\n                                case 15:\n                                    _context.prev = 15;\n                                    _context.t1 = _context[\"catch\"](10);\n                                    config.debug(\"Could not clear store\", _context.t1);\n                                case 18:\n                                    return _context.abrupt(\"return\", false);\n                                case 19:\n                                    return _context.abrupt(\"return\", true);\n                                case 20:\n                                case \"end\":\n                                    return _context.stop();\n                            }\n                        }\n                    }, _callee, null, [\n                        [\n                            0,\n                            6\n                        ],\n                        [\n                            10,\n                            15\n                        ]\n                    ]);\n                }));\n                return _write.apply(this, arguments);\n            }\n            function read(_x4, _x5) {\n                return _read.apply(this, arguments);\n            }\n            function _read() {\n                _read = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee2(config, req) {\n                    var uuid, ignoreCache, entry, error, expires, data, offline, _error;\n                    return regeneratorRuntime.wrap(function _callee2$(_context2) {\n                        while(1){\n                            switch(_context2.prev = _context2.next){\n                                case 0:\n                                    uuid = config.uuid, ignoreCache = config.ignoreCache;\n                                    _context2.next = 3;\n                                    return config.store.getItem(uuid);\n                                case 3:\n                                    entry = _context2.sent;\n                                    if (!(ignoreCache || !entry || !entry.data)) {\n                                        _context2.next = 10;\n                                        break;\n                                    }\n                                    config.debug(\"cache-miss\", req.url);\n                                    error = new Error();\n                                    error.reason = \"cache-miss\";\n                                    error.message = \"Entry not found from cache\";\n                                    throw error;\n                                case 10:\n                                    expires = entry.expires, data = entry.data; // Do not check for stale cache if offline on client-side\n                                    offline = typeof navigator !== \"undefined\" && \"onLine\" in navigator && !navigator.onLine;\n                                    if (!(!offline && !config.acceptStale && expires !== 0 && expires < Date.now())) {\n                                        _context2.next = 18;\n                                        break;\n                                    }\n                                    config.debug(\"cache-stale\", req.url);\n                                    _error = new Error();\n                                    _error.reason = \"cache-stale\";\n                                    _error.message = \"Entry is stale\";\n                                    throw _error;\n                                case 18:\n                                    config.debug(config.acceptStale ? \"cache-hit-stale\" : \"cache-hit\", req.url);\n                                    return _context2.abrupt(\"return\", data);\n                                case 20:\n                                case \"end\":\n                                    return _context2.stop();\n                            }\n                        }\n                    }, _callee2);\n                }));\n                return _read.apply(this, arguments);\n            }\n            function key(config) {\n                if (Object(_utilities__WEBPACK_IMPORTED_MODULE_5__[\"isFunction\"])(config.key)) return config.key;\n                var cacheKey;\n                if (Object(_utilities__WEBPACK_IMPORTED_MODULE_5__[\"isString\"])(config.key)) {\n                    cacheKey = function cacheKey(req) {\n                        var url = \"\".concat(req.baseURL ? req.baseURL : \"\").concat(req.url);\n                        var key = \"\".concat(config.key, \"/\").concat(url).concat(serializeQuery(req));\n                        return req.data ? key + md5__WEBPACK_IMPORTED_MODULE_6___default()(req.data) : key;\n                    };\n                } else {\n                    cacheKey = function cacheKey(req) {\n                        var url = \"\".concat(req.baseURL ? req.baseURL : \"\").concat(req.url);\n                        var key = url + serializeQuery(req);\n                        return req.data ? key + md5__WEBPACK_IMPORTED_MODULE_6___default()(req.data) : key;\n                    };\n                }\n                return cacheKey;\n            }\n            function defaultInvalidate(_x6, _x7) {\n                return _defaultInvalidate.apply(this, arguments);\n            }\n            function _defaultInvalidate() {\n                _defaultInvalidate = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee3(config, req) {\n                    var method;\n                    return regeneratorRuntime.wrap(function _callee3$(_context3) {\n                        while(1){\n                            switch(_context3.prev = _context3.next){\n                                case 0:\n                                    method = req.method.toLowerCase();\n                                    if (!config.exclude.methods.includes(method)) {\n                                        _context3.next = 4;\n                                        break;\n                                    }\n                                    _context3.next = 4;\n                                    return config.store.removeItem(config.uuid);\n                                case 4:\n                                case \"end\":\n                                    return _context3.stop();\n                            }\n                        }\n                    }, _callee3);\n                }));\n                return _defaultInvalidate.apply(this, arguments);\n            }\n            function invalidate() {\n                var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n                if (Object(_utilities__WEBPACK_IMPORTED_MODULE_5__[\"isFunction\"])(config.invalidate)) return config.invalidate;\n                return defaultInvalidate;\n            }\n            function serializeQuery(req) {\n                if (!req.params) return \"\"; // Probably server-side, just stringify the object\n                if (typeof URLSearchParams === \"undefined\") return JSON.stringify(req.params);\n                var params = req.params;\n                var isInstanceOfURLSearchParams = req.params instanceof URLSearchParams; // Convert to an instance of URLSearchParams so it get serialized the same way\n                if (!isInstanceOfURLSearchParams) {\n                    params = new URLSearchParams();\n                    Object.keys(req.params).forEach(function(key) {\n                        return params.append(key, req.params[key]);\n                    });\n                }\n                return \"?\".concat(params.toString());\n            }\n            /* harmony default export */ __nested_webpack_exports__[\"default\"] = {\n                read: read,\n                write: write,\n                key: key,\n                invalidate: invalidate,\n                serializeQuery: serializeQuery\n            };\n        /***/ },\n        /***/ \"./src/config.js\": /*!***********************!*\\\n  !*** ./src/config.js ***!\n  \\***********************/ /*! exports provided: defaults, makeConfig, mergeRequestConfig, default */ /***/ function(module1, __nested_webpack_exports__, __nested_webpack_require_224645__) {\n            \"use strict\";\n            __nested_webpack_require_224645__.r(__nested_webpack_exports__);\n            /* harmony export (binding) */ __nested_webpack_require_224645__.d(__nested_webpack_exports__, \"defaults\", function() {\n                return defaults;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_224645__.d(__nested_webpack_exports__, \"makeConfig\", function() {\n                return makeConfig;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_224645__.d(__nested_webpack_exports__, \"mergeRequestConfig\", function() {\n                return mergeRequestConfig;\n            });\n            /* harmony import */ var core_js_modules_es7_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_224645__(/*! core-js/modules/es7.object.get-own-property-descriptors */ \"./node_modules/core-js/modules/es7.object.get-own-property-descriptors.js\");\n            /* harmony import */ var core_js_modules_es7_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __nested_webpack_require_224645__.n(core_js_modules_es7_object_get_own_property_descriptors__WEBPACK_IMPORTED_MODULE_0__);\n            /* harmony import */ var core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_224645__(/*! core-js/modules/es6.symbol */ \"./node_modules/core-js/modules/es6.symbol.js\");\n            /* harmony import */ var core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __nested_webpack_require_224645__.n(core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_1__);\n            /* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_224645__(/*! core-js/modules/es6.array.iterator */ \"./node_modules/core-js/modules/es6.array.iterator.js\");\n            /* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/ __nested_webpack_require_224645__.n(core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_2__);\n            /* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_224645__(/*! core-js/modules/es6.object.to-string */ \"./node_modules/core-js/modules/es6.object.to-string.js\");\n            /* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/ __nested_webpack_require_224645__.n(core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_3__);\n            /* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_224645__(/*! axios */ \"axios\");\n            /* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/ __nested_webpack_require_224645__.n(axios__WEBPACK_IMPORTED_MODULE_4__);\n            /* harmony import */ var _memory__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_224645__(/*! ./memory */ \"./src/memory.js\");\n            /* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_224645__(/*! ./cache */ \"./src/cache.js\");\n            function ownKeys(object, enumerableOnly) {\n                var keys = Object.keys(object);\n                if (Object.getOwnPropertySymbols) {\n                    var symbols = Object.getOwnPropertySymbols(object);\n                    if (enumerableOnly) symbols = symbols.filter(function(sym) {\n                        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n                    });\n                    keys.push.apply(keys, symbols);\n                }\n                return keys;\n            }\n            function _objectSpread(target) {\n                for(var i = 1; i < arguments.length; i++){\n                    var source = arguments[i] != null ? arguments[i] : {};\n                    if (i % 2) {\n                        ownKeys(Object(source), true).forEach(function(key) {\n                            _defineProperty(target, key, source[key]);\n                        });\n                    } else if (Object.getOwnPropertyDescriptors) {\n                        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n                    } else {\n                        ownKeys(Object(source)).forEach(function(key) {\n                            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n                        });\n                    }\n                }\n                return target;\n            }\n            function _defineProperty(obj, key, value) {\n                if (key in obj) {\n                    Object.defineProperty(obj, key, {\n                        value: value,\n                        enumerable: true,\n                        configurable: true,\n                        writable: true\n                    });\n                } else {\n                    obj[key] = value;\n                }\n                return obj;\n            }\n            var noop = function noop() {};\n            var debug = function debug() {\n                var _console;\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                return (_console = console).log.apply(_console, [\n                    \"[axios-cache-adapter]\"\n                ].concat(args));\n            };\n            var defaults = {\n                // Default settings when solely creating the cache adapter with setupCache.\n                cache: {\n                    maxAge: 0,\n                    limit: false,\n                    store: null,\n                    key: null,\n                    invalidate: null,\n                    exclude: {\n                        paths: [],\n                        query: true,\n                        filter: null,\n                        methods: [\n                            \"post\",\n                            \"patch\",\n                            \"put\",\n                            \"delete\"\n                        ]\n                    },\n                    adapter: axios__WEBPACK_IMPORTED_MODULE_4___default.a.defaults.adapter,\n                    clearOnStale: true,\n                    clearOnError: true,\n                    readOnError: false,\n                    readHeaders: false,\n                    debug: false,\n                    ignoreCache: false\n                },\n                // Additional defaults when creating the axios instance with the cache adapter.\n                axios: {\n                    cache: {\n                        maxAge: 15 * 60 * 1000\n                    }\n                }\n            }; // List of disallowed in the per-request config.\n            var disallowedPerRequestKeys = [\n                \"limit\",\n                \"store\",\n                \"adapter\",\n                \"uuid\",\n                \"acceptStale\"\n            ];\n            /**\n * Make a global config object.\n *\n * @param {Object} [override={}] Optional config override.\n * @return {Object}\n */ var makeConfig = function makeConfig() {\n                var override = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n                var config = _objectSpread(_objectSpread(_objectSpread({}, defaults.cache), override), {}, {\n                    exclude: _objectSpread(_objectSpread({}, defaults.cache.exclude), override.exclude)\n                }); // Create a cache key method\n                config.key = Object(_cache__WEBPACK_IMPORTED_MODULE_6__[\"key\"])(config);\n                config.invalidate = Object(_cache__WEBPACK_IMPORTED_MODULE_6__[\"invalidate\"])(config); // If debug mode is on, create a simple logger method\n                if (config.debug !== false) {\n                    config.debug = typeof config.debug === \"function\" ? config.debug : debug;\n                } else {\n                    config.debug = noop;\n                } // Create an in memory store if none was given\n                if (!config.store) config.store = new _memory__WEBPACK_IMPORTED_MODULE_5__[\"default\"]();\n                config.debug(\"Global cache config\", config);\n                return config;\n            };\n            /**\n * Merge the per-request config in another config.\n *\n * This method exists because not all keys should be allowed as it\n * may lead to unexpected behaviours. For instance, setting another\n * store or adapter per request is wrong, instead another instance\n * axios, or the adapter, should be used.\n *\n * @param {Object} config Config object.\n * @param {Object} req    The current axios request\n * @return {Object}\n */ var mergeRequestConfig = function mergeRequestConfig(config, req) {\n                var requestConfig = req.cache || {};\n                if (requestConfig) {\n                    disallowedPerRequestKeys.forEach(function(key) {\n                        return requestConfig[key] ? delete requestConfig[key] : undefined;\n                    });\n                }\n                var mergedConfig = _objectSpread(_objectSpread(_objectSpread({}, config), requestConfig), {}, {\n                    exclude: _objectSpread(_objectSpread({}, config.exclude), requestConfig.exclude)\n                });\n                if (mergedConfig.debug === true) {\n                    mergedConfig.debug = debug;\n                } // Create a cache key method\n                if (requestConfig.key) {\n                    mergedConfig.key = Object(_cache__WEBPACK_IMPORTED_MODULE_6__[\"key\"])(requestConfig);\n                } // Generate request UUID\n                mergedConfig.uuid = mergedConfig.key(req);\n                config.debug(\"Request config for \".concat(req.url), mergedConfig);\n                return mergedConfig;\n            };\n            /* harmony default export */ __nested_webpack_exports__[\"default\"] = {\n                defaults: defaults,\n                makeConfig: makeConfig,\n                mergeRequestConfig: mergeRequestConfig\n            };\n        /***/ },\n        /***/ \"./src/exclude.js\": /*!************************!*\\\n  !*** ./src/exclude.js ***!\n  \\************************/ /*! exports provided: default */ /***/ function(module1, __nested_webpack_exports__, __nested_webpack_require_234700__) {\n            \"use strict\";\n            __nested_webpack_require_234700__.r(__nested_webpack_exports__);\n            /* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_234700__(/*! core-js/modules/es6.array.iterator */ \"./node_modules/core-js/modules/es6.array.iterator.js\");\n            /* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __nested_webpack_require_234700__.n(core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_0__);\n            /* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_234700__(/*! core-js/modules/es6.object.to-string */ \"./node_modules/core-js/modules/es6.object.to-string.js\");\n            /* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __nested_webpack_require_234700__.n(core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_1__);\n            /* harmony import */ var core_js_modules_es7_array_includes__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_234700__(/*! core-js/modules/es7.array.includes */ \"./node_modules/core-js/modules/es7.array.includes.js\");\n            /* harmony import */ var core_js_modules_es7_array_includes__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/ __nested_webpack_require_234700__.n(core_js_modules_es7_array_includes__WEBPACK_IMPORTED_MODULE_2__);\n            /* harmony import */ var core_js_modules_es6_string_includes__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_234700__(/*! core-js/modules/es6.string.includes */ \"./node_modules/core-js/modules/es6.string.includes.js\");\n            /* harmony import */ var core_js_modules_es6_string_includes__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/ __nested_webpack_require_234700__.n(core_js_modules_es6_string_includes__WEBPACK_IMPORTED_MODULE_3__);\n            /* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_234700__(/*! ./utilities */ \"./src/utilities.js\");\n            function exclude() {\n                var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n                var req = arguments.length > 1 ? arguments[1] : undefined;\n                var _config$exclude = config.exclude, exclude = _config$exclude === void 0 ? {} : _config$exclude, debug = config.debug;\n                var method = req.method.toLowerCase();\n                if (method === \"head\" || exclude.methods.includes(method)) {\n                    debug(\"Excluding request by HTTP method \".concat(req.url));\n                    return true;\n                }\n                if (typeof exclude.filter === \"function\" && exclude.filter(req)) {\n                    debug(\"Excluding request by filter \".concat(req.url));\n                    return true;\n                } // do not cache request with query\n                var hasQueryParams = /\\?.*$/.test(req.url) || Object(_utilities__WEBPACK_IMPORTED_MODULE_4__[\"isObject\"])(req.params) && Object.keys(req.params).length !== 0 || typeof URLSearchParams !== \"undefined\" && req.params instanceof URLSearchParams;\n                if (exclude.query && hasQueryParams) {\n                    debug(\"Excluding request by query \".concat(req.url));\n                    return true;\n                }\n                var paths = exclude.paths || [];\n                var found = paths.some(function(regexp) {\n                    return req.url.match(regexp);\n                });\n                if (found) {\n                    debug(\"Excluding request by url match \".concat(req.url));\n                    return true;\n                }\n                return false;\n            }\n            /* harmony default export */ __nested_webpack_exports__[\"default\"] = exclude;\n        /***/ },\n        /***/ \"./src/index.node.js\": /*!***************************!*\\\n  !*** ./src/index.node.js ***!\n  \\***************************/ /*! exports provided: setup, setupCache, serializeQuery, RedisStore, RedisDefaultStore, default */ /***/ function(module1, __nested_webpack_exports__, __nested_webpack_require_238750__) {\n            \"use strict\";\n            __nested_webpack_require_238750__.r(__nested_webpack_exports__);\n            /* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_238750__(/*! ./api */ \"./src/api.js\");\n            /* harmony reexport (safe) */ __nested_webpack_require_238750__.d(__nested_webpack_exports__, \"setup\", function() {\n                return _api__WEBPACK_IMPORTED_MODULE_0__[\"setup\"];\n            });\n            /* harmony reexport (safe) */ __nested_webpack_require_238750__.d(__nested_webpack_exports__, \"setupCache\", function() {\n                return _api__WEBPACK_IMPORTED_MODULE_0__[\"setupCache\"];\n            });\n            /* harmony reexport (safe) */ __nested_webpack_require_238750__.d(__nested_webpack_exports__, \"serializeQuery\", function() {\n                return _api__WEBPACK_IMPORTED_MODULE_0__[\"serializeQuery\"];\n            });\n            /* harmony import */ var _redis__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_238750__(/*! ./redis */ \"./src/redis.js\");\n            /* harmony reexport (safe) */ __nested_webpack_require_238750__.d(__nested_webpack_exports__, \"RedisStore\", function() {\n                return _redis__WEBPACK_IMPORTED_MODULE_1__[\"default\"];\n            });\n            /* harmony import */ var _redis_default__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_238750__(/*! ./redis-default */ \"./src/redis-default.js\");\n            /* harmony reexport (safe) */ __nested_webpack_require_238750__.d(__nested_webpack_exports__, \"RedisDefaultStore\", function() {\n                return _redis_default__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\n            });\n            /* harmony default export */ __nested_webpack_exports__[\"default\"] = {\n                setup: _api__WEBPACK_IMPORTED_MODULE_0__[\"setup\"],\n                setupCache: _api__WEBPACK_IMPORTED_MODULE_0__[\"setupCache\"],\n                serializeQuery: _api__WEBPACK_IMPORTED_MODULE_0__[\"serializeQuery\"],\n                RedisStore: _redis__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n                RedisDefaultStore: _redis_default__WEBPACK_IMPORTED_MODULE_2__[\"default\"]\n            };\n        /***/ },\n        /***/ \"./src/limit.js\": /*!**********************!*\\\n  !*** ./src/limit.js ***!\n  \\**********************/ /*! exports provided: default */ /***/ function(module1, __nested_webpack_exports__, __nested_webpack_require_240967__) {\n            \"use strict\";\n            __nested_webpack_require_240967__.r(__nested_webpack_exports__);\n            /* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_240967__(/*! regenerator-runtime/runtime */ \"./node_modules/regenerator-runtime/runtime.js\");\n            /* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __nested_webpack_require_240967__.n(regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0__);\n            /* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_240967__(/*! core-js/modules/es6.object.to-string */ \"./node_modules/core-js/modules/es6.object.to-string.js\");\n            /* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __nested_webpack_require_240967__.n(core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_1__);\n            function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n                try {\n                    var info = gen[key](arg);\n                    var value = info.value;\n                } catch (error) {\n                    reject(error);\n                    return;\n                }\n                if (info.done) {\n                    resolve(value);\n                } else {\n                    Promise.resolve(value).then(_next, _throw);\n                }\n            }\n            function _asyncToGenerator(fn) {\n                return function() {\n                    var self1 = this, args = arguments;\n                    return new Promise(function(resolve, reject) {\n                        var gen = fn.apply(self1, args);\n                        function _next(value) {\n                            asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n                        }\n                        function _throw(err) {\n                            asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n                        }\n                        _next(undefined);\n                    });\n                };\n            }\n            function limit(_x) {\n                return _limit.apply(this, arguments);\n            }\n            function _limit() {\n                _limit = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee(config) {\n                    var length, firstItem;\n                    return regeneratorRuntime.wrap(function _callee$(_context) {\n                        while(1){\n                            switch(_context.prev = _context.next){\n                                case 0:\n                                    _context.next = 2;\n                                    return config.store.length();\n                                case 2:\n                                    length = _context.sent;\n                                    if (!(length < config.limit)) {\n                                        _context.next = 5;\n                                        break;\n                                    }\n                                    return _context.abrupt(\"return\");\n                                case 5:\n                                    config.debug(\"Current store size: \".concat(length));\n                                    _context.next = 8;\n                                    return config.store.iterate(function(value, key) {\n                                        if (!firstItem) firstItem = {\n                                            value: value,\n                                            key: key\n                                        };\n                                        if (value.expires < firstItem.value.expires) firstItem = {\n                                            value: value,\n                                            key: key\n                                        };\n                                    });\n                                case 8:\n                                    if (!firstItem) {\n                                        _context.next = 12;\n                                        break;\n                                    }\n                                    config.debug(\"Removing item: \".concat(firstItem.key));\n                                    _context.next = 12;\n                                    return config.store.removeItem(firstItem.key);\n                                case 12:\n                                case \"end\":\n                                    return _context.stop();\n                            }\n                        }\n                    }, _callee);\n                }));\n                return _limit.apply(this, arguments);\n            }\n            /* harmony default export */ __nested_webpack_exports__[\"default\"] = limit;\n        /***/ },\n        /***/ \"./src/memory.js\": /*!***********************!*\\\n  !*** ./src/memory.js ***!\n  \\***********************/ /*! exports provided: default */ /***/ function(module1, __nested_webpack_exports__, __nested_webpack_require_246013__) {\n            \"use strict\";\n            __nested_webpack_require_246013__.r(__nested_webpack_exports__);\n            /* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_246013__(/*! core-js/modules/es6.array.iterator */ \"./node_modules/core-js/modules/es6.array.iterator.js\");\n            /* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __nested_webpack_require_246013__.n(core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_0__);\n            /* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_246013__(/*! core-js/modules/es6.object.to-string */ \"./node_modules/core-js/modules/es6.object.to-string.js\");\n            /* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __nested_webpack_require_246013__.n(core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_1__);\n            /* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_246013__(/*! regenerator-runtime/runtime */ \"./node_modules/regenerator-runtime/runtime.js\");\n            /* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/ __nested_webpack_require_246013__.n(regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_2__);\n            /* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_246013__(/*! ./utilities */ \"./src/utilities.js\");\n            function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n                try {\n                    var info = gen[key](arg);\n                    var value = info.value;\n                } catch (error) {\n                    reject(error);\n                    return;\n                }\n                if (info.done) {\n                    resolve(value);\n                } else {\n                    Promise.resolve(value).then(_next, _throw);\n                }\n            }\n            function _asyncToGenerator(fn) {\n                return function() {\n                    var self1 = this, args = arguments;\n                    return new Promise(function(resolve, reject) {\n                        var gen = fn.apply(self1, args);\n                        function _next(value) {\n                            asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n                        }\n                        function _throw(err) {\n                            asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n                        }\n                        _next(undefined);\n                    });\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function _createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) _defineProperties(Constructor, staticProps);\n                return Constructor;\n            }\n            var MemoryStore = /*#__PURE__*/ function() {\n                function MemoryStore() {\n                    _classCallCheck(this, MemoryStore);\n                    this.store = {};\n                }\n                _createClass(MemoryStore, [\n                    {\n                        key: \"getItem\",\n                        value: function() {\n                            var _getItem = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee(key) {\n                                var item;\n                                return regeneratorRuntime.wrap(function _callee$(_context) {\n                                    while(1){\n                                        switch(_context.prev = _context.next){\n                                            case 0:\n                                                item = this.store[key] || null;\n                                                return _context.abrupt(\"return\", JSON.parse(item));\n                                            case 2:\n                                            case \"end\":\n                                                return _context.stop();\n                                        }\n                                    }\n                                }, _callee, this);\n                            }));\n                            function getItem(_x) {\n                                return _getItem.apply(this, arguments);\n                            }\n                            return getItem;\n                        }()\n                    },\n                    {\n                        key: \"setItem\",\n                        value: function() {\n                            var _setItem = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee2(key, value) {\n                                return regeneratorRuntime.wrap(function _callee2$(_context2) {\n                                    while(1){\n                                        switch(_context2.prev = _context2.next){\n                                            case 0:\n                                                this.store[key] = JSON.stringify(value);\n                                                return _context2.abrupt(\"return\", value);\n                                            case 2:\n                                            case \"end\":\n                                                return _context2.stop();\n                                        }\n                                    }\n                                }, _callee2, this);\n                            }));\n                            function setItem(_x2, _x3) {\n                                return _setItem.apply(this, arguments);\n                            }\n                            return setItem;\n                        }()\n                    },\n                    {\n                        key: \"removeItem\",\n                        value: function() {\n                            var _removeItem = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee3(key) {\n                                return regeneratorRuntime.wrap(function _callee3$(_context3) {\n                                    while(1){\n                                        switch(_context3.prev = _context3.next){\n                                            case 0:\n                                                delete this.store[key];\n                                            case 1:\n                                            case \"end\":\n                                                return _context3.stop();\n                                        }\n                                    }\n                                }, _callee3, this);\n                            }));\n                            function removeItem(_x4) {\n                                return _removeItem.apply(this, arguments);\n                            }\n                            return removeItem;\n                        }()\n                    },\n                    {\n                        key: \"clear\",\n                        value: function() {\n                            var _clear = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee4() {\n                                return regeneratorRuntime.wrap(function _callee4$(_context4) {\n                                    while(1){\n                                        switch(_context4.prev = _context4.next){\n                                            case 0:\n                                                this.store = {};\n                                            case 1:\n                                            case \"end\":\n                                                return _context4.stop();\n                                        }\n                                    }\n                                }, _callee4, this);\n                            }));\n                            function clear() {\n                                return _clear.apply(this, arguments);\n                            }\n                            return clear;\n                        }()\n                    },\n                    {\n                        key: \"length\",\n                        value: function() {\n                            var _length = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee5() {\n                                return regeneratorRuntime.wrap(function _callee5$(_context5) {\n                                    while(1){\n                                        switch(_context5.prev = _context5.next){\n                                            case 0:\n                                                return _context5.abrupt(\"return\", Object.keys(this.store).length);\n                                            case 1:\n                                            case \"end\":\n                                                return _context5.stop();\n                                        }\n                                    }\n                                }, _callee5, this);\n                            }));\n                            function length() {\n                                return _length.apply(this, arguments);\n                            }\n                            return length;\n                        }()\n                    },\n                    {\n                        key: \"iterate\",\n                        value: function iterate(fn) {\n                            return Promise.all(Object(_utilities__WEBPACK_IMPORTED_MODULE_3__[\"mapObject\"])(this.store, fn));\n                        }\n                    }\n                ]);\n                return MemoryStore;\n            }();\n            /* harmony default export */ __nested_webpack_exports__[\"default\"] = MemoryStore;\n        /***/ },\n        /***/ \"./src/redis-default.js\": /*!******************************!*\\\n  !*** ./src/redis-default.js ***!\n  \\******************************/ /*! exports provided: default */ /***/ function(module1, __nested_webpack_exports__, __nested_webpack_require_256826__) {\n            \"use strict\";\n            __nested_webpack_require_256826__.r(__nested_webpack_exports__);\n            /* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_256826__(/*! core-js/modules/es6.array.iterator */ \"./node_modules/core-js/modules/es6.array.iterator.js\");\n            /* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __nested_webpack_require_256826__.n(core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_0__);\n            /* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_256826__(/*! core-js/modules/es6.object.to-string */ \"./node_modules/core-js/modules/es6.object.to-string.js\");\n            /* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __nested_webpack_require_256826__.n(core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_1__);\n            /* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_256826__(/*! regenerator-runtime/runtime */ \"./node_modules/regenerator-runtime/runtime.js\");\n            /* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/ __nested_webpack_require_256826__.n(regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_2__);\n            /* harmony import */ var core_js_modules_es6_function_bind__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_256826__(/*! core-js/modules/es6.function.bind */ \"./node_modules/core-js/modules/es6.function.bind.js\");\n            /* harmony import */ var core_js_modules_es6_function_bind__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/ __nested_webpack_require_256826__.n(core_js_modules_es6_function_bind__WEBPACK_IMPORTED_MODULE_3__);\n            /* harmony import */ var core_js_modules_es6_function_name__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_256826__(/*! core-js/modules/es6.function.name */ \"./node_modules/core-js/modules/es6.function.name.js\");\n            /* harmony import */ var core_js_modules_es6_function_name__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/ __nested_webpack_require_256826__.n(core_js_modules_es6_function_name__WEBPACK_IMPORTED_MODULE_4__);\n            /* harmony import */ var util__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_256826__(/*! util */ \"util\");\n            /* harmony import */ var util__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/ __nested_webpack_require_256826__.n(util__WEBPACK_IMPORTED_MODULE_5__);\n            function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n                try {\n                    var info = gen[key](arg);\n                    var value = info.value;\n                } catch (error) {\n                    reject(error);\n                    return;\n                }\n                if (info.done) {\n                    resolve(value);\n                } else {\n                    Promise.resolve(value).then(_next, _throw);\n                }\n            }\n            function _asyncToGenerator(fn) {\n                return function() {\n                    var self1 = this, args = arguments;\n                    return new Promise(function(resolve, reject) {\n                        var gen = fn.apply(self1, args);\n                        function _next(value) {\n                            asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n                        }\n                        function _throw(err) {\n                            asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n                        }\n                        _next(undefined);\n                    });\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function _createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) _defineProperties(Constructor, staticProps);\n                return Constructor;\n            }\n            var RedisDefaultStore = /*#__PURE__*/ function() {\n                function RedisDefaultStore(client) {\n                    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                    _classCallCheck(this, RedisDefaultStore);\n                    var invalidClientError = new TypeError(\"First parameter must be a valid RedisClient instance.\");\n                    try {\n                        if (client.constructor.name !== \"RedisClient\") {\n                            throw invalidClientError;\n                        }\n                    } catch (err) {\n                        throw invalidClientError;\n                    }\n                    this.client = client;\n                    this.prefix = options.prefix || \"axios-cache\";\n                    this.maxScanCount = options.maxScanCount || 1000;\n                    this.getAsync = Object(util__WEBPACK_IMPORTED_MODULE_5__[\"promisify\"])(client.get).bind(client);\n                    this.psetexAsync = Object(util__WEBPACK_IMPORTED_MODULE_5__[\"promisify\"])(client.psetex).bind(client);\n                    this.delAsync = Object(util__WEBPACK_IMPORTED_MODULE_5__[\"promisify\"])(client.del).bind(client);\n                    this.scanAsync = Object(util__WEBPACK_IMPORTED_MODULE_5__[\"promisify\"])(client.scan).bind(client);\n                }\n                _createClass(RedisDefaultStore, [\n                    {\n                        key: \"calculateTTL\",\n                        value: function calculateTTL(value) {\n                            var now = Date.now();\n                            if (value.expires && value.expires > now) {\n                                return value.expires - now;\n                            } // If there is no expires in value or the provided expire is before the current time\n                            return -1;\n                        }\n                    },\n                    {\n                        key: \"transformKey\",\n                        value: function transformKey(key) {\n                            return this.prefix + \"_\" + key;\n                        }\n                    },\n                    {\n                        key: \"getItem\",\n                        value: function() {\n                            var _getItem = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee(key) {\n                                var item;\n                                return regeneratorRuntime.wrap(function _callee$(_context) {\n                                    while(1){\n                                        switch(_context.prev = _context.next){\n                                            case 0:\n                                                _context.next = 2;\n                                                return this.getAsync(this.transformKey(key));\n                                            case 2:\n                                                _context.t0 = _context.sent;\n                                                if (_context.t0) {\n                                                    _context.next = 5;\n                                                    break;\n                                                }\n                                                _context.t0 = null;\n                                            case 5:\n                                                item = _context.t0;\n                                                return _context.abrupt(\"return\", JSON.parse(item));\n                                            case 7:\n                                            case \"end\":\n                                                return _context.stop();\n                                        }\n                                    }\n                                }, _callee, this);\n                            }));\n                            function getItem(_x) {\n                                return _getItem.apply(this, arguments);\n                            }\n                            return getItem;\n                        }()\n                    },\n                    {\n                        key: \"setItem\",\n                        value: function() {\n                            var _setItem = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee2(key, value) {\n                                var computedKey, ttl;\n                                return regeneratorRuntime.wrap(function _callee2$(_context2) {\n                                    while(1){\n                                        switch(_context2.prev = _context2.next){\n                                            case 0:\n                                                computedKey = this.transformKey(key);\n                                                ttl = this.calculateTTL(value);\n                                                if (!(ttl > 0)) {\n                                                    _context2.next = 5;\n                                                    break;\n                                                }\n                                                _context2.next = 5;\n                                                return this.psetexAsync(computedKey, ttl, JSON.stringify(value));\n                                            case 5:\n                                                return _context2.abrupt(\"return\", value);\n                                            case 6:\n                                            case \"end\":\n                                                return _context2.stop();\n                                        }\n                                    }\n                                }, _callee2, this);\n                            }));\n                            function setItem(_x2, _x3) {\n                                return _setItem.apply(this, arguments);\n                            }\n                            return setItem;\n                        }()\n                    },\n                    {\n                        key: \"removeItem\",\n                        value: function() {\n                            var _removeItem = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee3(key) {\n                                return regeneratorRuntime.wrap(function _callee3$(_context3) {\n                                    while(1){\n                                        switch(_context3.prev = _context3.next){\n                                            case 0:\n                                                _context3.next = 2;\n                                                return this.delAsync(this.transformKey(key));\n                                            case 2:\n                                            case \"end\":\n                                                return _context3.stop();\n                                        }\n                                    }\n                                }, _callee3, this);\n                            }));\n                            function removeItem(_x4) {\n                                return _removeItem.apply(this, arguments);\n                            }\n                            return removeItem;\n                        }()\n                    },\n                    {\n                        key: \"scan\",\n                        value: function() {\n                            var _scan = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee4(operation) {\n                                var cursor, reply;\n                                return regeneratorRuntime.wrap(function _callee4$(_context4) {\n                                    while(1){\n                                        switch(_context4.prev = _context4.next){\n                                            case 0:\n                                                cursor = \"0\";\n                                            case 1:\n                                                _context4.next = 3;\n                                                return this.scanAsync(cursor, \"MATCH\", this.transformKey(\"*\"), \"COUNT\", this.maxScanCount);\n                                            case 3:\n                                                reply = _context4.sent;\n                                                cursor = reply[0];\n                                                _context4.next = 7;\n                                                return operation(reply[1]);\n                                            case 7:\n                                                if (cursor !== \"0\") {\n                                                    _context4.next = 1;\n                                                    break;\n                                                }\n                                            case 8:\n                                            case \"end\":\n                                                return _context4.stop();\n                                        }\n                                    }\n                                }, _callee4, this);\n                            }));\n                            function scan(_x5) {\n                                return _scan.apply(this, arguments);\n                            }\n                            return scan;\n                        }()\n                    },\n                    {\n                        key: \"clear\",\n                        value: function() {\n                            var _clear = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee5() {\n                                var _this = this;\n                                return regeneratorRuntime.wrap(function _callee5$(_context5) {\n                                    while(1){\n                                        switch(_context5.prev = _context5.next){\n                                            case 0:\n                                                _context5.next = 2;\n                                                return this.scan(function(keys) {\n                                                    return _this.delAsync(keys);\n                                                });\n                                            case 2:\n                                            case \"end\":\n                                                return _context5.stop();\n                                        }\n                                    }\n                                }, _callee5, this);\n                            }));\n                            function clear() {\n                                return _clear.apply(this, arguments);\n                            }\n                            return clear;\n                        }()\n                    },\n                    {\n                        key: \"length\",\n                        value: function() {\n                            var _length = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee6() {\n                                var length;\n                                return regeneratorRuntime.wrap(function _callee6$(_context6) {\n                                    while(1){\n                                        switch(_context6.prev = _context6.next){\n                                            case 0:\n                                                length = 0;\n                                                _context6.next = 3;\n                                                return this.scan(function(keys) {\n                                                    length += keys.length;\n                                                });\n                                            case 3:\n                                                return _context6.abrupt(\"return\", length);\n                                            case 4:\n                                            case \"end\":\n                                                return _context6.stop();\n                                        }\n                                    }\n                                }, _callee6, this);\n                            }));\n                            function length() {\n                                return _length.apply(this, arguments);\n                            }\n                            return length;\n                        }()\n                    },\n                    {\n                        key: \"iterate\",\n                        value: function() {\n                            var _iterate = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee8(fn) {\n                                var _this2 = this;\n                                var runFunction, _runFunction;\n                                return regeneratorRuntime.wrap(function _callee8$(_context8) {\n                                    while(1){\n                                        switch(_context8.prev = _context8.next){\n                                            case 0:\n                                                _runFunction = function _runFunction3() {\n                                                    _runFunction = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee7(key) {\n                                                        var item, value;\n                                                        return regeneratorRuntime.wrap(function _callee7$(_context7) {\n                                                            while(1){\n                                                                switch(_context7.prev = _context7.next){\n                                                                    case 0:\n                                                                        _context7.next = 2;\n                                                                        return this.getAsync(key);\n                                                                    case 2:\n                                                                        _context7.t0 = _context7.sent;\n                                                                        if (_context7.t0) {\n                                                                            _context7.next = 5;\n                                                                            break;\n                                                                        }\n                                                                        _context7.t0 = null;\n                                                                    case 5:\n                                                                        item = _context7.t0;\n                                                                        value = JSON.parse(item);\n                                                                        _context7.next = 9;\n                                                                        return fn(value, key);\n                                                                    case 9:\n                                                                        return _context7.abrupt(\"return\", _context7.sent);\n                                                                    case 10:\n                                                                    case \"end\":\n                                                                        return _context7.stop();\n                                                                }\n                                                            }\n                                                        }, _callee7, this);\n                                                    }));\n                                                    return _runFunction.apply(this, arguments);\n                                                };\n                                                runFunction = function _runFunction2(_x7) {\n                                                    return _runFunction.apply(this, arguments);\n                                                };\n                                                _context8.next = 4;\n                                                return this.scan(function(keys) {\n                                                    return Promise.all(keys.map(runFunction.bind(_this2)));\n                                                });\n                                            case 4:\n                                                return _context8.abrupt(\"return\", Promise.resolve([]));\n                                            case 5:\n                                            case \"end\":\n                                                return _context8.stop();\n                                        }\n                                    }\n                                }, _callee8, this);\n                            }));\n                            function iterate(_x6) {\n                                return _iterate.apply(this, arguments);\n                            }\n                            return iterate;\n                        }()\n                    }\n                ]);\n                return RedisDefaultStore;\n            }();\n            /* harmony default export */ __nested_webpack_exports__[\"default\"] = RedisDefaultStore;\n        /***/ },\n        /***/ \"./src/redis.js\": /*!**********************!*\\\n  !*** ./src/redis.js ***!\n  \\**********************/ /*! exports provided: default */ /***/ function(module1, __nested_webpack_exports__, __nested_webpack_require_279068__) {\n            \"use strict\";\n            __nested_webpack_require_279068__.r(__nested_webpack_exports__);\n            /* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_279068__(/*! core-js/modules/es6.array.iterator */ \"./node_modules/core-js/modules/es6.array.iterator.js\");\n            /* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __nested_webpack_require_279068__.n(core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_0__);\n            /* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_279068__(/*! core-js/modules/es6.object.to-string */ \"./node_modules/core-js/modules/es6.object.to-string.js\");\n            /* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __nested_webpack_require_279068__.n(core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_1__);\n            /* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_279068__(/*! regenerator-runtime/runtime */ \"./node_modules/regenerator-runtime/runtime.js\");\n            /* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/ __nested_webpack_require_279068__.n(regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_2__);\n            /* harmony import */ var core_js_modules_es6_function_bind__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_279068__(/*! core-js/modules/es6.function.bind */ \"./node_modules/core-js/modules/es6.function.bind.js\");\n            /* harmony import */ var core_js_modules_es6_function_bind__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/ __nested_webpack_require_279068__.n(core_js_modules_es6_function_bind__WEBPACK_IMPORTED_MODULE_3__);\n            /* harmony import */ var core_js_modules_es6_function_name__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_279068__(/*! core-js/modules/es6.function.name */ \"./node_modules/core-js/modules/es6.function.name.js\");\n            /* harmony import */ var core_js_modules_es6_function_name__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/ __nested_webpack_require_279068__.n(core_js_modules_es6_function_name__WEBPACK_IMPORTED_MODULE_4__);\n            /* harmony import */ var util__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_279068__(/*! util */ \"util\");\n            /* harmony import */ var util__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/ __nested_webpack_require_279068__.n(util__WEBPACK_IMPORTED_MODULE_5__);\n            /* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_279068__(/*! ./utilities */ \"./src/utilities.js\");\n            function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n                try {\n                    var info = gen[key](arg);\n                    var value = info.value;\n                } catch (error) {\n                    reject(error);\n                    return;\n                }\n                if (info.done) {\n                    resolve(value);\n                } else {\n                    Promise.resolve(value).then(_next, _throw);\n                }\n            }\n            function _asyncToGenerator(fn) {\n                return function() {\n                    var self1 = this, args = arguments;\n                    return new Promise(function(resolve, reject) {\n                        var gen = fn.apply(self1, args);\n                        function _next(value) {\n                            asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n                        }\n                        function _throw(err) {\n                            asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n                        }\n                        _next(undefined);\n                    });\n                };\n            }\n            function _classCallCheck(instance, Constructor) {\n                if (!(instance instanceof Constructor)) {\n                    throw new TypeError(\"Cannot call a class as a function\");\n                }\n            }\n            function _defineProperties(target, props) {\n                for(var i = 0; i < props.length; i++){\n                    var descriptor = props[i];\n                    descriptor.enumerable = descriptor.enumerable || false;\n                    descriptor.configurable = true;\n                    if (\"value\" in descriptor) descriptor.writable = true;\n                    Object.defineProperty(target, descriptor.key, descriptor);\n                }\n            }\n            function _createClass(Constructor, protoProps, staticProps) {\n                if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n                if (staticProps) _defineProperties(Constructor, staticProps);\n                return Constructor;\n            }\n            var RedisStore = /*#__PURE__*/ function() {\n                function RedisStore(client) {\n                    var HASH_KEY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"axios-cache\";\n                    _classCallCheck(this, RedisStore);\n                    var invalidClientError = new TypeError(\"First parameter must be a valid RedisClient instance.\");\n                    try {\n                        if (client.constructor.name !== \"RedisClient\") {\n                            throw invalidClientError;\n                        }\n                    } catch (err) {\n                        throw invalidClientError;\n                    }\n                    this.client = client;\n                    this.HASH_KEY = HASH_KEY;\n                    this.hgetAsync = Object(util__WEBPACK_IMPORTED_MODULE_5__[\"promisify\"])(client.hget).bind(client);\n                    this.hsetAsync = Object(util__WEBPACK_IMPORTED_MODULE_5__[\"promisify\"])(client.hset).bind(client);\n                    this.hdelAsync = Object(util__WEBPACK_IMPORTED_MODULE_5__[\"promisify\"])(client.hdel).bind(client);\n                    this.delAsync = Object(util__WEBPACK_IMPORTED_MODULE_5__[\"promisify\"])(client.del).bind(client);\n                    this.hlenAsync = Object(util__WEBPACK_IMPORTED_MODULE_5__[\"promisify\"])(client.hlen).bind(client);\n                    this.hgetallAsync = Object(util__WEBPACK_IMPORTED_MODULE_5__[\"promisify\"])(client.hgetall).bind(client);\n                }\n                _createClass(RedisStore, [\n                    {\n                        key: \"getItem\",\n                        value: function() {\n                            var _getItem = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee(key) {\n                                var item;\n                                return regeneratorRuntime.wrap(function _callee$(_context) {\n                                    while(1){\n                                        switch(_context.prev = _context.next){\n                                            case 0:\n                                                _context.next = 2;\n                                                return this.hgetAsync(this.HASH_KEY, key);\n                                            case 2:\n                                                _context.t0 = _context.sent;\n                                                if (_context.t0) {\n                                                    _context.next = 5;\n                                                    break;\n                                                }\n                                                _context.t0 = null;\n                                            case 5:\n                                                item = _context.t0;\n                                                return _context.abrupt(\"return\", JSON.parse(item));\n                                            case 7:\n                                            case \"end\":\n                                                return _context.stop();\n                                        }\n                                    }\n                                }, _callee, this);\n                            }));\n                            function getItem(_x) {\n                                return _getItem.apply(this, arguments);\n                            }\n                            return getItem;\n                        }()\n                    },\n                    {\n                        key: \"setItem\",\n                        value: function() {\n                            var _setItem = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee2(key, value) {\n                                return regeneratorRuntime.wrap(function _callee2$(_context2) {\n                                    while(1){\n                                        switch(_context2.prev = _context2.next){\n                                            case 0:\n                                                _context2.next = 2;\n                                                return this.hsetAsync(this.HASH_KEY, key, JSON.stringify(value));\n                                            case 2:\n                                                return _context2.abrupt(\"return\", value);\n                                            case 3:\n                                            case \"end\":\n                                                return _context2.stop();\n                                        }\n                                    }\n                                }, _callee2, this);\n                            }));\n                            function setItem(_x2, _x3) {\n                                return _setItem.apply(this, arguments);\n                            }\n                            return setItem;\n                        }()\n                    },\n                    {\n                        key: \"removeItem\",\n                        value: function() {\n                            var _removeItem = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee3(key) {\n                                return regeneratorRuntime.wrap(function _callee3$(_context3) {\n                                    while(1){\n                                        switch(_context3.prev = _context3.next){\n                                            case 0:\n                                                _context3.next = 2;\n                                                return this.hdelAsync(this.HASH_KEY, key);\n                                            case 2:\n                                            case \"end\":\n                                                return _context3.stop();\n                                        }\n                                    }\n                                }, _callee3, this);\n                            }));\n                            function removeItem(_x4) {\n                                return _removeItem.apply(this, arguments);\n                            }\n                            return removeItem;\n                        }()\n                    },\n                    {\n                        key: \"clear\",\n                        value: function() {\n                            var _clear = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee4() {\n                                return regeneratorRuntime.wrap(function _callee4$(_context4) {\n                                    while(1){\n                                        switch(_context4.prev = _context4.next){\n                                            case 0:\n                                                _context4.next = 2;\n                                                return this.delAsync(this.HASH_KEY);\n                                            case 2:\n                                            case \"end\":\n                                                return _context4.stop();\n                                        }\n                                    }\n                                }, _callee4, this);\n                            }));\n                            function clear() {\n                                return _clear.apply(this, arguments);\n                            }\n                            return clear;\n                        }()\n                    },\n                    {\n                        key: \"length\",\n                        value: function() {\n                            var _length = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee5() {\n                                return regeneratorRuntime.wrap(function _callee5$(_context5) {\n                                    while(1){\n                                        switch(_context5.prev = _context5.next){\n                                            case 0:\n                                                return _context5.abrupt(\"return\", this.hlenAsync(this.HASH_KEY));\n                                            case 1:\n                                            case \"end\":\n                                                return _context5.stop();\n                                        }\n                                    }\n                                }, _callee5, this);\n                            }));\n                            function length() {\n                                return _length.apply(this, arguments);\n                            }\n                            return length;\n                        }()\n                    },\n                    {\n                        key: \"iterate\",\n                        value: function() {\n                            var _iterate = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee6(fn) {\n                                var hashData;\n                                return regeneratorRuntime.wrap(function _callee6$(_context6) {\n                                    while(1){\n                                        switch(_context6.prev = _context6.next){\n                                            case 0:\n                                                _context6.next = 2;\n                                                return this.hgetallAsync(this.HASH_KEY);\n                                            case 2:\n                                                hashData = _context6.sent;\n                                                return _context6.abrupt(\"return\", Promise.all(Object(_utilities__WEBPACK_IMPORTED_MODULE_6__[\"mapObject\"])(hashData, fn)));\n                                            case 4:\n                                            case \"end\":\n                                                return _context6.stop();\n                                        }\n                                    }\n                                }, _callee6, this);\n                            }));\n                            function iterate(_x5) {\n                                return _iterate.apply(this, arguments);\n                            }\n                            return iterate;\n                        }()\n                    }\n                ]);\n                return RedisStore;\n            }();\n            /* harmony default export */ __nested_webpack_exports__[\"default\"] = RedisStore;\n        /***/ },\n        /***/ \"./src/request.js\": /*!************************!*\\\n  !*** ./src/request.js ***!\n  \\************************/ /*! exports provided: default */ /***/ function(module1, __nested_webpack_exports__, __nested_webpack_require_294545__) {\n            \"use strict\";\n            __nested_webpack_require_294545__.r(__nested_webpack_exports__);\n            /* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_294545__(/*! regenerator-runtime/runtime */ \"./node_modules/regenerator-runtime/runtime.js\");\n            /* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __nested_webpack_require_294545__.n(regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0__);\n            /* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_294545__(/*! core-js/modules/es6.object.to-string */ \"./node_modules/core-js/modules/es6.object.to-string.js\");\n            /* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __nested_webpack_require_294545__.n(core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_1__);\n            /* harmony import */ var _response__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_294545__(/*! ./response */ \"./src/response.js\");\n            /* harmony import */ var _exclude__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_294545__(/*! ./exclude */ \"./src/exclude.js\");\n            /* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_294545__(/*! ./cache */ \"./src/cache.js\");\n            function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n                try {\n                    var info = gen[key](arg);\n                    var value = info.value;\n                } catch (error) {\n                    reject(error);\n                    return;\n                }\n                if (info.done) {\n                    resolve(value);\n                } else {\n                    Promise.resolve(value).then(_next, _throw);\n                }\n            }\n            function _asyncToGenerator(fn) {\n                return function() {\n                    var self1 = this, args = arguments;\n                    return new Promise(function(resolve, reject) {\n                        var gen = fn.apply(self1, args);\n                        function _next(value) {\n                            asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n                        }\n                        function _throw(err) {\n                            asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n                        }\n                        _next(undefined);\n                    });\n                };\n            }\n            function request(_x, _x2) {\n                return _request.apply(this, arguments);\n            }\n            function _request() {\n                _request = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee(config, req) {\n                    var next, res, excludeFromCache;\n                    return regeneratorRuntime.wrap(function _callee$(_context) {\n                        while(1){\n                            switch(_context.prev = _context.next){\n                                case 0:\n                                    excludeFromCache = function _excludeFromCache() {\n                                        config.excludeFromCache = true;\n                                        return {\n                                            config: config,\n                                            next: next\n                                        };\n                                    };\n                                    config.debug(\"uuid\", config.uuid);\n                                    next = function next() {\n                                        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                                            args[_key] = arguments[_key];\n                                        }\n                                        return _response__WEBPACK_IMPORTED_MODULE_2__[\"default\"].apply(void 0, [\n                                            config,\n                                            req\n                                        ].concat(args));\n                                    }; // run invalidate function to check if any cache items need to be invalidated.\n                                    _context.next = 5;\n                                    return config.invalidate(config, req);\n                                case 5:\n                                    if (!Object(_exclude__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(config, req)) {\n                                        _context.next = 7;\n                                        break;\n                                    }\n                                    return _context.abrupt(\"return\", excludeFromCache());\n                                case 7:\n                                    _context.prev = 7;\n                                    _context.next = 10;\n                                    return Object(_cache__WEBPACK_IMPORTED_MODULE_4__[\"read\"])(config, req);\n                                case 10:\n                                    res = _context.sent;\n                                    res.config = req;\n                                    res.request = {\n                                        fromCache: true\n                                    };\n                                    return _context.abrupt(\"return\", {\n                                        config: config,\n                                        next: res\n                                    });\n                                case 16:\n                                    _context.prev = 16;\n                                    _context.t0 = _context[\"catch\"](7);\n                                    if (!(config.clearOnStale && _context.t0.reason === \"cache-stale\")) {\n                                        _context.next = 21;\n                                        break;\n                                    }\n                                    _context.next = 21;\n                                    return config.store.removeItem(config.uuid);\n                                case 21:\n                                    return _context.abrupt(\"return\", {\n                                        config: config,\n                                        next: next\n                                    });\n                                case 22:\n                                case \"end\":\n                                    return _context.stop();\n                            }\n                        }\n                    }, _callee, null, [\n                        [\n                            7,\n                            16\n                        ]\n                    ]);\n                }));\n                return _request.apply(this, arguments);\n            }\n            /* harmony default export */ __nested_webpack_exports__[\"default\"] = request;\n        /***/ },\n        /***/ \"./src/response.js\": /*!*************************!*\\\n  !*** ./src/response.js ***!\n  \\*************************/ /*! exports provided: default */ /***/ function(module1, __nested_webpack_exports__, __nested_webpack_require_301697__) {\n            \"use strict\";\n            __nested_webpack_require_301697__.r(__nested_webpack_exports__);\n            /* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_301697__(/*! regenerator-runtime/runtime */ \"./node_modules/regenerator-runtime/runtime.js\");\n            /* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __nested_webpack_require_301697__.n(regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0__);\n            /* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_301697__(/*! core-js/modules/es6.object.to-string */ \"./node_modules/core-js/modules/es6.object.to-string.js\");\n            /* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __nested_webpack_require_301697__.n(core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_1__);\n            /* harmony import */ var _limit__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_301697__(/*! ./limit */ \"./src/limit.js\");\n            /* harmony import */ var _cache__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_301697__(/*! ./cache */ \"./src/cache.js\");\n            /* harmony import */ var cache_control_esm__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_301697__(/*! cache-control-esm */ \"./node_modules/cache-control-esm/index.js\");\n            function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n                try {\n                    var info = gen[key](arg);\n                    var value = info.value;\n                } catch (error) {\n                    reject(error);\n                    return;\n                }\n                if (info.done) {\n                    resolve(value);\n                } else {\n                    Promise.resolve(value).then(_next, _throw);\n                }\n            }\n            function _asyncToGenerator(fn) {\n                return function() {\n                    var self1 = this, args = arguments;\n                    return new Promise(function(resolve, reject) {\n                        var gen = fn.apply(self1, args);\n                        function _next(value) {\n                            asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n                        }\n                        function _throw(err) {\n                            asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n                        }\n                        _next(undefined);\n                    });\n                };\n            }\n            function response(_x, _x2, _x3) {\n                return _response.apply(this, arguments);\n            }\n            function _response() {\n                _response = _asyncToGenerator(/*#__PURE__*/ regeneratorRuntime.mark(function _callee(config, req, res) {\n                    var _res$request, request, _res$headers, headers, cacheControl;\n                    return regeneratorRuntime.wrap(function _callee$(_context) {\n                        while(1){\n                            switch(_context.prev = _context.next){\n                                case 0:\n                                    _res$request = res.request, request = _res$request === void 0 ? {} : _res$request, _res$headers = res.headers, headers = _res$headers === void 0 ? {} : _res$headers; // exclude binary response from cache\n                                    if (!([\n                                        \"arraybuffer\",\n                                        \"blob\"\n                                    ].indexOf(request.responseType) > -1)) {\n                                        _context.next = 3;\n                                        break;\n                                    }\n                                    return _context.abrupt(\"return\", res);\n                                case 3:\n                                    cacheControl = {}; // Should we try to determine request cache expiration from headers or not\n                                    if (config.readHeaders) {\n                                        if (headers[\"cache-control\"]) {\n                                            // Try parsing `cache-control` header from response\n                                            cacheControl = Object(cache_control_esm__WEBPACK_IMPORTED_MODULE_4__[\"parse\"])(headers[\"cache-control\"]); // Force cache exlcusion for `cache-control: no-cache` and `cache-control: no-store`\n                                            if (cacheControl.noCache || cacheControl.noStore) {\n                                                config.excludeFromCache = true;\n                                            }\n                                        } else if (headers.expires) {\n                                            // Else try reading `expires` header\n                                            config.expires = new Date(headers.expires).getTime();\n                                        } else {\n                                            config.expires = new Date().getTime();\n                                        }\n                                    }\n                                    if (config.excludeFromCache) {\n                                        _context.next = 15;\n                                        break;\n                                    }\n                                    if (cacheControl.maxAge || cacheControl.maxAge === 0) {\n                                        // Use `cache-control` header `max-age` value and convert to milliseconds\n                                        config.expires = Date.now() + cacheControl.maxAge * 1000;\n                                    } else if (!config.readHeaders) {\n                                        // Use fixed `maxAge` defined in the global or per-request config\n                                        config.expires = config.maxAge === 0 ? Date.now() : Date.now() + config.maxAge;\n                                    } // Check if a cache limit has been configured\n                                    if (!config.limit) {\n                                        _context.next = 11;\n                                        break;\n                                    }\n                                    config.debug(\"Detected limit: \".concat(config.limit));\n                                    _context.next = 11;\n                                    return Object(_limit__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(config);\n                                case 11:\n                                    _context.next = 13;\n                                    return Object(_cache__WEBPACK_IMPORTED_MODULE_3__[\"write\"])(config, req, res);\n                                case 13:\n                                    _context.next = 16;\n                                    break;\n                                case 15:\n                                    // Mark request as excluded from cache\n                                    res.request.excludedFromCache = true;\n                                case 16:\n                                    return _context.abrupt(\"return\", res);\n                                case 17:\n                                case \"end\":\n                                    return _context.stop();\n                            }\n                        }\n                    }, _callee);\n                }));\n                return _response.apply(this, arguments);\n            }\n            /* harmony default export */ __nested_webpack_exports__[\"default\"] = response;\n        /***/ },\n        /***/ \"./src/serialize.js\": /*!**************************!*\\\n  !*** ./src/serialize.js ***!\n  \\**************************/ /*! exports provided: default */ /***/ function(module1, __nested_webpack_exports__, __nested_webpack_require_309519__) {\n            \"use strict\";\n            __nested_webpack_require_309519__.r(__nested_webpack_exports__);\n            /* harmony import */ var core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_309519__(/*! core-js/modules/es6.symbol */ \"./node_modules/core-js/modules/es6.symbol.js\");\n            /* harmony import */ var core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __nested_webpack_require_309519__.n(core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_0__);\n            /* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_309519__(/*! core-js/modules/es6.array.iterator */ \"./node_modules/core-js/modules/es6.array.iterator.js\");\n            /* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __nested_webpack_require_309519__.n(core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_1__);\n            /* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_309519__(/*! core-js/modules/es6.object.to-string */ \"./node_modules/core-js/modules/es6.object.to-string.js\");\n            /* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/ __nested_webpack_require_309519__.n(core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_2__);\n            function _objectWithoutProperties(source, excluded) {\n                if (source == null) return {};\n                var target = _objectWithoutPropertiesLoose(source, excluded);\n                var key, i;\n                if (Object.getOwnPropertySymbols) {\n                    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n                    for(i = 0; i < sourceSymbolKeys.length; i++){\n                        key = sourceSymbolKeys[i];\n                        if (excluded.indexOf(key) >= 0) continue;\n                        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n                        target[key] = source[key];\n                    }\n                }\n                return target;\n            }\n            function _objectWithoutPropertiesLoose(source, excluded) {\n                if (source == null) return {};\n                var target = {};\n                var sourceKeys = Object.keys(source);\n                var key, i;\n                for(i = 0; i < sourceKeys.length; i++){\n                    key = sourceKeys[i];\n                    if (excluded.indexOf(key) >= 0) continue;\n                    target[key] = source[key];\n                }\n                return target;\n            }\n            function serialize(config, req, res) {\n                if (res.data) {\n                    // FIXME: May be useless as localForage and axios already parse automatically\n                    try {\n                        res.data = JSON.parse(res.data);\n                    } catch (err) {\n                        config.debug(\"Could not parse data as JSON\", err);\n                    }\n                }\n                var request = res.request, _ = res.config, serialized = _objectWithoutProperties(res, [\n                    \"request\",\n                    \"config\"\n                ]);\n                return serialized;\n            }\n            /* harmony default export */ __nested_webpack_exports__[\"default\"] = serialize;\n        /***/ },\n        /***/ \"./src/utilities.js\": /*!**************************!*\\\n  !*** ./src/utilities.js ***!\n  \\**************************/ /*! exports provided: isObject, getTag, isFunction, isString, mapObject */ /***/ function(module1, __nested_webpack_exports__, __nested_webpack_require_313169__) {\n            \"use strict\";\n            __nested_webpack_require_313169__.r(__nested_webpack_exports__);\n            /* harmony export (binding) */ __nested_webpack_require_313169__.d(__nested_webpack_exports__, \"isObject\", function() {\n                return isObject;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_313169__.d(__nested_webpack_exports__, \"getTag\", function() {\n                return getTag;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_313169__.d(__nested_webpack_exports__, \"isFunction\", function() {\n                return isFunction;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_313169__.d(__nested_webpack_exports__, \"isString\", function() {\n                return isString;\n            });\n            /* harmony export (binding) */ __nested_webpack_require_313169__.d(__nested_webpack_exports__, \"mapObject\", function() {\n                return mapObject;\n            });\n            /* harmony import */ var core_js_modules_es7_symbol_async_iterator__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_313169__(/*! core-js/modules/es7.symbol.async-iterator */ \"./node_modules/core-js/modules/es7.symbol.async-iterator.js\");\n            /* harmony import */ var core_js_modules_es7_symbol_async_iterator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/ __nested_webpack_require_313169__.n(core_js_modules_es7_symbol_async_iterator__WEBPACK_IMPORTED_MODULE_0__);\n            /* harmony import */ var core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_313169__(/*! core-js/modules/es6.symbol */ \"./node_modules/core-js/modules/es6.symbol.js\");\n            /* harmony import */ var core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/ __nested_webpack_require_313169__.n(core_js_modules_es6_symbol__WEBPACK_IMPORTED_MODULE_1__);\n            /* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_313169__(/*! core-js/modules/es6.array.iterator */ \"./node_modules/core-js/modules/es6.array.iterator.js\");\n            /* harmony import */ var core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/ __nested_webpack_require_313169__.n(core_js_modules_es6_array_iterator__WEBPACK_IMPORTED_MODULE_2__);\n            /* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_313169__(/*! core-js/modules/es6.object.to-string */ \"./node_modules/core-js/modules/es6.object.to-string.js\");\n            /* harmony import */ var core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/ __nested_webpack_require_313169__.n(core_js_modules_es6_object_to_string__WEBPACK_IMPORTED_MODULE_3__);\n            function _typeof(obj) {\n                \"@babel/helpers - typeof\";\n                if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n                    _typeof = function _typeof(obj) {\n                        return typeof obj;\n                    };\n                } else {\n                    _typeof = function _typeof(obj) {\n                        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n                    };\n                }\n                return _typeof(obj);\n            }\n            // https://github.com/lodash/lodash/blob/master/isObject.js\n            function isObject(value) {\n                var type = _typeof(value);\n                return value != null && (type === \"object\" || type === \"function\");\n            } // https://github.com/lodash/lodash/blob/master/.internal/getTag.js\n            function getTag(value) {\n                if (value === null) {\n                    return value === undefined ? \"[object Undefined]\" : \"[object Null]\";\n                }\n                return Object.prototype.toString.call(value);\n            } // https://github.com/lodash/lodash/blob/master/isFunction.js\n            function isFunction(value) {\n                if (!isObject(value)) {\n                    return false;\n                }\n                var tag = getTag(value);\n                return tag === \"[object Function]\" || tag === \"[object AsyncFunction]\" || tag === \"[object GeneratorFunction]\" || tag === \"[object Proxy]\";\n            } // https://github.com/lodash/lodash/blob/master/isString.js\n            function isString(value) {\n                var type = _typeof(value);\n                return type === \"string\" || type === \"object\" && value != null && !Array.isArray(value) && getTag(value) === \"[object String]\";\n            }\n            function mapObject(value, fn) {\n                if (!isObject(value)) {\n                    return [];\n                }\n                return Object.keys(value).map(function(key) {\n                    return fn(value[key], key);\n                });\n            }\n        /***/ },\n        /***/ \"axios\": /*!*************************************************************************************!*\\\n  !*** external {\"umd\":\"axios\",\"amd\":\"axios\",\"commonjs\":\"axios\",\"commonjs2\":\"axios\"} ***!\n  \\*************************************************************************************/ /*! no static exports found */ /***/ function(module1, exports1) {\n            module1.exports = __WEBPACK_EXTERNAL_MODULE_axios__;\n        /***/ },\n        /***/ \"util\": /*!***********************!*\\\n  !*** external \"util\" ***!\n  \\***********************/ /*! no static exports found */ /***/ function(module1, exports1) {\n            module1.exports = __webpack_require__(/*! util */ \"util\");\n        /***/ }\n    });\n}); //# sourceMappingURL=cache.node.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXhpb3MtY2FjaGUtYWRhcHRlci9kaXN0L2NhY2hlLm5vZGUuanMiLCJtYXBwaW5ncyI6IjtBQUFDLFVBQVNBLGlDQUFpQ0MsSUFBSSxFQUFFQyxPQUFPO0lBQ3ZELElBQUcsSUFBaUQsRUFDbkRFLE9BQU9ELE9BQU8sR0FBR0QsUUFBUUcsbUJBQU9BLENBQUMsNkRBQU87U0FDcEMsRUFLaUQ7QUFDdkQsR0FBR0ksUUFBUSxTQUFTQyxpQ0FBaUM7SUFDckQsT0FBZ0IsTUFBSCxHQUFJLFNBQVNDLE9BQU87UUFDakMsTUFBTSxHQUFJLG1CQUFtQjtRQUM3QixNQUFNLEdBQUksSUFBSUMsbUJBQW1CLENBQUM7UUFDbEMsTUFBTSxHQUNOLE1BQU0sR0FBSSx1QkFBdUI7UUFDakMsTUFBTSxHQUFJLFNBQVNDLDhCQUFtQkEsQ0FBQ0MsUUFBUTtZQUMvQyxNQUFNLEdBQ04sTUFBTSxHQUFLLDhCQUE4QjtZQUN6QyxNQUFNLEdBQUssSUFBR0YsZ0JBQWdCLENBQUNFLFNBQVMsRUFBRTtnQkFDMUMsTUFBTSxHQUFNLE9BQU9GLGdCQUFnQixDQUFDRSxTQUFTLENBQUNYLE9BQU87WUFDckQsTUFBTSxHQUFLO1lBQ1gsTUFBTSxHQUFLLGtEQUFrRDtZQUM3RCxNQUFNLEdBQUssSUFBSUMsVUFBU1EsZ0JBQWdCLENBQUNFLFNBQVMsR0FBRztnQkFDckQsTUFBTSxHQUFNQyxHQUFHRDtnQkFDZixNQUFNLEdBQU1FLEdBQUc7Z0JBQ2YsTUFBTSxHQUFNYixTQUFTLENBQUM7WUFDWDtZQUNYLE1BQU0sR0FDTixNQUFNLEdBQUssOEJBQThCO1lBQ3pDLE1BQU0sR0FBS1EsT0FBTyxDQUFDRyxTQUFTLENBQUNHLElBQUksQ0FBQ2IsUUFBT0QsT0FBTyxFQUFFQyxTQUFRQSxRQUFPRCxPQUFPLEVBQUVVLDhCQUFtQkE7WUFDN0YsTUFBTSxHQUNOLE1BQU0sR0FBSyw0QkFBNEI7WUFDdkMsTUFBTSxHQUFLVCxRQUFPWSxDQUFDLEdBQUc7WUFDdEIs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MkIsR0FBRyxDQUFDLFNBQVV2MkIsR0FBRztvQkFDekMsT0FBT2lKLEdBQUd2SixLQUFLLENBQUNNLElBQUksRUFBRUE7Z0JBQ3hCO1lBQ0Y7UUFFQSxHQUFHLEdBQUc7UUFFTixHQUFHLEdBQUcsU0FDTjs7dUZBRXVGLEdBQ3ZGLDRCQUE0QixHQUM1QixHQUFHLEdBQUksU0FBU2pDLE9BQU0sRUFBRUQsUUFBTztZQUUvQkMsUUFBT0QsT0FBTyxHQUFHTztRQUVqQixHQUFHLEdBQUc7UUFFTixHQUFHLEdBQUcsUUFDTjs7eUJBRXlCLEdBQ3pCLDRCQUE0QixHQUM1QixHQUFHLEdBQUksU0FBU04sT0FBTSxFQUFFRCxRQUFPO1lBRS9CQyxRQUFPRCxPQUFPLEdBQUdFLG1CQUFPQSxDQUFDLGtCQUFNO1FBRS9CLEdBQUcsR0FBRztJQUVHO0FBQ1QsSUFDQSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS1jbGFzc3Jvb20vLi9ub2RlX21vZHVsZXMvYXhpb3MtY2FjaGUtYWRhcHRlci9kaXN0L2NhY2hlLm5vZGUuanM/NDVjZSJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJheGlvc1wiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJheGlvc1wiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJheGlvc0NhY2hlQWRhcHRlclwiXSA9IGZhY3RvcnkocmVxdWlyZShcImF4aW9zXCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJheGlvc0NhY2hlQWRhcHRlclwiXSA9IGZhY3Rvcnkocm9vdFt1bmRlZmluZWRdKTtcbn0pKGdsb2JhbCwgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9heGlvc19fKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbi8qKioqKiovIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4vKioqKioqLyBcdFx0cmV0dXJuIG5zO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL2luZGV4Lm5vZGUuanNcIik7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovICh7XG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY2FjaGUtY29udHJvbC1lc20vaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY2FjaGUtY29udHJvbC1lc20vaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogQ2FjaGVDb250cm9sLCBwYXJzZSwgZm9ybWF0LCBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkNhY2hlQ29udHJvbFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIENhY2hlQ29udHJvbDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwicGFyc2VcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBwYXJzZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZm9ybWF0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZm9ybWF0OyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X2FycmF5X2Zyb21fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZnJvbSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuZnJvbS5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X2FycmF5X2Zyb21fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXM2X2FycmF5X2Zyb21fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzNl9mdW5jdGlvbl9uYW1lX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLm5hbWUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLm5hbWUuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzNl9mdW5jdGlvbl9uYW1lX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzNl9mdW5jdGlvbl9uYW1lX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfb2JqZWN0X3RvX3N0cmluZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfb2JqZWN0X3RvX3N0cmluZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lczZfb2JqZWN0X3RvX3N0cmluZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfd2ViX2RvbV9pdGVyYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfd2ViX2RvbV9pdGVyYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc193ZWJfZG9tX2l0ZXJhYmxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczdfc3ltYm9sX2FzeW5jX2l0ZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvciAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczdfc3ltYm9sX2FzeW5jX2l0ZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzN19zeW1ib2xfYXN5bmNfaXRlcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzNl9zeW1ib2xfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lczYuc3ltYm9sICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zeW1ib2wuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzNl9zeW1ib2xfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXM2X3N5bWJvbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X3JlZ2V4cF9zcGxpdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuc3BsaXQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnJlZ2V4cC5zcGxpdC5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X3JlZ2V4cF9zcGxpdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lczZfcmVnZXhwX3NwbGl0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfbnVtYmVyX2lzX2Zpbml0ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtZmluaXRlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtZmluaXRlLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfbnVtYmVyX2lzX2Zpbml0ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lczZfbnVtYmVyX2lzX2Zpbml0ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fKTtcblxuXG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8ICEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSkgcmV0dXJuOyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxudmFyIEhFQURFUl9SRUdFWFAgPSAvKFthLXpBLVpdW2EtekEtWl8tXSopXFxzKig/Oj0oPzpcIihbXlwiXSopXCJ8KFteIFxcdFwiLDtdKikpKT8vZztcbnZhciBTVFJJTkdTID0ge1xuICBtYXhBZ2U6ICdtYXgtYWdlJyxcbiAgc2hhcmVkTWF4QWdlOiAncy1tYXhhZ2UnLFxuICBtYXhTdGFsZTogJ21heC1zdGFsZScsXG4gIG1pbkZyZXNoOiAnbWluLWZyZXNoJyxcbiAgaW1tdXRhYmxlOiAnaW1tdXRhYmxlJyxcbiAgbXVzdFJldmFsaWRhdGU6ICdtdXN0LXJldmFsaWRhdGUnLFxuICBub0NhY2hlOiAnbm8tY2FjaGUnLFxuICBub1N0b3JlOiAnbm8tc3RvcmUnLFxuICBub1RyYW5zZm9ybTogJ25vLXRyYW5zZm9ybScsXG4gIG9ubHlJZkNhY2hlZDogJ29ubHktaWYtY2FjaGVkJyxcbiAgXCJwcml2YXRlXCI6ICdwcml2YXRlJyxcbiAgcHJveHlSZXZhbGlkYXRlOiAncHJveHktcmV2YWxpZGF0ZScsXG4gIFwicHVibGljXCI6ICdwdWJsaWMnXG59O1xuXG5mdW5jdGlvbiBwYXJzZUJvb2xlYW5Pbmx5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcGFyc2VEdXJhdGlvbih2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZHVyYXRpb24gPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuXG4gIGlmICghTnVtYmVyLmlzRmluaXRlKGR1cmF0aW9uKSB8fCBkdXJhdGlvbiA8IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBkdXJhdGlvbjtcbn1cblxudmFyIENhY2hlQ29udHJvbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENhY2hlQ29udHJvbCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FjaGVDb250cm9sKTtcblxuICAgIHRoaXMubWF4QWdlID0gbnVsbDtcbiAgICB0aGlzLnNoYXJlZE1heEFnZSA9IG51bGw7XG4gICAgdGhpcy5tYXhTdGFsZSA9IG51bGw7XG4gICAgdGhpcy5tYXhTdGFsZUR1cmF0aW9uID0gbnVsbDtcbiAgICB0aGlzLm1pbkZyZXNoID0gbnVsbDtcbiAgICB0aGlzLmltbXV0YWJsZSA9IG51bGw7XG4gICAgdGhpcy5tdXN0UmV2YWxpZGF0ZSA9IG51bGw7XG4gICAgdGhpcy5ub0NhY2hlID0gbnVsbDtcbiAgICB0aGlzLm5vU3RvcmUgPSBudWxsO1xuICAgIHRoaXMubm9UcmFuc2Zvcm0gPSBudWxsO1xuICAgIHRoaXMub25seUlmQ2FjaGVkID0gbnVsbDtcbiAgICB0aGlzW1wicHJpdmF0ZVwiXSA9IG51bGw7XG4gICAgdGhpcy5wcm94eVJldmFsaWRhdGUgPSBudWxsO1xuICAgIHRoaXNbXCJwdWJsaWNcIl0gPSBudWxsO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENhY2hlQ29udHJvbCwgW3tcbiAgICBrZXk6IFwicGFyc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2UoaGVhZGVyKSB7XG4gICAgICBpZiAoIWhlYWRlciB8fCBoZWFkZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWVzID0ge307XG4gICAgICB2YXIgbWF0Y2hlcyA9IGhlYWRlci5tYXRjaChIRUFERVJfUkVHRVhQKSB8fCBbXTtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwobWF0Y2hlcywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgIHZhciB0b2tlbnMgPSBtYXRjaC5zcGxpdCgnPScsIDIpO1xuXG4gICAgICAgIHZhciBfdG9rZW5zID0gX3NsaWNlZFRvQXJyYXkodG9rZW5zLCAxKSxcbiAgICAgICAgICAgIGtleSA9IF90b2tlbnNbMF07XG5cbiAgICAgICAgdmFyIHZhbHVlID0gbnVsbDtcblxuICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB2YWx1ZSA9IHRva2Vuc1sxXS50cmltKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZXNba2V5LnRvTG93ZXJDYXNlKCldID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICAgIHRoaXMubWF4QWdlID0gcGFyc2VEdXJhdGlvbih2YWx1ZXNbU1RSSU5HUy5tYXhBZ2VdKTtcbiAgICAgIHRoaXMuc2hhcmVkTWF4QWdlID0gcGFyc2VEdXJhdGlvbih2YWx1ZXNbU1RSSU5HUy5zaGFyZWRNYXhBZ2VdKTtcbiAgICAgIHRoaXMubWF4U3RhbGUgPSBwYXJzZUJvb2xlYW5Pbmx5KHZhbHVlc1tTVFJJTkdTLm1heFN0YWxlXSk7XG4gICAgICB0aGlzLm1heFN0YWxlRHVyYXRpb24gPSBwYXJzZUR1cmF0aW9uKHZhbHVlc1tTVFJJTkdTLm1heFN0YWxlXSk7XG5cbiAgICAgIGlmICh0aGlzLm1heFN0YWxlRHVyYXRpb24pIHtcbiAgICAgICAgdGhpcy5tYXhTdGFsZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubWluRnJlc2ggPSBwYXJzZUR1cmF0aW9uKHZhbHVlc1tTVFJJTkdTLm1pbkZyZXNoXSk7XG4gICAgICB0aGlzLmltbXV0YWJsZSA9IHBhcnNlQm9vbGVhbk9ubHkodmFsdWVzW1NUUklOR1MuaW1tdXRhYmxlXSk7XG4gICAgICB0aGlzLm11c3RSZXZhbGlkYXRlID0gcGFyc2VCb29sZWFuT25seSh2YWx1ZXNbU1RSSU5HUy5tdXN0UmV2YWxpZGF0ZV0pO1xuICAgICAgdGhpcy5ub0NhY2hlID0gcGFyc2VCb29sZWFuT25seSh2YWx1ZXNbU1RSSU5HUy5ub0NhY2hlXSk7XG4gICAgICB0aGlzLm5vU3RvcmUgPSBwYXJzZUJvb2xlYW5Pbmx5KHZhbHVlc1tTVFJJTkdTLm5vU3RvcmVdKTtcbiAgICAgIHRoaXMubm9UcmFuc2Zvcm0gPSBwYXJzZUJvb2xlYW5Pbmx5KHZhbHVlc1tTVFJJTkdTLm5vVHJhbnNmb3JtXSk7XG4gICAgICB0aGlzLm9ubHlJZkNhY2hlZCA9IHBhcnNlQm9vbGVhbk9ubHkodmFsdWVzW1NUUklOR1Mub25seUlmQ2FjaGVkXSk7XG4gICAgICB0aGlzW1wicHJpdmF0ZVwiXSA9IHBhcnNlQm9vbGVhbk9ubHkodmFsdWVzW1NUUklOR1NbXCJwcml2YXRlXCJdXSk7XG4gICAgICB0aGlzLnByb3h5UmV2YWxpZGF0ZSA9IHBhcnNlQm9vbGVhbk9ubHkodmFsdWVzW1NUUklOR1MucHJveHlSZXZhbGlkYXRlXSk7XG4gICAgICB0aGlzW1wicHVibGljXCJdID0gcGFyc2VCb29sZWFuT25seSh2YWx1ZXNbU1RSSU5HU1tcInB1YmxpY1wiXV0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvcm1hdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXQoKSB7XG4gICAgICB2YXIgdG9rZW5zID0gW107XG5cbiAgICAgIGlmICh0aGlzLm1heEFnZSkge1xuICAgICAgICB0b2tlbnMucHVzaChcIlwiLmNvbmNhdChTVFJJTkdTLm1heEFnZSwgXCI9XCIpLmNvbmNhdCh0aGlzLm1heEFnZSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zaGFyZWRNYXhBZ2UpIHtcbiAgICAgICAgdG9rZW5zLnB1c2goXCJcIi5jb25jYXQoU1RSSU5HUy5zaGFyZWRNYXhBZ2UsIFwiPVwiKS5jb25jYXQodGhpcy5zaGFyZWRNYXhBZ2UpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubWF4U3RhbGUpIHtcbiAgICAgICAgaWYgKHRoaXMubWF4U3RhbGVEdXJhdGlvbikge1xuICAgICAgICAgIHRva2Vucy5wdXNoKFwiXCIuY29uY2F0KFNUUklOR1MubWF4U3RhbGUsIFwiPVwiKS5jb25jYXQodGhpcy5tYXhTdGFsZUR1cmF0aW9uKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2goU1RSSU5HUy5tYXhTdGFsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubWluRnJlc2gpIHtcbiAgICAgICAgdG9rZW5zLnB1c2goXCJcIi5jb25jYXQoU1RSSU5HUy5taW5GcmVzaCwgXCI9XCIpLmNvbmNhdCh0aGlzLm1pbkZyZXNoKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmltbXV0YWJsZSkge1xuICAgICAgICB0b2tlbnMucHVzaChTVFJJTkdTLmltbXV0YWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm11c3RSZXZhbGlkYXRlKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKFNUUklOR1MubXVzdFJldmFsaWRhdGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5ub0NhY2hlKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKFNUUklOR1Mubm9DYWNoZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm5vU3RvcmUpIHtcbiAgICAgICAgdG9rZW5zLnB1c2goU1RSSU5HUy5ub1N0b3JlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubm9UcmFuc2Zvcm0pIHtcbiAgICAgICAgdG9rZW5zLnB1c2goU1RSSU5HUy5ub1RyYW5zZm9ybSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9ubHlJZkNhY2hlZCkge1xuICAgICAgICB0b2tlbnMucHVzaChTVFJJTkdTLm9ubHlJZkNhY2hlZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzW1wicHJpdmF0ZVwiXSkge1xuICAgICAgICB0b2tlbnMucHVzaChTVFJJTkdTW1wicHJpdmF0ZVwiXSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnByb3h5UmV2YWxpZGF0ZSkge1xuICAgICAgICB0b2tlbnMucHVzaChTVFJJTkdTLnByb3h5UmV2YWxpZGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzW1wicHVibGljXCJdKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKFNUUklOR1NbXCJwdWJsaWNcIl0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdG9rZW5zLmpvaW4oJywgJyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENhY2hlQ29udHJvbDtcbn0oKTtcblxuZnVuY3Rpb24gcGFyc2UoaGVhZGVyKSB7XG4gIHZhciBjYyA9IG5ldyBDYWNoZUNvbnRyb2woKTtcbiAgcmV0dXJuIGNjLnBhcnNlKGhlYWRlcik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdChjYykge1xuICBpZiAoIShjYyBpbnN0YW5jZW9mIENhY2hlQ29udHJvbCkpIHtcbiAgICByZXR1cm4gQ2FjaGVDb250cm9sLnByb3RvdHlwZS5mb3JtYXQuY2FsbChjYyk7XG4gIH1cblxuICByZXR1cm4gY2MuZm9ybWF0KCk7XG59XG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XG4gIENhY2hlQ29udHJvbDogQ2FjaGVDb250cm9sLFxuICBwYXJzZTogcGFyc2UsXG4gIGZvcm1hdDogZm9ybWF0XG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY2hhcmVuYy9jaGFyZW5jLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jaGFyZW5jL2NoYXJlbmMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciBjaGFyZW5jID0ge1xuICAvLyBVVEYtOCBlbmNvZGluZ1xuICB1dGY4OiB7XG4gICAgLy8gQ29udmVydCBhIHN0cmluZyB0byBhIGJ5dGUgYXJyYXlcbiAgICBzdHJpbmdUb0J5dGVzOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHJldHVybiBjaGFyZW5jLmJpbi5zdHJpbmdUb0J5dGVzKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKSk7XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnQgYSBieXRlIGFycmF5IHRvIGEgc3RyaW5nXG4gICAgYnl0ZXNUb1N0cmluZzogZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKGNoYXJlbmMuYmluLmJ5dGVzVG9TdHJpbmcoYnl0ZXMpKSk7XG4gICAgfVxuICB9LFxuXG4gIC8vIEJpbmFyeSBlbmNvZGluZ1xuICBiaW46IHtcbiAgICAvLyBDb252ZXJ0IGEgc3RyaW5nIHRvIGEgYnl0ZSBhcnJheVxuICAgIHN0cmluZ1RvQnl0ZXM6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgZm9yICh2YXIgYnl0ZXMgPSBbXSwgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspXG4gICAgICAgIGJ5dGVzLnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKTtcbiAgICAgIHJldHVybiBieXRlcztcbiAgICB9LFxuXG4gICAgLy8gQ29udmVydCBhIGJ5dGUgYXJyYXkgdG8gYSBzdHJpbmdcbiAgICBieXRlc1RvU3RyaW5nOiBmdW5jdGlvbihieXRlcykge1xuICAgICAgZm9yICh2YXIgc3RyID0gW10sIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspXG4gICAgICAgIHN0ci5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0pKTtcbiAgICAgIHJldHVybiBzdHIuam9pbignJyk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNoYXJlbmM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2EtZnVuY3Rpb24uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmICh0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FkZC10by11bnNjb3BhYmxlcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FkZC10by11bnNjb3BhYmxlcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyAyMi4xLjMuMzEgQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG52YXIgVU5TQ09QQUJMRVMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL193a3MgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy5qc1wiKSgndW5zY29wYWJsZXMnKTtcbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuaWYgKEFycmF5UHJvdG9bVU5TQ09QQUJMRVNdID09IHVuZGVmaW5lZCkgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faGlkZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGlkZS5qc1wiKShBcnJheVByb3RvLCBVTlNDT1BBQkxFUywge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIEFycmF5UHJvdG9bVU5TQ09QQUJMRVNdW2tleV0gPSB0cnVlO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FkdmFuY2Utc3RyaW5nLWluZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hZHZhbmNlLXN0cmluZy1pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19zdHJpbmctYXQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1hdC5qc1wiKSh0cnVlKTtcblxuIC8vIGBBZHZhbmNlU3RyaW5nSW5kZXhgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYWR2YW5jZXN0cmluZ2luZGV4XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTLCBpbmRleCwgdW5pY29kZSkge1xuICByZXR1cm4gaW5kZXggKyAodW5pY29kZSA/IGF0KFMsIGluZGV4KS5sZW5ndGggOiAxKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hbi1vYmplY3QuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hbi1vYmplY3QuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faXMtb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1vYmplY3QuanNcIik7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciB0b0lPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL190by1pb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pb2JqZWN0LmpzXCIpO1xudmFyIHRvTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fdG8tbGVuZ3RoICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1sZW5ndGguanNcIik7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fdG8tYWJzb2x1dGUtaW5kZXggKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWFic29sdXRlLWluZGV4LmpzXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pIHtcbiAgICAgIGlmIChPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19iaW5kLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2JpbmQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYUZ1bmN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYS1mdW5jdGlvbiAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYS1mdW5jdGlvbi5qc1wiKTtcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2lzLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtb2JqZWN0LmpzXCIpO1xudmFyIGludm9rZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2ludm9rZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faW52b2tlLmpzXCIpO1xudmFyIGFycmF5U2xpY2UgPSBbXS5zbGljZTtcbnZhciBmYWN0b3JpZXMgPSB7fTtcblxudmFyIGNvbnN0cnVjdCA9IGZ1bmN0aW9uIChGLCBsZW4sIGFyZ3MpIHtcbiAgaWYgKCEobGVuIGluIGZhY3RvcmllcykpIHtcbiAgICBmb3IgKHZhciBuID0gW10sIGkgPSAwOyBpIDwgbGVuOyBpKyspIG5baV0gPSAnYVsnICsgaSArICddJztcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgICBmYWN0b3JpZXNbbGVuXSA9IEZ1bmN0aW9uKCdGLGEnLCAncmV0dXJuIG5ldyBGKCcgKyBuLmpvaW4oJywnKSArICcpJyk7XG4gIH0gcmV0dXJuIGZhY3Rvcmllc1tsZW5dKEYsIGFyZ3MpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGdW5jdGlvbi5iaW5kIHx8IGZ1bmN0aW9uIGJpbmQodGhhdCAvKiAsIC4uLmFyZ3MgKi8pIHtcbiAgdmFyIGZuID0gYUZ1bmN0aW9uKHRoaXMpO1xuICB2YXIgcGFydEFyZ3MgPSBhcnJheVNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgdmFyIGJvdW5kID0gZnVuY3Rpb24gKC8qIGFyZ3MuLi4gKi8pIHtcbiAgICB2YXIgYXJncyA9IHBhcnRBcmdzLmNvbmNhdChhcnJheVNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBib3VuZCA/IGNvbnN0cnVjdChmbiwgYXJncy5sZW5ndGgsIGFyZ3MpIDogaW52b2tlKGZuLCBhcmdzLCB0aGF0KTtcbiAgfTtcbiAgaWYgKGlzT2JqZWN0KGZuLnByb3RvdHlwZSkpIGJvdW5kLnByb3RvdHlwZSA9IGZuLnByb3RvdHlwZTtcbiAgcmV0dXJuIGJvdW5kO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NsYXNzb2YuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY2xhc3NvZi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gZ2V0dGluZyB0YWcgZnJvbSAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19jb2YgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvZi5qc1wiKTtcbnZhciBUQUcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL193a3MgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy5qc1wiKSgndG9TdHJpbmdUYWcnKTtcbi8vIEVTMyB3cm9uZyBoZXJlXG52YXIgQVJHID0gY29mKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPLCBULCBCO1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAoVCA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVEFHKSkgPT0gJ3N0cmluZycgPyBUXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBBUkcgPyBjb2YoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAoQiA9IGNvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29mLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29mLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvcmUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29yZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHsgdmVyc2lvbjogJzIuNi4xMicgfTtcbmlmICh0eXBlb2YgX19lID09ICdudW1iZXInKSBfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jcmVhdGUtcHJvcGVydHkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jcmVhdGUtcHJvcGVydHkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19vYmplY3QtZHAgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcC5qc1wiKTtcbnZhciBjcmVhdGVEZXNjID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fcHJvcGVydHktZGVzYyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBpbmRleCwgdmFsdWUpIHtcbiAgaWYgKGluZGV4IGluIG9iamVjdCkgJGRlZmluZVByb3BlcnR5LmYob2JqZWN0LCBpbmRleCwgY3JlYXRlRGVzYygwLCB2YWx1ZSkpO1xuICBlbHNlIG9iamVjdFtpbmRleF0gPSB2YWx1ZTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jdHguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jdHguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYS1mdW5jdGlvbiAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYS1mdW5jdGlvbi5qc1wiKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCB0aGF0LCBsZW5ndGgpIHtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYgKHRoYXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZuO1xuICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoLyogLi4uYXJncyAqLykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RlZmluZWQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGVmaW5lZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIV9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2ZhaWxzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mYWlscy5qc1wiKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kb20tY3JlYXRlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RvbS1jcmVhdGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2lzLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtb2JqZWN0LmpzXCIpO1xudmFyIGRvY3VtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZ2xvYmFsICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanNcIikuZG9jdW1lbnQ7XG4vLyB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0JyBpbiBvbGQgSUVcbnZhciBpcyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2VudW0ta2V5cy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2VudW0ta2V5cy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBhbGwgZW51bWVyYWJsZSBvYmplY3Qga2V5cywgaW5jbHVkZXMgc3ltYm9sc1xudmFyIGdldEtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19vYmplY3Qta2V5cyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMuanNcIik7XG52YXIgZ09QUyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX29iamVjdC1nb3BzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wcy5qc1wiKTtcbnZhciBwSUUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19vYmplY3QtcGllICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtcGllLmpzXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHJlc3VsdCA9IGdldEtleXMoaXQpO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgaWYgKGdldFN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IGdldFN5bWJvbHMoaXQpO1xuICAgIHZhciBpc0VudW0gPSBwSUUuZjtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAoc3ltYm9scy5sZW5ndGggPiBpKSBpZiAoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19leHBvcnQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19leHBvcnQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2dsb2JhbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZ2xvYmFsLmpzXCIpO1xudmFyIGNvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19jb3JlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb3JlLmpzXCIpO1xudmFyIGhpZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19oaWRlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oaWRlLmpzXCIpO1xudmFyIHJlZGVmaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fcmVkZWZpbmUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLmpzXCIpO1xudmFyIGN0eCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2N0eCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY3R4LmpzXCIpO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uICh0eXBlLCBuYW1lLCBzb3VyY2UpIHtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkY7XG4gIHZhciBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HO1xuICB2YXIgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuUztcbiAgdmFyIElTX1BST1RPID0gdHlwZSAmICRleHBvcnQuUDtcbiAgdmFyIElTX0JJTkQgPSB0eXBlICYgJGV4cG9ydC5CO1xuICB2YXIgdGFyZ2V0ID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIHx8IChnbG9iYWxbbmFtZV0gPSB7fSkgOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdO1xuICB2YXIgZXhwb3J0cyA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pO1xuICB2YXIgZXhwUHJvdG8gPSBleHBvcnRzW1BST1RPVFlQRV0gfHwgKGV4cG9ydHNbUFJPVE9UWVBFXSA9IHt9KTtcbiAgdmFyIGtleSwgb3duLCBvdXQsIGV4cDtcbiAgaWYgKElTX0dMT0JBTCkgc291cmNlID0gbmFtZTtcbiAgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IChvd24gPyB0YXJnZXQgOiBzb3VyY2UpW2tleV07XG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICBleHAgPSBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHRlbmQgZ2xvYmFsXG4gICAgaWYgKHRhcmdldCkgcmVkZWZpbmUodGFyZ2V0LCBrZXksIG91dCwgdHlwZSAmICRleHBvcnQuVSk7XG4gICAgLy8gZXhwb3J0XG4gICAgaWYgKGV4cG9ydHNba2V5XSAhPSBvdXQpIGhpZGUoZXhwb3J0cywga2V5LCBleHApO1xuICAgIGlmIChJU19QUk9UTyAmJiBleHBQcm90b1trZXldICE9IG91dCkgZXhwUHJvdG9ba2V5XSA9IG91dDtcbiAgfVxufTtcbmdsb2JhbC5jb3JlID0gY29yZTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLWlzLXJlZ2V4cC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLWlzLXJlZ2V4cC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgTUFUQ0ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL193a3MgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy5qc1wiKSgnbWF0Y2gnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSkge1xuICB2YXIgcmUgPSAvLi87XG4gIHRyeSB7XG4gICAgJy8uLydbS0VZXShyZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0cnkge1xuICAgICAgcmVbTUFUQ0hdID0gZmFsc2U7XG4gICAgICByZXR1cm4gIScvLi8nW0tFWV0ocmUpO1xuICAgIH0gY2F0Y2ggKGYpIHsgLyogZW1wdHkgKi8gfVxuICB9IHJldHVybiB0cnVlO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mYWlscy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZpeC1yZS13a3MuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZml4LXJlLXdrcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbl9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZXM2LnJlZ2V4cC5leGVjICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuZXhlYy5qc1wiKTtcbnZhciByZWRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3JlZGVmaW5lICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWRlZmluZS5qc1wiKTtcbnZhciBoaWRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faGlkZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGlkZS5qc1wiKTtcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2ZhaWxzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mYWlscy5qc1wiKTtcbnZhciBkZWZpbmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZGVmaW5lZCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGVmaW5lZC5qc1wiKTtcbnZhciB3a3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL193a3MgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy5qc1wiKTtcbnZhciByZWdleHBFeGVjID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fcmVnZXhwLWV4ZWMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZ2V4cC1leGVjLmpzXCIpO1xuXG52YXIgU1BFQ0lFUyA9IHdrcygnc3BlY2llcycpO1xuXG52YXIgUkVQTEFDRV9TVVBQT1JUU19OQU1FRF9HUk9VUFMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyAjcmVwbGFjZSBuZWVkcyBidWlsdC1pbiBzdXBwb3J0IGZvciBuYW1lZCBncm91cHMuXG4gIC8vICNtYXRjaCB3b3JrcyBmaW5lIGJlY2F1c2UgaXQganVzdCByZXR1cm4gdGhlIGV4ZWMgcmVzdWx0cywgZXZlbiBpZiBpdCBoYXNcbiAgLy8gYSBcImdyb3BzXCIgcHJvcGVydHkuXG4gIHZhciByZSA9IC8uLztcbiAgcmUuZXhlYyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgcmVzdWx0Lmdyb3VwcyA9IHsgYTogJzcnIH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcmV0dXJuICcnLnJlcGxhY2UocmUsICckPGE+JykgIT09ICc3Jztcbn0pO1xuXG52YXIgU1BMSVRfV09SS1NfV0lUSF9PVkVSV1JJVFRFTl9FWEVDID0gKGZ1bmN0aW9uICgpIHtcbiAgLy8gQ2hyb21lIDUxIGhhcyBhIGJ1Z2d5IFwic3BsaXRcIiBpbXBsZW1lbnRhdGlvbiB3aGVuIFJlZ0V4cCNleGVjICE9PSBuYXRpdmVFeGVjXG4gIHZhciByZSA9IC8oPzopLztcbiAgdmFyIG9yaWdpbmFsRXhlYyA9IHJlLmV4ZWM7XG4gIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBvcmlnaW5hbEV4ZWMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfTtcbiAgdmFyIHJlc3VsdCA9ICdhYicuc3BsaXQocmUpO1xuICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA9PT0gMiAmJiByZXN1bHRbMF0gPT09ICdhJyAmJiByZXN1bHRbMV0gPT09ICdiJztcbn0pKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSwgbGVuZ3RoLCBleGVjKSB7XG4gIHZhciBTWU1CT0wgPSB3a3MoS0VZKTtcblxuICB2YXIgREVMRUdBVEVTX1RPX1NZTUJPTCA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gU3RyaW5nIG1ldGhvZHMgY2FsbCBzeW1ib2wtbmFtZWQgUmVnRXAgbWV0aG9kc1xuICAgIHZhciBPID0ge307XG4gICAgT1tTWU1CT0xdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfTtcbiAgICByZXR1cm4gJydbS0VZXShPKSAhPSA3O1xuICB9KTtcblxuICB2YXIgREVMRUdBVEVTX1RPX0VYRUMgPSBERUxFR0FURVNfVE9fU1lNQk9MID8gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBTeW1ib2wtbmFtZWQgUmVnRXhwIG1ldGhvZHMgY2FsbCAuZXhlY1xuICAgIHZhciBleGVjQ2FsbGVkID0gZmFsc2U7XG4gICAgdmFyIHJlID0gL2EvO1xuICAgIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7IGV4ZWNDYWxsZWQgPSB0cnVlOyByZXR1cm4gbnVsbDsgfTtcbiAgICBpZiAoS0VZID09PSAnc3BsaXQnKSB7XG4gICAgICAvLyBSZWdFeHBbQEBzcGxpdF0gZG9lc24ndCBjYWxsIHRoZSByZWdleCdzIGV4ZWMgbWV0aG9kLCBidXQgZmlyc3QgY3JlYXRlc1xuICAgICAgLy8gYSBuZXcgb25lLiBXZSBuZWVkIHRvIHJldHVybiB0aGUgcGF0Y2hlZCByZWdleCB3aGVuIGNyZWF0aW5nIHRoZSBuZXcgb25lLlxuICAgICAgcmUuY29uc3RydWN0b3IgPSB7fTtcbiAgICAgIHJlLmNvbnN0cnVjdG9yW1NQRUNJRVNdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmU7IH07XG4gICAgfVxuICAgIHJlW1NZTUJPTF0oJycpO1xuICAgIHJldHVybiAhZXhlY0NhbGxlZDtcbiAgfSkgOiB1bmRlZmluZWQ7XG5cbiAgaWYgKFxuICAgICFERUxFR0FURVNfVE9fU1lNQk9MIHx8XG4gICAgIURFTEVHQVRFU19UT19FWEVDIHx8XG4gICAgKEtFWSA9PT0gJ3JlcGxhY2UnICYmICFSRVBMQUNFX1NVUFBPUlRTX05BTUVEX0dST1VQUykgfHxcbiAgICAoS0VZID09PSAnc3BsaXQnICYmICFTUExJVF9XT1JLU19XSVRIX09WRVJXUklUVEVOX0VYRUMpXG4gICkge1xuICAgIHZhciBuYXRpdmVSZWdFeHBNZXRob2QgPSAvLi9bU1lNQk9MXTtcbiAgICB2YXIgZm5zID0gZXhlYyhcbiAgICAgIGRlZmluZWQsXG4gICAgICBTWU1CT0wsXG4gICAgICAnJ1tLRVldLFxuICAgICAgZnVuY3Rpb24gbWF5YmVDYWxsTmF0aXZlKG5hdGl2ZU1ldGhvZCwgcmVnZXhwLCBzdHIsIGFyZzIsIGZvcmNlU3RyaW5nTWV0aG9kKSB7XG4gICAgICAgIGlmIChyZWdleHAuZXhlYyA9PT0gcmVnZXhwRXhlYykge1xuICAgICAgICAgIGlmIChERUxFR0FURVNfVE9fU1lNQk9MICYmICFmb3JjZVN0cmluZ01ldGhvZCkge1xuICAgICAgICAgICAgLy8gVGhlIG5hdGl2ZSBTdHJpbmcgbWV0aG9kIGFscmVhZHkgZGVsZWdhdGVzIHRvIEBAbWV0aG9kICh0aGlzXG4gICAgICAgICAgICAvLyBwb2x5ZmlsbGVkIGZ1bmN0aW9uKSwgbGVhc2luZyB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gICAgICAgICAgICAvLyBXZSBhdm9pZCBpdCBieSBkaXJlY3RseSBjYWxsaW5nIHRoZSBuYXRpdmUgQEBtZXRob2QgbWV0aG9kLlxuICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IG5hdGl2ZVJlZ0V4cE1ldGhvZC5jYWxsKHJlZ2V4cCwgc3RyLCBhcmcyKSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogbmF0aXZlTWV0aG9kLmNhbGwoc3RyLCByZWdleHAsIGFyZzIpIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UgfTtcbiAgICAgIH1cbiAgICApO1xuICAgIHZhciBzdHJmbiA9IGZuc1swXTtcbiAgICB2YXIgcnhmbiA9IGZuc1sxXTtcblxuICAgIHJlZGVmaW5lKFN0cmluZy5wcm90b3R5cGUsIEtFWSwgc3RyZm4pO1xuICAgIGhpZGUoUmVnRXhwLnByb3RvdHlwZSwgU1lNQk9MLCBsZW5ndGggPT0gMlxuICAgICAgLy8gMjEuMi41LjggUmVnRXhwLnByb3RvdHlwZVtAQHJlcGxhY2VdKHN0cmluZywgcmVwbGFjZVZhbHVlKVxuICAgICAgLy8gMjEuMi41LjExIFJlZ0V4cC5wcm90b3R5cGVbQEBzcGxpdF0oc3RyaW5nLCBsaW1pdClcbiAgICAgID8gZnVuY3Rpb24gKHN0cmluZywgYXJnKSB7IHJldHVybiByeGZuLmNhbGwoc3RyaW5nLCB0aGlzLCBhcmcpOyB9XG4gICAgICAvLyAyMS4yLjUuNiBSZWdFeHAucHJvdG90eXBlW0BAbWF0Y2hdKHN0cmluZylcbiAgICAgIC8vIDIxLjIuNS45IFJlZ0V4cC5wcm90b3R5cGVbQEBzZWFyY2hdKHN0cmluZylcbiAgICAgIDogZnVuY3Rpb24gKHN0cmluZykgeyByZXR1cm4gcnhmbi5jYWxsKHN0cmluZywgdGhpcyk7IH1cbiAgICApO1xuICB9XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmxhZ3MuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZsYWdzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIDIxLjIuNS4zIGdldCBSZWdFeHAucHJvdG90eXBlLmZsYWdzXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19hbi1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FuLW9iamVjdC5qc1wiKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdGhhdCA9IGFuT2JqZWN0KHRoaXMpO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICh0aGF0Lmdsb2JhbCkgcmVzdWx0ICs9ICdnJztcbiAgaWYgKHRoYXQuaWdub3JlQ2FzZSkgcmVzdWx0ICs9ICdpJztcbiAgaWYgKHRoYXQubXVsdGlsaW5lKSByZXN1bHQgKz0gJ20nO1xuICBpZiAodGhhdC51bmljb2RlKSByZXN1bHQgKz0gJ3UnO1xuICBpZiAodGhhdC5zdGlja3kpIHJlc3VsdCArPSAneSc7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZnVuY3Rpb24tdG8tc3RyaW5nLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZnVuY3Rpb24tdG8tc3RyaW5nLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fc2hhcmVkICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zaGFyZWQuanNcIikoJ25hdGl2ZS1mdW5jdGlvbi10by1zdHJpbmcnLCBGdW5jdGlvbi50b1N0cmluZyk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuaWYgKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpIF9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGFzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGFzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oaWRlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2hpZGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBkUCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX29iamVjdC1kcCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwLmpzXCIpO1xudmFyIGNyZWF0ZURlc2MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19wcm9wZXJ0eS1kZXNjICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19kZXNjcmlwdG9ycyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanNcIikgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkUC5mKG9iamVjdCwga2V5LCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2h0bWwuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faHRtbC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGRvY3VtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZ2xvYmFsICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanNcIikuZG9jdW1lbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gIV9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Rlc2NyaXB0b3JzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZXNjcmlwdG9ycy5qc1wiKSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZmFpbHMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLmpzXCIpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19kb20tY3JlYXRlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kb20tY3JlYXRlLmpzXCIpKCdkaXYnKSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ludm9rZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ludm9rZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyBmYXN0IGFwcGx5LCBodHRwOi8vanNwZXJmLmxua2l0LmNvbS9mYXN0LWFwcGx5LzVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCBhcmdzLCB0aGF0KSB7XG4gIHZhciB1biA9IHRoYXQgPT09IHVuZGVmaW5lZDtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIHVuID8gZm4oKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0KTtcbiAgICBjYXNlIDE6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICBjYXNlIDQ6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICB9IHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmdzKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pb2JqZWN0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lvYmplY3QuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgY29mID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fY29mICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2YuanNcIik7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLWFycmF5LWl0ZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3JcbnZhciBJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19pdGVyYXRvcnMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXJhdG9ycy5qc1wiKTtcbnZhciBJVEVSQVRPUiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3drcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLmpzXCIpKCdpdGVyYXRvcicpO1xudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG9bSVRFUkFUT1JdID09PSBpdCk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtYXJyYXkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLWFycmF5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gNy4yLjIgSXNBcnJheShhcmd1bWVudClcbnZhciBjb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19jb2YgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvZi5qc1wiKTtcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICByZXR1cm4gY29mKGFyZykgPT0gJ0FycmF5Jztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1vYmplY3QuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1vYmplY3QuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1yZWdleHAuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1yZWdleHAuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gNy4yLjggSXNSZWdFeHAoYXJndW1lbnQpXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19pcy1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLW9iamVjdC5qc1wiKTtcbnZhciBjb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19jb2YgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvZi5qc1wiKTtcbnZhciBNQVRDSCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3drcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLmpzXCIpKCdtYXRjaCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIGlzUmVnRXhwO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmICgoaXNSZWdFeHAgPSBpdFtNQVRDSF0pICE9PSB1bmRlZmluZWQgPyAhIWlzUmVnRXhwIDogY29mKGl0KSA9PSAnUmVnRXhwJyk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1jYWxsLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1jYWxsLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2FuLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYW4tb2JqZWN0LmpzXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGZuLCB2YWx1ZSwgZW50cmllcykge1xuICB0cnkge1xuICAgIHJldHVybiBlbnRyaWVzID8gZm4oYW5PYmplY3QodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7XG4gIC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB2YXIgcmV0ID0gaXRlcmF0b3JbJ3JldHVybiddO1xuICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCkgYW5PYmplY3QocmV0LmNhbGwoaXRlcmF0b3IpKTtcbiAgICB0aHJvdyBlO1xuICB9XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1jcmVhdGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19vYmplY3QtY3JlYXRlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzXCIpO1xudmFyIGRlc2NyaXB0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19wcm9wZXJ0eS1kZXNjICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzXCIpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fc2V0LXRvLXN0cmluZy10YWcgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzXCIpO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19oaWRlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oaWRlLmpzXCIpKEl0ZXJhdG9yUHJvdG90eXBlLCBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL193a3MgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy5qc1wiKSgnaXRlcmF0b3InKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KSB7XG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwgeyBuZXh0OiBkZXNjcmlwdG9yKDEsIG5leHQpIH0pO1xuICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgTkFNRSArICcgSXRlcmF0b3InKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWRlZmluZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1kZWZpbmUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIExJQlJBUlkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19saWJyYXJ5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19saWJyYXJ5LmpzXCIpO1xudmFyICRleHBvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19leHBvcnQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2V4cG9ydC5qc1wiKTtcbnZhciByZWRlZmluZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3JlZGVmaW5lICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWRlZmluZS5qc1wiKTtcbnZhciBoaWRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faGlkZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGlkZS5qc1wiKTtcbnZhciBJdGVyYXRvcnMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19pdGVyYXRvcnMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXJhdG9ycy5qc1wiKTtcbnZhciAkaXRlckNyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2l0ZXItY3JlYXRlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qc1wiKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3NldC10by1zdHJpbmctdGFnICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qc1wiKTtcbnZhciBnZXRQcm90b3R5cGVPZiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX29iamVjdC1ncG8gKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1ncG8uanNcIik7XG52YXIgSVRFUkFUT1IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL193a3MgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy5qc1wiKSgnaXRlcmF0b3InKTtcbnZhciBCVUdHWSA9ICEoW10ua2V5cyAmJiAnbmV4dCcgaW4gW10ua2V5cygpKTsgLy8gU2FmYXJpIGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxudmFyIEZGX0lURVJBVE9SID0gJ0BAaXRlcmF0b3InO1xudmFyIEtFWVMgPSAna2V5cyc7XG52YXIgVkFMVUVTID0gJ3ZhbHVlcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XG4gICRpdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcbiAgdmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uIChraW5kKSB7XG4gICAgaWYgKCFCVUdHWSAmJiBraW5kIGluIHByb3RvKSByZXR1cm4gcHJvdG9ba2luZF07XG4gICAgc3dpdGNoIChraW5kKSB7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgfTtcbiAgdmFyIFRBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgdmFyIERFRl9WQUxVRVMgPSBERUZBVUxUID09IFZBTFVFUztcbiAgdmFyIFZBTFVFU19CVUcgPSBmYWxzZTtcbiAgdmFyIHByb3RvID0gQmFzZS5wcm90b3R5cGU7XG4gIHZhciAkbmF0aXZlID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdO1xuICB2YXIgJGRlZmF1bHQgPSAkbmF0aXZlIHx8IGdldE1ldGhvZChERUZBVUxUKTtcbiAgdmFyICRlbnRyaWVzID0gREVGQVVMVCA/ICFERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKSA6IHVuZGVmaW5lZDtcbiAgdmFyICRhbnlOYXRpdmUgPSBOQU1FID09ICdBcnJheScgPyBwcm90by5lbnRyaWVzIHx8ICRuYXRpdmUgOiAkbmF0aXZlO1xuICB2YXIgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZiAoJGFueU5hdGl2ZSkge1xuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoJGFueU5hdGl2ZS5jYWxsKG5ldyBCYXNlKCkpKTtcbiAgICBpZiAoSXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgSXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JQcm90b3R5cGUsIFRBRywgdHJ1ZSk7XG4gICAgICAvLyBmaXggZm9yIHNvbWUgb2xkIGVuZ2luZXNcbiAgICAgIGlmICghTElCUkFSWSAmJiB0eXBlb2YgSXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdICE9ICdmdW5jdGlvbicpIGhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICB9XG4gIH1cbiAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxuICBpZiAoREVGX1ZBTFVFUyAmJiAkbmF0aXZlICYmICRuYXRpdmUubmFtZSAhPT0gVkFMVUVTKSB7XG4gICAgVkFMVUVTX0JVRyA9IHRydWU7XG4gICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiAkbmF0aXZlLmNhbGwodGhpcyk7IH07XG4gIH1cbiAgLy8gRGVmaW5lIGl0ZXJhdG9yXG4gIGlmICgoIUxJQlJBUlkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSkge1xuICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7XG4gIH1cbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDtcbiAgSXRlcmF0b3JzW1RBR10gPSByZXR1cm5UaGlzO1xuICBpZiAoREVGQVVMVCkge1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6IERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogSVNfU0VUID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiAkZW50cmllc1xuICAgIH07XG4gICAgaWYgKEZPUkNFRCkgZm9yIChrZXkgaW4gbWV0aG9kcykge1xuICAgICAgaWYgKCEoa2V5IGluIHByb3RvKSkgcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcbiAgICB9IGVsc2UgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoQlVHR1kgfHwgVkFMVUVTX0JVRyksIE5BTUUsIG1ldGhvZHMpO1xuICB9XG4gIHJldHVybiBtZXRob2RzO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2l0ZXItZGV0ZWN0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWRldGVjdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBJVEVSQVRPUiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3drcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLmpzXCIpKCdpdGVyYXRvcicpO1xudmFyIFNBRkVfQ0xPU0lORyA9IGZhbHNlO1xuXG50cnkge1xuICB2YXIgcml0ZXIgPSBbN11bSVRFUkFUT1JdKCk7XG4gIHJpdGVyWydyZXR1cm4nXSA9IGZ1bmN0aW9uICgpIHsgU0FGRV9DTE9TSU5HID0gdHJ1ZTsgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcbiAgQXJyYXkuZnJvbShyaXRlciwgZnVuY3Rpb24gKCkgeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjLCBza2lwQ2xvc2luZykge1xuICBpZiAoIXNraXBDbG9zaW5nICYmICFTQUZFX0NMT1NJTkcpIHJldHVybiBmYWxzZTtcbiAgdmFyIHNhZmUgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gWzddO1xuICAgIHZhciBpdGVyID0gYXJyW0lURVJBVE9SXSgpO1xuICAgIGl0ZXIubmV4dCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHsgZG9uZTogc2FmZSA9IHRydWUgfTsgfTtcbiAgICBhcnJbSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXRlcjsgfTtcbiAgICBleGVjKGFycik7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gc2FmZTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLXN0ZXAuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLXN0ZXAuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9uZSwgdmFsdWUpIHtcbiAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmUgfTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyYXRvcnMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyYXRvcnMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2xpYnJhcnkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbGlicmFyeS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBmYWxzZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX21ldGEuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbWV0YS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIE1FVEEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL191aWQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3VpZC5qc1wiKSgnbWV0YScpO1xudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faXMtb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1vYmplY3QuanNcIik7XG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faGFzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oYXMuanNcIik7XG52YXIgc2V0RGVzYyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX29iamVjdC1kcCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwLmpzXCIpLmY7XG52YXIgaWQgPSAwO1xudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgRlJFRVpFID0gIV9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2ZhaWxzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mYWlscy5qc1wiKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBpc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSk7XG59KTtcbnZhciBzZXRNZXRhID0gZnVuY3Rpb24gKGl0KSB7XG4gIHNldERlc2MoaXQsIE1FVEEsIHsgdmFsdWU6IHtcbiAgICBpOiAnTycgKyArK2lkLCAvLyBvYmplY3QgSURcbiAgICB3OiB7fSAgICAgICAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IH0pO1xufTtcbnZhciBmYXN0S2V5ID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgLy8gcmV0dXJuIHByaW1pdGl2ZSB3aXRoIHByZWZpeFxuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiAnRic7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gb2JqZWN0IElEXG4gIH0gcmV0dXJuIGl0W01FVEFdLmk7XG59O1xudmFyIGdldFdlYWsgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICBpZiAoIWhhcyhpdCwgTUVUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuIHRydWU7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBoYXNoIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gcmV0dXJuIGl0W01FVEFdLnc7XG59O1xuLy8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nXG52YXIgb25GcmVlemUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKEZSRUVaRSAmJiBtZXRhLk5FRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBKSkgc2V0TWV0YShpdCk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgbWV0YSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBLRVk6IE1FVEEsXG4gIE5FRUQ6IGZhbHNlLFxuICBmYXN0S2V5OiBmYXN0S2V5LFxuICBnZXRXZWFrOiBnZXRXZWFrLFxuICBvbkZyZWV6ZTogb25GcmVlemVcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1jcmVhdGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYW4tb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hbi1vYmplY3QuanNcIik7XG52YXIgZFBzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fb2JqZWN0LWRwcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwcy5qc1wiKTtcbnZhciBlbnVtQnVnS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2VudW0tYnVnLWtleXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2VudW0tYnVnLWtleXMuanNcIik7XG52YXIgSUVfUFJPVE8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19zaGFyZWQta2V5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zaGFyZWQta2V5LmpzXCIpKCdJRV9QUk9UTycpO1xudmFyIEVtcHR5ID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2RvbS1jcmVhdGUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RvbS1jcmVhdGUuanNcIikoJ2lmcmFtZScpO1xuICB2YXIgaSA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgdmFyIGx0ID0gJzwnO1xuICB2YXIgZ3QgPSAnPic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2h0bWwgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2h0bWwuanNcIikuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0Oic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2NyaXB0LXVybFxuICAvLyBjcmVhdGVEaWN0ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuT2JqZWN0O1xuICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUobHQgKyAnc2NyaXB0JyArIGd0ICsgJ2RvY3VtZW50LkY9T2JqZWN0JyArIGx0ICsgJy9zY3JpcHQnICsgZ3QpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcbiAgd2hpbGUgKGktLSkgZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5KCk7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2FuLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYW4tb2JqZWN0LmpzXCIpO1xudmFyIElFOF9ET01fREVGSU5FID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faWU4LWRvbS1kZWZpbmUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzXCIpO1xudmFyIHRvUHJpbWl0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fdG8tcHJpbWl0aXZlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1wcmltaXRpdmUuanNcIik7XG52YXIgZFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Rlc2NyaXB0b3JzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZXNjcmlwdG9ycy5qc1wiKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHBzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZFAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19vYmplY3QtZHAgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcC5qc1wiKTtcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2FuLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYW4tb2JqZWN0LmpzXCIpO1xudmFyIGdldEtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19vYmplY3Qta2V5cyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMuanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZGVzY3JpcHRvcnMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzXCIpID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaSA9IDA7XG4gIHZhciBQO1xuICB3aGlsZSAobGVuZ3RoID4gaSkgZFAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcbiAgcmV0dXJuIE87XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BkLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHBJRSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX29iamVjdC1waWUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1waWUuanNcIik7XG52YXIgY3JlYXRlRGVzYyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3Byb3BlcnR5LWRlc2MgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanNcIik7XG52YXIgdG9JT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fdG8taW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8taW9iamVjdC5qc1wiKTtcbnZhciB0b1ByaW1pdGl2ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3RvLXByaW1pdGl2ZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tcHJpbWl0aXZlLmpzXCIpO1xudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2hhcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGFzLmpzXCIpO1xudmFyIElFOF9ET01fREVGSU5FID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faWU4LWRvbS1kZWZpbmUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzXCIpO1xudmFyIGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG5leHBvcnRzLmYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19kZXNjcmlwdG9ycyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanNcIikgPyBnT1BEIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSU9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGdPUEQoTywgUCk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoaGFzKE8sIFApKSByZXR1cm4gY3JlYXRlRGVzYyghcElFLmYuY2FsbChPLCBQKSwgT1tQXSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIGJ1Z2d5IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHdpdGggaWZyYW1lIGFuZCB3aW5kb3dcbnZhciB0b0lPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL190by1pb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pb2JqZWN0LmpzXCIpO1xudmFyIGdPUE4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19vYmplY3QtZ29wbiAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcG4uanNcIikuZjtcbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xuICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcblxudmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGdPUE4oaXQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHdpbmRvd05hbWVzLnNsaWNlKCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiB0b1N0cmluZy5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJyA/IGdldFdpbmRvd05hbWVzKGl0KSA6IGdPUE4odG9JT2JqZWN0KGl0KSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcG4uanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BuLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gMTkuMS4yLjcgLyAxNS4yLjMuNCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxudmFyICRrZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzXCIpO1xudmFyIGhpZGRlbktleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19lbnVtLWJ1Zy1rZXlzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzXCIpLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgcmV0dXJuICRrZXlzKE8sIGhpZGRlbktleXMpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ3BvLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1ncG8uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faGFzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oYXMuanNcIik7XG52YXIgdG9PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL190by1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLW9iamVjdC5qc1wiKTtcbnZhciBJRV9QUk9UTyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3NoYXJlZC1rZXkgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC1rZXkuanNcIikoJ0lFX1BST1RPJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiAoTykge1xuICBPID0gdG9PYmplY3QoTyk7XG4gIGlmIChoYXMoTywgSUVfUFJPVE8pKSByZXR1cm4gT1tJRV9QUk9UT107XG4gIGlmICh0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG8gOiBudWxsO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19oYXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2hhcy5qc1wiKTtcbnZhciB0b0lPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL190by1pb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pb2JqZWN0LmpzXCIpO1xudmFyIGFycmF5SW5kZXhPZiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2FycmF5LWluY2x1ZGVzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qc1wiKShmYWxzZSk7XG52YXIgSUVfUFJPVE8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19zaGFyZWQta2V5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zaGFyZWQta2V5LmpzXCIpKCdJRV9QUk9UTycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JT2JqZWN0KG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSBpZiAoa2V5ICE9IElFX1BST1RPKSBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxudmFyICRrZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzXCIpO1xudmFyIGVudW1CdWdLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZW51bS1idWcta2V5cyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiAgcmV0dXJuICRrZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtcGllLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1waWUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb3duLWtleXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX293bi1rZXlzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gYWxsIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBub24tZW51bWVyYWJsZSBhbmQgc3ltYm9sc1xudmFyIGdPUE4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19vYmplY3QtZ29wbiAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcG4uanNcIik7XG52YXIgZ09QUyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX29iamVjdC1nb3BzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wcy5qc1wiKTtcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2FuLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYW4tb2JqZWN0LmpzXCIpO1xudmFyIFJlZmxlY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19nbG9iYWwgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2dsb2JhbC5qc1wiKS5SZWZsZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBSZWZsZWN0ICYmIFJlZmxlY3Qub3duS2V5cyB8fCBmdW5jdGlvbiBvd25LZXlzKGl0KSB7XG4gIHZhciBrZXlzID0gZ09QTi5mKGFuT2JqZWN0KGl0KSk7XG4gIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICByZXR1cm4gZ2V0U3ltYm9scyA/IGtleXMuY29uY2F0KGdldFN5bWJvbHMoaXQpKSA6IGtleXM7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2dsb2JhbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZ2xvYmFsLmpzXCIpO1xudmFyIGhpZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19oaWRlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oaWRlLmpzXCIpO1xudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2hhcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGFzLmpzXCIpO1xudmFyIFNSQyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3VpZCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdWlkLmpzXCIpKCdzcmMnKTtcbnZhciAkdG9TdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19mdW5jdGlvbi10by1zdHJpbmcgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2Z1bmN0aW9uLXRvLXN0cmluZy5qc1wiKTtcbnZhciBUT19TVFJJTkcgPSAndG9TdHJpbmcnO1xudmFyIFRQTCA9ICgnJyArICR0b1N0cmluZykuc3BsaXQoVE9fU1RSSU5HKTtcblxuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fY29yZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY29yZS5qc1wiKS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiAkdG9TdHJpbmcuY2FsbChpdCk7XG59O1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywga2V5LCB2YWwsIHNhZmUpIHtcbiAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgdmFsID09ICdmdW5jdGlvbic7XG4gIGlmIChpc0Z1bmN0aW9uKSBoYXModmFsLCAnbmFtZScpIHx8IGhpZGUodmFsLCAnbmFtZScsIGtleSk7XG4gIGlmIChPW2tleV0gPT09IHZhbCkgcmV0dXJuO1xuICBpZiAoaXNGdW5jdGlvbikgaGFzKHZhbCwgU1JDKSB8fCBoaWRlKHZhbCwgU1JDLCBPW2tleV0gPyAnJyArIE9ba2V5XSA6IFRQTC5qb2luKFN0cmluZyhrZXkpKSk7XG4gIGlmIChPID09PSBnbG9iYWwpIHtcbiAgICBPW2tleV0gPSB2YWw7XG4gIH0gZWxzZSBpZiAoIXNhZmUpIHtcbiAgICBkZWxldGUgT1trZXldO1xuICAgIGhpZGUoTywga2V5LCB2YWwpO1xuICB9IGVsc2UgaWYgKE9ba2V5XSkge1xuICAgIE9ba2V5XSA9IHZhbDtcbiAgfSBlbHNlIHtcbiAgICBoaWRlKE8sIGtleSwgdmFsKTtcbiAgfVxuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG59KShGdW5jdGlvbi5wcm90b3R5cGUsIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nICYmIHRoaXNbU1JDXSB8fCAkdG9TdHJpbmcuY2FsbCh0aGlzKTtcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVnZXhwLWV4ZWMtYWJzdHJhY3QuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZ2V4cC1leGVjLWFic3RyYWN0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19jbGFzc29mICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jbGFzc29mLmpzXCIpO1xudmFyIGJ1aWx0aW5FeGVjID0gUmVnRXhwLnByb3RvdHlwZS5leGVjO1xuXG4gLy8gYFJlZ0V4cEV4ZWNgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVnZXhwZXhlY1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoUiwgUykge1xuICB2YXIgZXhlYyA9IFIuZXhlYztcbiAgaWYgKHR5cGVvZiBleGVjID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHJlc3VsdCA9IGV4ZWMuY2FsbChSLCBTKTtcbiAgICBpZiAodHlwZW9mIHJlc3VsdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZ0V4cCBleGVjIG1ldGhvZCByZXR1cm5lZCBzb21ldGhpbmcgb3RoZXIgdGhhbiBhbiBPYmplY3Qgb3IgbnVsbCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmIChjbGFzc29mKFIpICE9PSAnUmVnRXhwJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlZ0V4cCNleGVjIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgcmVjZWl2ZXInKTtcbiAgfVxuICByZXR1cm4gYnVpbHRpbkV4ZWMuY2FsbChSLCBTKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWdleHAtZXhlYy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVnZXhwLWV4ZWMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgcmVnZXhwRmxhZ3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19mbGFncyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmxhZ3MuanNcIik7XG5cbnZhciBuYXRpdmVFeGVjID0gUmVnRXhwLnByb3RvdHlwZS5leGVjO1xuLy8gVGhpcyBhbHdheXMgcmVmZXJzIHRvIHRoZSBuYXRpdmUgaW1wbGVtZW50YXRpb24sIGJlY2F1c2UgdGhlXG4vLyBTdHJpbmcjcmVwbGFjZSBwb2x5ZmlsbCB1c2VzIC4vZml4LXJlZ2V4cC13ZWxsLWtub3duLXN5bWJvbC1sb2dpYy5qcyxcbi8vIHdoaWNoIGxvYWRzIHRoaXMgZmlsZSBiZWZvcmUgcGF0Y2hpbmcgdGhlIG1ldGhvZC5cbnZhciBuYXRpdmVSZXBsYWNlID0gU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlO1xuXG52YXIgcGF0Y2hlZEV4ZWMgPSBuYXRpdmVFeGVjO1xuXG52YXIgTEFTVF9JTkRFWCA9ICdsYXN0SW5kZXgnO1xuXG52YXIgVVBEQVRFU19MQVNUX0lOREVYX1dST05HID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlMSA9IC9hLyxcbiAgICAgIHJlMiA9IC9iKi9nO1xuICBuYXRpdmVFeGVjLmNhbGwocmUxLCAnYScpO1xuICBuYXRpdmVFeGVjLmNhbGwocmUyLCAnYScpO1xuICByZXR1cm4gcmUxW0xBU1RfSU5ERVhdICE9PSAwIHx8IHJlMltMQVNUX0lOREVYXSAhPT0gMDtcbn0pKCk7XG5cbi8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwLCBjb3BpZWQgZnJvbSBlczUtc2hpbSdzIFN0cmluZyNzcGxpdCBwYXRjaC5cbnZhciBOUENHX0lOQ0xVREVEID0gLygpPz8vLmV4ZWMoJycpWzFdICE9PSB1bmRlZmluZWQ7XG5cbnZhciBQQVRDSCA9IFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyB8fCBOUENHX0lOQ0xVREVEO1xuXG5pZiAoUEFUQ0gpIHtcbiAgcGF0Y2hlZEV4ZWMgPSBmdW5jdGlvbiBleGVjKHN0cikge1xuICAgIHZhciByZSA9IHRoaXM7XG4gICAgdmFyIGxhc3RJbmRleCwgcmVDb3B5LCBtYXRjaCwgaTtcblxuICAgIGlmIChOUENHX0lOQ0xVREVEKSB7XG4gICAgICByZUNvcHkgPSBuZXcgUmVnRXhwKCdeJyArIHJlLnNvdXJjZSArICckKD8hXFxcXHMpJywgcmVnZXhwRmxhZ3MuY2FsbChyZSkpO1xuICAgIH1cbiAgICBpZiAoVVBEQVRFU19MQVNUX0lOREVYX1dST05HKSBsYXN0SW5kZXggPSByZVtMQVNUX0lOREVYXTtcblxuICAgIG1hdGNoID0gbmF0aXZlRXhlYy5jYWxsKHJlLCBzdHIpO1xuXG4gICAgaWYgKFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyAmJiBtYXRjaCkge1xuICAgICAgcmVbTEFTVF9JTkRFWF0gPSByZS5nbG9iYWwgPyBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCA6IGxhc3RJbmRleDtcbiAgICB9XG4gICAgaWYgKE5QQ0dfSU5DTFVERUQgJiYgbWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgLy8gRml4IGJyb3dzZXJzIHdob3NlIGBleGVjYCBtZXRob2RzIGRvbid0IGNvbnNpc3RlbnRseSByZXR1cm4gYHVuZGVmaW5lZGBcbiAgICAgIC8vIGZvciBOUENHLCBsaWtlIElFOC4gTk9URTogVGhpcyBkb2Vzbicgd29yayBmb3IgLyguPyk/L1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvb3AtZnVuY1xuICAgICAgbmF0aXZlUmVwbGFjZS5jYWxsKG1hdGNoWzBdLCByZUNvcHksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAyOyBpKyspIHtcbiAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldID09PSB1bmRlZmluZWQpIG1hdGNoW2ldID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWF0Y2g7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGF0Y2hlZEV4ZWM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZGVmID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fb2JqZWN0LWRwICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHAuanNcIikuZjtcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19oYXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2hhcy5qc1wiKTtcbnZhciBUQUcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL193a3MgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy5qc1wiKSgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIHRhZywgc3RhdCkge1xuICBpZiAoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSkgZGVmKGl0LCBUQUcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdGFnIH0pO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC1rZXkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLWtleS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHNoYXJlZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3NoYXJlZCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLmpzXCIpKCdrZXlzJyk7XG52YXIgdWlkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fdWlkICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL191aWQuanNcIik7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zaGFyZWQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zaGFyZWQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGNvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19jb3JlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb3JlLmpzXCIpO1xudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2dsb2JhbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZ2xvYmFsLmpzXCIpO1xudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KTtcbn0pKCd2ZXJzaW9ucycsIFtdKS5wdXNoKHtcbiAgdmVyc2lvbjogY29yZS52ZXJzaW9uLFxuICBtb2RlOiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19saWJyYXJ5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19saWJyYXJ5LmpzXCIpID8gJ3B1cmUnIDogJ2dsb2JhbCcsXG4gIGNvcHlyaWdodDogJ8KpIDIwMjAgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknXG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NwZWNpZXMtY29uc3RydWN0b3IuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3BlY2llcy1jb25zdHJ1Y3Rvci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gNy4zLjIwIFNwZWNpZXNDb25zdHJ1Y3RvcihPLCBkZWZhdWx0Q29uc3RydWN0b3IpXG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19hbi1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FuLW9iamVjdC5qc1wiKTtcbnZhciBhRnVuY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19hLWZ1bmN0aW9uICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzXCIpO1xudmFyIFNQRUNJRVMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL193a3MgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy5qc1wiKSgnc3BlY2llcycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywgRCkge1xuICB2YXIgQyA9IGFuT2JqZWN0KE8pLmNvbnN0cnVjdG9yO1xuICB2YXIgUztcbiAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCB8fCAoUyA9IGFuT2JqZWN0KEMpW1NQRUNJRVNdKSA9PSB1bmRlZmluZWQgPyBEIDogYUZ1bmN0aW9uKFMpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1hdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1hdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgdG9JbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fdG8taW50ZWdlciAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8taW50ZWdlci5qc1wiKTtcbnZhciBkZWZpbmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZGVmaW5lZCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGVmaW5lZC5qc1wiKTtcbi8vIHRydWUgIC0+IFN0cmluZyNhdFxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUT19TVFJJTkcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0aGF0LCBwb3MpIHtcbiAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKTtcbiAgICB2YXIgaSA9IHRvSW50ZWdlcihwb3MpO1xuICAgIHZhciBsID0gcy5sZW5ndGg7XG4gICAgdmFyIGEsIGI7XG4gICAgaWYgKGkgPCAwIHx8IGkgPj0gbCkgcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcbiAgICAgID8gVE9fU1RSSU5HID8gcy5jaGFyQXQoaSkgOiBhXG4gICAgICA6IFRPX1NUUklORyA/IHMuc2xpY2UoaSwgaSArIDIpIDogKGEgLSAweGQ4MDAgPDwgMTApICsgKGIgLSAweGRjMDApICsgMHgxMDAwMDtcbiAgfTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctY29udGV4dC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLWNvbnRleHQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBoZWxwZXIgZm9yIFN0cmluZyN7c3RhcnRzV2l0aCwgZW5kc1dpdGgsIGluY2x1ZGVzfVxudmFyIGlzUmVnRXhwID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faXMtcmVnZXhwICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1yZWdleHAuanNcIik7XG52YXIgZGVmaW5lZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2RlZmluZWQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RlZmluZWQuanNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRoYXQsIHNlYXJjaFN0cmluZywgTkFNRSkge1xuICBpZiAoaXNSZWdFeHAoc2VhcmNoU3RyaW5nKSkgdGhyb3cgVHlwZUVycm9yKCdTdHJpbmcjJyArIE5BTUUgKyBcIiBkb2Vzbid0IGFjY2VwdCByZWdleCFcIik7XG4gIHJldHVybiBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tYWJzb2x1dGUtaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWFic29sdXRlLWluZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHRvSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3RvLWludGVnZXIgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWludGVnZXIuanNcIik7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8taW50ZWdlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pbnRlZ2VyLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWlvYmplY3QuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8taW9iamVjdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2lvYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lvYmplY3QuanNcIik7XG52YXIgZGVmaW5lZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2RlZmluZWQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RlZmluZWQuanNcIik7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIHRvSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3RvLWludGVnZXIgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWludGVnZXIuanNcIik7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLW9iamVjdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLW9iamVjdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2RlZmluZWQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2RlZmluZWQuanNcIik7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1wcmltaXRpdmUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1wcmltaXRpdmUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19pcy1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLW9iamVjdC5qc1wiKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFMpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdWlkLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdWlkLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciBpZCA9IDA7XG52YXIgcHggPSBNYXRoLnJhbmRvbSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLWRlZmluZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MtZGVmaW5lLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZ2xvYmFsICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanNcIik7XG52YXIgY29yZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2NvcmUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvcmUuanNcIik7XG52YXIgTElCUkFSWSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2xpYnJhcnkgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2xpYnJhcnkuanNcIik7XG52YXIgd2tzRXh0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fd2tzLWV4dCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLWV4dC5qc1wiKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX29iamVjdC1kcCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwLmpzXCIpLmY7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciAkU3ltYm9sID0gY29yZS5TeW1ib2wgfHwgKGNvcmUuU3ltYm9sID0gTElCUkFSWSA/IHt9IDogZ2xvYmFsLlN5bWJvbCB8fCB7fSk7XG4gIGlmIChuYW1lLmNoYXJBdCgwKSAhPSAnXycgJiYgIShuYW1lIGluICRTeW1ib2wpKSBkZWZpbmVQcm9wZXJ0eSgkU3ltYm9sLCBuYW1lLCB7IHZhbHVlOiB3a3NFeHQuZihuYW1lKSB9KTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MtZXh0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy1leHQuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmV4cG9ydHMuZiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3drcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLmpzXCIpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBzdG9yZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3NoYXJlZCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLmpzXCIpKCd3a3MnKTtcbnZhciB1aWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL191aWQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3VpZC5qc1wiKTtcbnZhciBTeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19nbG9iYWwgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2dsb2JhbC5qc1wiKS5TeW1ib2w7XG52YXIgVVNFX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcblxudmFyICRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cbiAgICBVU0VfU1lNQk9MICYmIFN5bWJvbFtuYW1lXSB8fCAoVVNFX1NZTUJPTCA/IFN5bWJvbCA6IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xufTtcblxuJGV4cG9ydHMuc3RvcmUgPSBzdG9yZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBjbGFzc29mID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fY2xhc3NvZiAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY2xhc3NvZi5qc1wiKTtcbnZhciBJVEVSQVRPUiA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3drcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLmpzXCIpKCdpdGVyYXRvcicpO1xudmFyIEl0ZXJhdG9ycyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2l0ZXJhdG9ycyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlcmF0b3JzLmpzXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19jb3JlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb3JlLmpzXCIpLmdldEl0ZXJhdG9yTWV0aG9kID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCAhPSB1bmRlZmluZWQpIHJldHVybiBpdFtJVEVSQVRPUl1cbiAgICB8fCBpdFsnQEBpdGVyYXRvciddXG4gICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5mcm9tLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZyb20uanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgY3R4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fY3R4ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jdHguanNcIik7XG52YXIgJGV4cG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2V4cG9ydCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZXhwb3J0LmpzXCIpO1xudmFyIHRvT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fdG8tb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1vYmplY3QuanNcIik7XG52YXIgY2FsbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2l0ZXItY2FsbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1jYWxsLmpzXCIpO1xudmFyIGlzQXJyYXlJdGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faXMtYXJyYXktaXRlciAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtYXJyYXktaXRlci5qc1wiKTtcbnZhciB0b0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3RvLWxlbmd0aCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzXCIpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fY3JlYXRlLXByb3BlcnR5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jcmVhdGUtcHJvcGVydHkuanNcIik7XG52YXIgZ2V0SXRlckZuID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kLmpzXCIpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19pdGVyLWRldGVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1kZXRlY3QuanNcIikoZnVuY3Rpb24gKGl0ZXIpIHsgQXJyYXkuZnJvbShpdGVyKTsgfSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4yLjEgQXJyYXkuZnJvbShhcnJheUxpa2UsIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICBmcm9tOiBmdW5jdGlvbiBmcm9tKGFycmF5TGlrZSAvKiAsIG1hcGZuID0gdW5kZWZpbmVkLCB0aGlzQXJnID0gdW5kZWZpbmVkICovKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdChhcnJheUxpa2UpO1xuICAgIHZhciBDID0gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyA/IHRoaXMgOiBBcnJheTtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIG1hcGZuID0gYUxlbiA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gICAgdmFyIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGl0ZXJGbiA9IGdldEl0ZXJGbihPKTtcbiAgICB2YXIgbGVuZ3RoLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yO1xuICAgIGlmIChtYXBwaW5nKSBtYXBmbiA9IGN0eChtYXBmbiwgYUxlbiA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQsIDIpO1xuICAgIC8vIGlmIG9iamVjdCBpc24ndCBpdGVyYWJsZSBvciBpdCdzIGFycmF5IHdpdGggZGVmYXVsdCBpdGVyYXRvciAtIHVzZSBzaW1wbGUgY2FzZVxuICAgIGlmIChpdGVyRm4gIT0gdW5kZWZpbmVkICYmICEoQyA9PSBBcnJheSAmJiBpc0FycmF5SXRlcihpdGVyRm4pKSkge1xuICAgICAgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKE8pLCByZXN1bHQgPSBuZXcgQygpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGluZGV4KyspIHtcbiAgICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IGNhbGwoaXRlcmF0b3IsIG1hcGZuLCBbc3RlcC52YWx1ZSwgaW5kZXhdLCB0cnVlKSA6IHN0ZXAudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgICBmb3IgKHJlc3VsdCA9IG5ldyBDKGxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmcgPyBtYXBmbihPW2luZGV4XSwgaW5kZXgpIDogT1tpbmRleF0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQubGVuZ3RoID0gaW5kZXg7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGFkZFRvVW5zY29wYWJsZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19hZGQtdG8tdW5zY29wYWJsZXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FkZC10by11bnNjb3BhYmxlcy5qc1wiKTtcbnZhciBzdGVwID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faXRlci1zdGVwICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLXN0ZXAuanNcIik7XG52YXIgSXRlcmF0b3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faXRlcmF0b3JzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyYXRvcnMuanNcIik7XG52YXIgdG9JT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fdG8taW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8taW9iamVjdC5qc1wiKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19pdGVyLWRlZmluZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXRlci1kZWZpbmUuanNcIikoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICB0aGlzLl90ID0gdG9JT2JqZWN0KGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gIHRoaXMuX2sgPSBraW5kOyAgICAgICAgICAgICAgICAvLyBraW5kXG4vLyAyMi4xLjUuMi4xICVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIE8gPSB0aGlzLl90O1xuICB2YXIga2luZCA9IHRoaXMuX2s7XG4gIHZhciBpbmRleCA9IHRoaXMuX2krKztcbiAgaWYgKCFPIHx8IGluZGV4ID49IE8ubGVuZ3RoKSB7XG4gICAgdGhpcy5fdCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gc3RlcCgxKTtcbiAgfVxuICBpZiAoa2luZCA9PSAna2V5cycpIHJldHVybiBzdGVwKDAsIGluZGV4KTtcbiAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiBzdGVwKDAsIE9baW5kZXhdKTtcbiAgcmV0dXJuIHN0ZXAoMCwgW2luZGV4LCBPW2luZGV4XV0pO1xufSwgJ3ZhbHVlcycpO1xuXG4vLyBhcmd1bWVudHNMaXN0W0BAaXRlcmF0b3JdIGlzICVBcnJheVByb3RvX3ZhbHVlcyUgKDkuNC40LjYsIDkuNC40LjcpXG5JdGVyYXRvcnMuQXJndW1lbnRzID0gSXRlcmF0b3JzLkFycmF5O1xuXG5hZGRUb1Vuc2NvcGFibGVzKCdrZXlzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCd2YWx1ZXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmJpbmQuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24uYmluZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLy8gMTkuMi4zLjIgLyAxNS4zLjQuNSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCh0aGlzQXJnLCBhcmdzLi4uKVxudmFyICRleHBvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19leHBvcnQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2V4cG9ydC5qc1wiKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdGdW5jdGlvbicsIHsgYmluZDogX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYmluZCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYmluZC5qc1wiKSB9KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLm5hbWUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24ubmFtZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGRQID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fb2JqZWN0LWRwICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHAuanNcIikuZjtcbnZhciBGUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgbmFtZVJFID0gL15cXHMqZnVuY3Rpb24gKFteIChdKikvO1xudmFyIE5BTUUgPSAnbmFtZSc7XG5cbi8vIDE5LjIuNC4yIG5hbWVcbk5BTUUgaW4gRlByb3RvIHx8IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2Rlc2NyaXB0b3JzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZXNjcmlwdG9ycy5qc1wiKSAmJiBkUChGUHJvdG8sIE5BTUUsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuICgnJyArIHRoaXMpLm1hdGNoKG5hbWVSRSlbMV07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuaXMtZmluaXRlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5pcy1maW5pdGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8vIDIwLjEuMi4yIE51bWJlci5pc0Zpbml0ZShudW1iZXIpXG52YXIgJGV4cG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2V4cG9ydCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZXhwb3J0LmpzXCIpO1xudmFyIF9pc0Zpbml0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2dsb2JhbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZ2xvYmFsLmpzXCIpLmlzRmluaXRlO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ051bWJlcicsIHtcbiAgaXNGaW5pdGU6IGZ1bmN0aW9uIGlzRmluaXRlKGl0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnbnVtYmVyJyAmJiBfaXNGaW5pdGUoaXQpO1xuICB9XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19jbGFzc29mICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jbGFzc29mLmpzXCIpO1xudmFyIHRlc3QgPSB7fTtcbnRlc3RbX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fd2tzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MuanNcIikoJ3RvU3RyaW5nVGFnJyldID0gJ3onO1xuaWYgKHRlc3QgKyAnJyAhPSAnW29iamVjdCB6XScpIHtcbiAgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fcmVkZWZpbmUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLmpzXCIpKE9iamVjdC5wcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnW29iamVjdCAnICsgY2xhc3NvZih0aGlzKSArICddJztcbiAgfSwgdHJ1ZSk7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuZXhlYy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLmV4ZWMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIHJlZ2V4cEV4ZWMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19yZWdleHAtZXhlYyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVnZXhwLWV4ZWMuanNcIik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19leHBvcnQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2V4cG9ydC5qc1wiKSh7XG4gIHRhcmdldDogJ1JlZ0V4cCcsXG4gIHByb3RvOiB0cnVlLFxuICBmb3JjZWQ6IHJlZ2V4cEV4ZWMgIT09IC8uLy5leGVjXG59LCB7XG4gIGV4ZWM6IHJlZ2V4cEV4ZWNcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnNwbGl0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYucmVnZXhwLnNwbGl0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBpc1JlZ0V4cCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2lzLXJlZ2V4cCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtcmVnZXhwLmpzXCIpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYW4tb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hbi1vYmplY3QuanNcIik7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fc3BlY2llcy1jb25zdHJ1Y3RvciAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3BlY2llcy1jb25zdHJ1Y3Rvci5qc1wiKTtcbnZhciBhZHZhbmNlU3RyaW5nSW5kZXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19hZHZhbmNlLXN0cmluZy1pbmRleCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYWR2YW5jZS1zdHJpbmctaW5kZXguanNcIik7XG52YXIgdG9MZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL190by1sZW5ndGggKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWxlbmd0aC5qc1wiKTtcbnZhciBjYWxsUmVnRXhwRXhlYyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3JlZ2V4cC1leGVjLWFic3RyYWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWdleHAtZXhlYy1hYnN0cmFjdC5qc1wiKTtcbnZhciByZWdleHBFeGVjID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fcmVnZXhwLWV4ZWMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZ2V4cC1leGVjLmpzXCIpO1xudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZmFpbHMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLmpzXCIpO1xudmFyICRtaW4gPSBNYXRoLm1pbjtcbnZhciAkcHVzaCA9IFtdLnB1c2g7XG52YXIgJFNQTElUID0gJ3NwbGl0JztcbnZhciBMRU5HVEggPSAnbGVuZ3RoJztcbnZhciBMQVNUX0lOREVYID0gJ2xhc3RJbmRleCc7XG52YXIgTUFYX1VJTlQzMiA9IDB4ZmZmZmZmZmY7XG5cbi8vIGJhYmVsLW1pbmlmeSB0cmFuc3BpbGVzIFJlZ0V4cCgneCcsICd5JykgLT4gL3gveSBhbmQgaXQgY2F1c2VzIFN5bnRheEVycm9yXG52YXIgU1VQUE9SVFNfWSA9ICFmYWlscyhmdW5jdGlvbiAoKSB7IFJlZ0V4cChNQVhfVUlOVDMyLCAneScpOyB9KTtcblxuLy8gQEBzcGxpdCBsb2dpY1xuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZml4LXJlLXdrcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZml4LXJlLXdrcy5qc1wiKSgnc3BsaXQnLCAyLCBmdW5jdGlvbiAoZGVmaW5lZCwgU1BMSVQsICRzcGxpdCwgbWF5YmVDYWxsTmF0aXZlKSB7XG4gIHZhciBpbnRlcm5hbFNwbGl0O1xuICBpZiAoXG4gICAgJ2FiYmMnWyRTUExJVF0oLyhiKSovKVsxXSA9PSAnYycgfHxcbiAgICAndGVzdCdbJFNQTElUXSgvKD86KS8sIC0xKVtMRU5HVEhdICE9IDQgfHxcbiAgICAnYWInWyRTUExJVF0oLyg/OmFiKSovKVtMRU5HVEhdICE9IDIgfHxcbiAgICAnLidbJFNQTElUXSgvKC4/KSguPykvKVtMRU5HVEhdICE9IDQgfHxcbiAgICAnLidbJFNQTElUXSgvKCkoKS8pW0xFTkdUSF0gPiAxIHx8XG4gICAgJydbJFNQTElUXSgvLj8vKVtMRU5HVEhdXG4gICkge1xuICAgIC8vIGJhc2VkIG9uIGVzNS1zaGltIGltcGxlbWVudGF0aW9uLCBuZWVkIHRvIHJld29yayBpdFxuICAgIGludGVybmFsU3BsaXQgPSBmdW5jdGlvbiAoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgdmFyIHN0cmluZyA9IFN0cmluZyh0aGlzKTtcbiAgICAgIGlmIChzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCAmJiBsaW1pdCA9PT0gMCkgcmV0dXJuIFtdO1xuICAgICAgLy8gSWYgYHNlcGFyYXRvcmAgaXMgbm90IGEgcmVnZXgsIHVzZSBuYXRpdmUgc3BsaXRcbiAgICAgIGlmICghaXNSZWdFeHAoc2VwYXJhdG9yKSkgcmV0dXJuICRzcGxpdC5jYWxsKHN0cmluZywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgICB2YXIgZmxhZ3MgPSAoc2VwYXJhdG9yLmlnbm9yZUNhc2UgPyAnaScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5tdWx0aWxpbmUgPyAnbScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci51bmljb2RlID8gJ3UnIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3Iuc3RpY2t5ID8gJ3knIDogJycpO1xuICAgICAgdmFyIGxhc3RMYXN0SW5kZXggPSAwO1xuICAgICAgdmFyIHNwbGl0TGltaXQgPSBsaW1pdCA9PT0gdW5kZWZpbmVkID8gTUFYX1VJTlQzMiA6IGxpbWl0ID4+PiAwO1xuICAgICAgLy8gTWFrZSBgZ2xvYmFsYCBhbmQgYXZvaWQgYGxhc3RJbmRleGAgaXNzdWVzIGJ5IHdvcmtpbmcgd2l0aCBhIGNvcHlcbiAgICAgIHZhciBzZXBhcmF0b3JDb3B5ID0gbmV3IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCBmbGFncyArICdnJyk7XG4gICAgICB2YXIgbWF0Y2gsIGxhc3RJbmRleCwgbGFzdExlbmd0aDtcbiAgICAgIHdoaWxlIChtYXRjaCA9IHJlZ2V4cEV4ZWMuY2FsbChzZXBhcmF0b3JDb3B5LCBzdHJpbmcpKSB7XG4gICAgICAgIGxhc3RJbmRleCA9IHNlcGFyYXRvckNvcHlbTEFTVF9JTkRFWF07XG4gICAgICAgIGlmIChsYXN0SW5kZXggPiBsYXN0TGFzdEluZGV4KSB7XG4gICAgICAgICAgb3V0cHV0LnB1c2goc3RyaW5nLnNsaWNlKGxhc3RMYXN0SW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgICAgICAgaWYgKG1hdGNoW0xFTkdUSF0gPiAxICYmIG1hdGNoLmluZGV4IDwgc3RyaW5nW0xFTkdUSF0pICRwdXNoLmFwcGx5KG91dHB1dCwgbWF0Y2guc2xpY2UoMSkpO1xuICAgICAgICAgIGxhc3RMZW5ndGggPSBtYXRjaFswXVtMRU5HVEhdO1xuICAgICAgICAgIGxhc3RMYXN0SW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgICAgaWYgKG91dHB1dFtMRU5HVEhdID49IHNwbGl0TGltaXQpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXBhcmF0b3JDb3B5W0xBU1RfSU5ERVhdID09PSBtYXRjaC5pbmRleCkgc2VwYXJhdG9yQ29weVtMQVNUX0lOREVYXSsrOyAvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wXG4gICAgICB9XG4gICAgICBpZiAobGFzdExhc3RJbmRleCA9PT0gc3RyaW5nW0xFTkdUSF0pIHtcbiAgICAgICAgaWYgKGxhc3RMZW5ndGggfHwgIXNlcGFyYXRvckNvcHkudGVzdCgnJykpIG91dHB1dC5wdXNoKCcnKTtcbiAgICAgIH0gZWxzZSBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCkpO1xuICAgICAgcmV0dXJuIG91dHB1dFtMRU5HVEhdID4gc3BsaXRMaW1pdCA/IG91dHB1dC5zbGljZSgwLCBzcGxpdExpbWl0KSA6IG91dHB1dDtcbiAgICB9O1xuICAvLyBDaGFrcmEsIFY4XG4gIH0gZWxzZSBpZiAoJzAnWyRTUExJVF0odW5kZWZpbmVkLCAwKVtMRU5HVEhdKSB7XG4gICAgaW50ZXJuYWxTcGxpdCA9IGZ1bmN0aW9uIChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICByZXR1cm4gc2VwYXJhdG9yID09PSB1bmRlZmluZWQgJiYgbGltaXQgPT09IDAgPyBbXSA6ICRzcGxpdC5jYWxsKHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgaW50ZXJuYWxTcGxpdCA9ICRzcGxpdDtcbiAgfVxuXG4gIHJldHVybiBbXG4gICAgLy8gYFN0cmluZy5wcm90b3R5cGUuc3BsaXRgIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuc3BsaXRcbiAgICBmdW5jdGlvbiBzcGxpdChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICB2YXIgTyA9IGRlZmluZWQodGhpcyk7XG4gICAgICB2YXIgc3BsaXR0ZXIgPSBzZXBhcmF0b3IgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogc2VwYXJhdG9yW1NQTElUXTtcbiAgICAgIHJldHVybiBzcGxpdHRlciAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gc3BsaXR0ZXIuY2FsbChzZXBhcmF0b3IsIE8sIGxpbWl0KVxuICAgICAgICA6IGludGVybmFsU3BsaXQuY2FsbChTdHJpbmcoTyksIHNlcGFyYXRvciwgbGltaXQpO1xuICAgIH0sXG4gICAgLy8gYFJlZ0V4cC5wcm90b3R5cGVbQEBzcGxpdF1gIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUtQEBzcGxpdFxuICAgIC8vXG4gICAgLy8gTk9URTogVGhpcyBjYW5ub3QgYmUgcHJvcGVybHkgcG9seWZpbGxlZCBpbiBlbmdpbmVzIHRoYXQgZG9uJ3Qgc3VwcG9ydFxuICAgIC8vIHRoZSAneScgZmxhZy5cbiAgICBmdW5jdGlvbiAocmVnZXhwLCBsaW1pdCkge1xuICAgICAgdmFyIHJlcyA9IG1heWJlQ2FsbE5hdGl2ZShpbnRlcm5hbFNwbGl0LCByZWdleHAsIHRoaXMsIGxpbWl0LCBpbnRlcm5hbFNwbGl0ICE9PSAkc3BsaXQpO1xuICAgICAgaWYgKHJlcy5kb25lKSByZXR1cm4gcmVzLnZhbHVlO1xuXG4gICAgICB2YXIgcnggPSBhbk9iamVjdChyZWdleHApO1xuICAgICAgdmFyIFMgPSBTdHJpbmcodGhpcyk7XG4gICAgICB2YXIgQyA9IHNwZWNpZXNDb25zdHJ1Y3RvcihyeCwgUmVnRXhwKTtcblxuICAgICAgdmFyIHVuaWNvZGVNYXRjaGluZyA9IHJ4LnVuaWNvZGU7XG4gICAgICB2YXIgZmxhZ3MgPSAocnguaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocngubXVsdGlsaW5lID8gJ20nIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyeC51bmljb2RlID8gJ3UnIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChTVVBQT1JUU19ZID8gJ3knIDogJ2cnKTtcblxuICAgICAgLy8gXig/ICsgcnggKyApIGlzIG5lZWRlZCwgaW4gY29tYmluYXRpb24gd2l0aCBzb21lIFMgc2xpY2luZywgdG9cbiAgICAgIC8vIHNpbXVsYXRlIHRoZSAneScgZmxhZy5cbiAgICAgIHZhciBzcGxpdHRlciA9IG5ldyBDKFNVUFBPUlRTX1kgPyByeCA6ICdeKD86JyArIHJ4LnNvdXJjZSArICcpJywgZmxhZ3MpO1xuICAgICAgdmFyIGxpbSA9IGxpbWl0ID09PSB1bmRlZmluZWQgPyBNQVhfVUlOVDMyIDogbGltaXQgPj4+IDA7XG4gICAgICBpZiAobGltID09PSAwKSByZXR1cm4gW107XG4gICAgICBpZiAoUy5sZW5ndGggPT09IDApIHJldHVybiBjYWxsUmVnRXhwRXhlYyhzcGxpdHRlciwgUykgPT09IG51bGwgPyBbU10gOiBbXTtcbiAgICAgIHZhciBwID0gMDtcbiAgICAgIHZhciBxID0gMDtcbiAgICAgIHZhciBBID0gW107XG4gICAgICB3aGlsZSAocSA8IFMubGVuZ3RoKSB7XG4gICAgICAgIHNwbGl0dGVyLmxhc3RJbmRleCA9IFNVUFBPUlRTX1kgPyBxIDogMDtcbiAgICAgICAgdmFyIHogPSBjYWxsUmVnRXhwRXhlYyhzcGxpdHRlciwgU1VQUE9SVFNfWSA/IFMgOiBTLnNsaWNlKHEpKTtcbiAgICAgICAgdmFyIGU7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB6ID09PSBudWxsIHx8XG4gICAgICAgICAgKGUgPSAkbWluKHRvTGVuZ3RoKHNwbGl0dGVyLmxhc3RJbmRleCArIChTVVBQT1JUU19ZID8gMCA6IHEpKSwgUy5sZW5ndGgpKSA9PT0gcFxuICAgICAgICApIHtcbiAgICAgICAgICBxID0gYWR2YW5jZVN0cmluZ0luZGV4KFMsIHEsIHVuaWNvZGVNYXRjaGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgQS5wdXNoKFMuc2xpY2UocCwgcSkpO1xuICAgICAgICAgIGlmIChBLmxlbmd0aCA9PT0gbGltKSByZXR1cm4gQTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSB6Lmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgQS5wdXNoKHpbaV0pO1xuICAgICAgICAgICAgaWYgKEEubGVuZ3RoID09PSBsaW0pIHJldHVybiBBO1xuICAgICAgICAgIH1cbiAgICAgICAgICBxID0gcCA9IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIEEucHVzaChTLnNsaWNlKHApKTtcbiAgICAgIHJldHVybiBBO1xuICAgIH1cbiAgXTtcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmluY2x1ZGVzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmluY2x1ZGVzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLy8gMjEuMS4zLjcgU3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlcyhzZWFyY2hTdHJpbmcsIHBvc2l0aW9uID0gMClcblxudmFyICRleHBvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19leHBvcnQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2V4cG9ydC5qc1wiKTtcbnZhciBjb250ZXh0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fc3RyaW5nLWNvbnRleHQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy1jb250ZXh0LmpzXCIpO1xudmFyIElOQ0xVREVTID0gJ2luY2x1ZGVzJztcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19mYWlscy1pcy1yZWdleHAgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLWlzLXJlZ2V4cC5qc1wiKShJTkNMVURFUyksICdTdHJpbmcnLCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhzZWFyY2hTdHJpbmcgLyogLCBwb3NpdGlvbiA9IDAgKi8pIHtcbiAgICByZXR1cm4gISF+Y29udGV4dCh0aGlzLCBzZWFyY2hTdHJpbmcsIElOQ0xVREVTKVxuICAgICAgLmluZGV4T2Yoc2VhcmNoU3RyaW5nLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3ltYm9sLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3ltYm9sLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vLyBFQ01BU2NyaXB0IDYgc3ltYm9scyBzaGltXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZ2xvYmFsICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanNcIik7XG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faGFzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oYXMuanNcIik7XG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19kZXNjcmlwdG9ycyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanNcIik7XG52YXIgJGV4cG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2V4cG9ydCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZXhwb3J0LmpzXCIpO1xudmFyIHJlZGVmaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fcmVkZWZpbmUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLmpzXCIpO1xudmFyIE1FVEEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19tZXRhICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19tZXRhLmpzXCIpLktFWTtcbnZhciAkZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19mYWlscyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZmFpbHMuanNcIik7XG52YXIgc2hhcmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fc2hhcmVkICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zaGFyZWQuanNcIik7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19zZXQtdG8tc3RyaW5nLXRhZyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanNcIik7XG52YXIgdWlkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fdWlkICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL191aWQuanNcIik7XG52YXIgd2tzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fd2tzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MuanNcIik7XG52YXIgd2tzRXh0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fd2tzLWV4dCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLWV4dC5qc1wiKTtcbnZhciB3a3NEZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL193a3MtZGVmaW5lICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MtZGVmaW5lLmpzXCIpO1xudmFyIGVudW1LZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZW51bS1rZXlzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19lbnVtLWtleXMuanNcIik7XG52YXIgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2lzLWFycmF5ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1hcnJheS5qc1wiKTtcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2FuLW9iamVjdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYW4tb2JqZWN0LmpzXCIpO1xudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faXMtb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1vYmplY3QuanNcIik7XG52YXIgdG9PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL190by1vYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLW9iamVjdC5qc1wiKTtcbnZhciB0b0lPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL190by1pb2JqZWN0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pb2JqZWN0LmpzXCIpO1xudmFyIHRvUHJpbWl0aXZlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fdG8tcHJpbWl0aXZlICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1wcmltaXRpdmUuanNcIik7XG52YXIgY3JlYXRlRGVzYyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3Byb3BlcnR5LWRlc2MgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanNcIik7XG52YXIgX2NyZWF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX29iamVjdC1jcmVhdGUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1jcmVhdGUuanNcIik7XG52YXIgZ09QTkV4dCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX29iamVjdC1nb3BuLWV4dCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcG4tZXh0LmpzXCIpO1xudmFyICRHT1BEID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fb2JqZWN0LWdvcGQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BkLmpzXCIpO1xudmFyICRHT1BTID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fb2JqZWN0LWdvcHMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BzLmpzXCIpO1xudmFyICREUCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX29iamVjdC1kcCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWRwLmpzXCIpO1xudmFyICRrZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fb2JqZWN0LWtleXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLmpzXCIpO1xudmFyIGdPUEQgPSAkR09QRC5mO1xudmFyIGRQID0gJERQLmY7XG52YXIgZ09QTiA9IGdPUE5FeHQuZjtcbnZhciAkU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciAkSlNPTiA9IGdsb2JhbC5KU09OO1xudmFyIF9zdHJpbmdpZnkgPSAkSlNPTiAmJiAkSlNPTi5zdHJpbmdpZnk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgSElEREVOID0gd2tzKCdfaGlkZGVuJyk7XG52YXIgVE9fUFJJTUlUSVZFID0gd2tzKCd0b1ByaW1pdGl2ZScpO1xudmFyIGlzRW51bSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKTtcbnZhciBBbGxTeW1ib2xzID0gc2hhcmVkKCdzeW1ib2xzJyk7XG52YXIgT1BTeW1ib2xzID0gc2hhcmVkKCdvcC1zeW1ib2xzJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3RbUFJPVE9UWVBFXTtcbnZhciBVU0VfTkFUSVZFID0gdHlwZW9mICRTeW1ib2wgPT0gJ2Z1bmN0aW9uJyAmJiAhISRHT1BTLmY7XG52YXIgUU9iamVjdCA9IGdsb2JhbC5RT2JqZWN0O1xuLy8gRG9uJ3QgdXNlIHNldHRlcnMgaW4gUXQgU2NyaXB0LCBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTczXG52YXIgc2V0dGVyID0gIVFPYmplY3QgfHwgIVFPYmplY3RbUFJPVE9UWVBFXSB8fCAhUU9iamVjdFtQUk9UT1RZUEVdLmZpbmRDaGlsZDtcblxuLy8gZmFsbGJhY2sgZm9yIG9sZCBBbmRyb2lkLCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9Njg3XG52YXIgc2V0U3ltYm9sRGVzYyA9IERFU0NSSVBUT1JTICYmICRmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBfY3JlYXRlKGRQKHt9LCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRQKHRoaXMsICdhJywgeyB2YWx1ZTogNyB9KS5hOyB9XG4gIH0pKS5hICE9IDc7XG59KSA/IGZ1bmN0aW9uIChpdCwga2V5LCBEKSB7XG4gIHZhciBwcm90b0Rlc2MgPSBnT1BEKE9iamVjdFByb3RvLCBrZXkpO1xuICBpZiAocHJvdG9EZXNjKSBkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcbiAgZFAoaXQsIGtleSwgRCk7XG4gIGlmIChwcm90b0Rlc2MgJiYgaXQgIT09IE9iamVjdFByb3RvKSBkUChPYmplY3RQcm90bywga2V5LCBwcm90b0Rlc2MpO1xufSA6IGRQO1xuXG52YXIgd3JhcCA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgdmFyIHN5bSA9IEFsbFN5bWJvbHNbdGFnXSA9IF9jcmVhdGUoJFN5bWJvbFtQUk9UT1RZUEVdKTtcbiAgc3ltLl9rID0gdGFnO1xuICByZXR1cm4gc3ltO1xufTtcblxudmFyIGlzU3ltYm9sID0gVVNFX05BVElWRSAmJiB0eXBlb2YgJFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJyA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgaW5zdGFuY2VvZiAkU3ltYm9sO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIEQpIHtcbiAgaWYgKGl0ID09PSBPYmplY3RQcm90bykgJGRlZmluZVByb3BlcnR5KE9QU3ltYm9scywga2V5LCBEKTtcbiAgYW5PYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBhbk9iamVjdChEKTtcbiAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkpKSB7XG4gICAgaWYgKCFELmVudW1lcmFibGUpIHtcbiAgICAgIGlmICghaGFzKGl0LCBISURERU4pKSBkUChpdCwgSElEREVOLCBjcmVhdGVEZXNjKDEsIHt9KSk7XG4gICAgICBpdFtISURERU5dW2tleV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkgaXRbSElEREVOXVtrZXldID0gZmFsc2U7XG4gICAgICBEID0gX2NyZWF0ZShELCB7IGVudW1lcmFibGU6IGNyZWF0ZURlc2MoMCwgZmFsc2UpIH0pO1xuICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2MoaXQsIGtleSwgRCk7XG4gIH0gcmV0dXJuIGRQKGl0LCBrZXksIEQpO1xufTtcbnZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoaXQsIFApIHtcbiAgYW5PYmplY3QoaXQpO1xuICB2YXIga2V5cyA9IGVudW1LZXlzKFAgPSB0b0lPYmplY3QoUCkpO1xuICB2YXIgaSA9IDA7XG4gIHZhciBsID0ga2V5cy5sZW5ndGg7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChsID4gaSkgJGRlZmluZVByb3BlcnR5KGl0LCBrZXkgPSBrZXlzW2krK10sIFBba2V5XSk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpdCwgUCkge1xuICByZXR1cm4gUCA9PT0gdW5kZWZpbmVkID8gX2NyZWF0ZShpdCkgOiAkZGVmaW5lUHJvcGVydGllcyhfY3JlYXRlKGl0KSwgUCk7XG59O1xudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKGtleSkge1xuICB2YXIgRSA9IGlzRW51bS5jYWxsKHRoaXMsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpO1xuICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIEUgfHwgIWhhcyh0aGlzLCBrZXkpIHx8ICFoYXMoQWxsU3ltYm9scywga2V5KSB8fCBoYXModGhpcywgSElEREVOKSAmJiB0aGlzW0hJRERFTl1ba2V5XSA/IEUgOiB0cnVlO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpIHtcbiAgaXQgPSB0b0lPYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKSByZXR1cm47XG4gIHZhciBEID0gZ09QRChpdCwga2V5KTtcbiAgaWYgKEQgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSkgRC5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgcmV0dXJuIEQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuICB2YXIgbmFtZXMgPSBnT1BOKHRvSU9iamVjdChpdCkpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBpID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIHtcbiAgICBpZiAoIWhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiBrZXkgIT0gSElEREVOICYmIGtleSAhPSBNRVRBKSByZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpIHtcbiAgdmFyIElTX09QID0gaXQgPT09IE9iamVjdFByb3RvO1xuICB2YXIgbmFtZXMgPSBnT1BOKElTX09QID8gT1BTeW1ib2xzIDogdG9JT2JqZWN0KGl0KSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkge1xuICAgIGlmIChoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYgKElTX09QID8gaGFzKE9iamVjdFByb3RvLCBrZXkpIDogdHJ1ZSkpIHJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxuaWYgKCFVU0VfTkFUSVZFKSB7XG4gICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiAkU3ltYm9sKSB0aHJvdyBUeXBlRXJyb3IoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvciEnKTtcbiAgICB2YXIgdGFnID0gdWlkKGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgICB2YXIgJHNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvKSAkc2V0LmNhbGwoT1BTeW1ib2xzLCB2YWx1ZSk7XG4gICAgICBpZiAoaGFzKHRoaXMsIEhJRERFTikgJiYgaGFzKHRoaXNbSElEREVOXSwgdGFnKSkgdGhpc1tISURERU5dW3RhZ10gPSBmYWxzZTtcbiAgICAgIHNldFN5bWJvbERlc2ModGhpcywgdGFnLCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG4gICAgfTtcbiAgICBpZiAoREVTQ1JJUFRPUlMgJiYgc2V0dGVyKSBzZXRTeW1ib2xEZXNjKE9iamVjdFByb3RvLCB0YWcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6ICRzZXQgfSk7XG4gICAgcmV0dXJuIHdyYXAodGFnKTtcbiAgfTtcbiAgcmVkZWZpbmUoJFN5bWJvbFtQUk9UT1RZUEVdLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5faztcbiAgfSk7XG5cbiAgJEdPUEQuZiA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICREUC5mID0gJGRlZmluZVByb3BlcnR5O1xuICBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19vYmplY3QtZ29wbiAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcG4uanNcIikuZiA9IGdPUE5FeHQuZiA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuICBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19vYmplY3QtcGllICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtcGllLmpzXCIpLmYgPSAkcHJvcGVydHlJc0VudW1lcmFibGU7XG4gICRHT1BTLmYgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4gIGlmIChERVNDUklQVE9SUyAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fbGlicmFyeSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fbGlicmFyeS5qc1wiKSkge1xuICAgIHJlZGVmaW5lKE9iamVjdFByb3RvLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHRydWUpO1xuICB9XG5cbiAgd2tzRXh0LmYgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiB3cmFwKHdrcyhuYW1lKSk7XG4gIH07XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHsgU3ltYm9sOiAkU3ltYm9sIH0pO1xuXG5mb3IgKHZhciBlczZTeW1ib2xzID0gKFxuICAvLyAxOS40LjIuMiwgMTkuNC4yLjMsIDE5LjQuMi40LCAxOS40LjIuNiwgMTkuNC4yLjgsIDE5LjQuMi45LCAxOS40LjIuMTAsIDE5LjQuMi4xMSwgMTkuNC4yLjEyLCAxOS40LjIuMTMsIDE5LjQuMi4xNFxuICAnaGFzSW5zdGFuY2UsaXNDb25jYXRTcHJlYWRhYmxlLGl0ZXJhdG9yLG1hdGNoLHJlcGxhY2Usc2VhcmNoLHNwZWNpZXMsc3BsaXQsdG9QcmltaXRpdmUsdG9TdHJpbmdUYWcsdW5zY29wYWJsZXMnXG4pLnNwbGl0KCcsJyksIGogPSAwOyBlczZTeW1ib2xzLmxlbmd0aCA+IGo7KXdrcyhlczZTeW1ib2xzW2orK10pO1xuXG5mb3IgKHZhciB3ZWxsS25vd25TeW1ib2xzID0gJGtleXMod2tzLnN0b3JlKSwgayA9IDA7IHdlbGxLbm93blN5bWJvbHMubGVuZ3RoID4gazspIHdrc0RlZmluZSh3ZWxsS25vd25TeW1ib2xzW2srK10pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnU3ltYm9sJywge1xuICAvLyAxOS40LjIuMSBTeW1ib2wuZm9yKGtleSlcbiAgJ2Zvcic6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gaGFzKFN5bWJvbFJlZ2lzdHJ5LCBrZXkgKz0gJycpXG4gICAgICA/IFN5bWJvbFJlZ2lzdHJ5W2tleV1cbiAgICAgIDogU3ltYm9sUmVnaXN0cnlba2V5XSA9ICRTeW1ib2woa2V5KTtcbiAgfSxcbiAgLy8gMTkuNC4yLjUgU3ltYm9sLmtleUZvcihzeW0pXG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKHN5bSkge1xuICAgIGlmICghaXNTeW1ib2woc3ltKSkgdGhyb3cgVHlwZUVycm9yKHN5bSArICcgaXMgbm90IGEgc3ltYm9sIScpO1xuICAgIGZvciAodmFyIGtleSBpbiBTeW1ib2xSZWdpc3RyeSkgaWYgKFN5bWJvbFJlZ2lzdHJ5W2tleV0gPT09IHN5bSkgcmV0dXJuIGtleTtcbiAgfSxcbiAgdXNlU2V0dGVyOiBmdW5jdGlvbiAoKSB7IHNldHRlciA9IHRydWU7IH0sXG4gIHVzZVNpbXBsZTogZnVuY3Rpb24gKCkgeyBzZXR0ZXIgPSBmYWxzZTsgfVxufSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdPYmplY3QnLCB7XG4gIC8vIDE5LjEuMi4yIE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gMTkuMS4yLjMgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsXG4gIC8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiAkZ2V0T3duUHJvcGVydHlOYW1lcyxcbiAgLy8gMTkuMS4yLjggT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKVxuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pO1xuXG4vLyBDaHJvbWUgMzggYW5kIDM5IGBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzYCBmYWlscyBvbiBwcmltaXRpdmVzXG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zNDQzXG52YXIgRkFJTFNfT05fUFJJTUlUSVZFUyA9ICRmYWlscyhmdW5jdGlvbiAoKSB7ICRHT1BTLmYoMSk7IH0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIEZBSUxTX09OX1BSSU1JVElWRVMsICdPYmplY3QnLCB7XG4gIGdldE93blByb3BlcnR5U3ltYm9sczogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSB7XG4gICAgcmV0dXJuICRHT1BTLmYodG9PYmplY3QoaXQpKTtcbiAgfVxufSk7XG5cbi8vIDI0LjMuMiBKU09OLnN0cmluZ2lmeSh2YWx1ZSBbLCByZXBsYWNlciBbLCBzcGFjZV1dKVxuJEpTT04gJiYgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoIVVTRV9OQVRJVkUgfHwgJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIFMgPSAkU3ltYm9sKCk7XG4gIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG4gIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICByZXR1cm4gX3N0cmluZ2lmeShbU10pICE9ICdbbnVsbF0nIHx8IF9zdHJpbmdpZnkoeyBhOiBTIH0pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG59KSksICdKU09OJywge1xuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCkge1xuICAgIHZhciBhcmdzID0gW2l0XTtcbiAgICB2YXIgaSA9IDE7XG4gICAgdmFyIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG4gICAgd2hpbGUgKGFyZ3VtZW50cy5sZW5ndGggPiBpKSBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgICRyZXBsYWNlciA9IHJlcGxhY2VyID0gYXJnc1sxXTtcbiAgICBpZiAoIWlzT2JqZWN0KHJlcGxhY2VyKSAmJiBpdCA9PT0gdW5kZWZpbmVkIHx8IGlzU3ltYm9sKGl0KSkgcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gICAgaWYgKCFpc0FycmF5KHJlcGxhY2VyKSkgcmVwbGFjZXIgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiAkcmVwbGFjZXIgPT0gJ2Z1bmN0aW9uJykgdmFsdWUgPSAkcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIGlmICghaXNTeW1ib2wodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBhcmdzWzFdID0gcmVwbGFjZXI7XG4gICAgcmV0dXJuIF9zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3MpO1xuICB9XG59KTtcblxuLy8gMTkuNC4zLjQgU3ltYm9sLnByb3RvdHlwZVtAQHRvUHJpbWl0aXZlXShoaW50KVxuJFN5bWJvbFtQUk9UT1RZUEVdW1RPX1BSSU1JVElWRV0gfHwgX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faGlkZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGlkZS5qc1wiKSgkU3ltYm9sW1BST1RPVFlQRV0sIFRPX1BSSU1JVElWRSwgJFN5bWJvbFtQUk9UT1RZUEVdLnZhbHVlT2YpO1xuLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoJFN5bWJvbCwgJ1N5bWJvbCcpO1xuLy8gMjAuMi4xLjkgTWF0aFtAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoTWF0aCwgJ01hdGgnLCB0cnVlKTtcbi8vIDI0LjMuMyBKU09OW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhnbG9iYWwuSlNPTiwgJ0pTT04nLCB0cnVlKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LmFycmF5LmluY2x1ZGVzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5hcnJheS5pbmNsdWRlcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9BcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcbnZhciAkZXhwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZXhwb3J0ICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19leHBvcnQuanNcIik7XG52YXIgJGluY2x1ZGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYXJyYXktaW5jbHVkZXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzXCIpKHRydWUpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCwgJ0FycmF5Jywge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoZWwgLyogLCBmcm9tSW5kZXggPSAwICovKSB7XG4gICAgcmV0dXJuICRpbmNsdWRlcyh0aGlzLCBlbCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fYWRkLXRvLXVuc2NvcGFibGVzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanNcIikoJ2luY2x1ZGVzJyk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcnMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yc1xudmFyICRleHBvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19leHBvcnQgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2V4cG9ydC5qc1wiKTtcbnZhciBvd25LZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fb3duLWtleXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX293bi1rZXlzLmpzXCIpO1xudmFyIHRvSU9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX3RvLWlvYmplY3QgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWlvYmplY3QuanNcIik7XG52YXIgZ09QRCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX29iamVjdC1nb3BkICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wZC5qc1wiKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2NyZWF0ZS1wcm9wZXJ0eSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY3JlYXRlLXByb3BlcnR5LmpzXCIpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yczogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmplY3QpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdChvYmplY3QpO1xuICAgIHZhciBnZXREZXNjID0gZ09QRC5mO1xuICAgIHZhciBrZXlzID0gb3duS2V5cyhPKTtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBrZXksIGRlc2M7XG4gICAgd2hpbGUgKGtleXMubGVuZ3RoID4gaSkge1xuICAgICAgZGVzYyA9IGdldERlc2MoTywga2V5ID0ga2V5c1tpKytdKTtcbiAgICAgIGlmIChkZXNjICE9PSB1bmRlZmluZWQpIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwga2V5LCBkZXNjKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fd2tzLWRlZmluZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fd2tzLWRlZmluZS5qc1wiKSgnYXN5bmNJdGVyYXRvcicpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciAkaXRlcmF0b3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9lczYuYXJyYXkuaXRlcmF0b3IgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzXCIpO1xudmFyIGdldEtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19vYmplY3Qta2V5cyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMuanNcIik7XG52YXIgcmVkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL19yZWRlZmluZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUuanNcIik7XG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fZ2xvYmFsICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanNcIik7XG52YXIgaGlkZSA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vX2hpZGUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2hpZGUuanNcIik7XG52YXIgSXRlcmF0b3JzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9faXRlcmF0b3JzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyYXRvcnMuanNcIik7XG52YXIgd2tzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9fd2tzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MuanNcIik7XG52YXIgSVRFUkFUT1IgPSB3a3MoJ2l0ZXJhdG9yJyk7XG52YXIgVE9fU1RSSU5HX1RBRyA9IHdrcygndG9TdHJpbmdUYWcnKTtcbnZhciBBcnJheVZhbHVlcyA9IEl0ZXJhdG9ycy5BcnJheTtcblxudmFyIERPTUl0ZXJhYmxlcyA9IHtcbiAgQ1NTUnVsZUxpc3Q6IHRydWUsIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBDU1NTdHlsZURlY2xhcmF0aW9uOiBmYWxzZSxcbiAgQ1NTVmFsdWVMaXN0OiBmYWxzZSxcbiAgQ2xpZW50UmVjdExpc3Q6IGZhbHNlLFxuICBET01SZWN0TGlzdDogZmFsc2UsXG4gIERPTVN0cmluZ0xpc3Q6IGZhbHNlLFxuICBET01Ub2tlbkxpc3Q6IHRydWUsXG4gIERhdGFUcmFuc2Zlckl0ZW1MaXN0OiBmYWxzZSxcbiAgRmlsZUxpc3Q6IGZhbHNlLFxuICBIVE1MQWxsQ29sbGVjdGlvbjogZmFsc2UsXG4gIEhUTUxDb2xsZWN0aW9uOiBmYWxzZSxcbiAgSFRNTEZvcm1FbGVtZW50OiBmYWxzZSxcbiAgSFRNTFNlbGVjdEVsZW1lbnQ6IGZhbHNlLFxuICBNZWRpYUxpc3Q6IHRydWUsIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBNaW1lVHlwZUFycmF5OiBmYWxzZSxcbiAgTmFtZWROb2RlTWFwOiBmYWxzZSxcbiAgTm9kZUxpc3Q6IHRydWUsXG4gIFBhaW50UmVxdWVzdExpc3Q6IGZhbHNlLFxuICBQbHVnaW46IGZhbHNlLFxuICBQbHVnaW5BcnJheTogZmFsc2UsXG4gIFNWR0xlbmd0aExpc3Q6IGZhbHNlLFxuICBTVkdOdW1iZXJMaXN0OiBmYWxzZSxcbiAgU1ZHUGF0aFNlZ0xpc3Q6IGZhbHNlLFxuICBTVkdQb2ludExpc3Q6IGZhbHNlLFxuICBTVkdTdHJpbmdMaXN0OiBmYWxzZSxcbiAgU1ZHVHJhbnNmb3JtTGlzdDogZmFsc2UsXG4gIFNvdXJjZUJ1ZmZlckxpc3Q6IGZhbHNlLFxuICBTdHlsZVNoZWV0TGlzdDogdHJ1ZSwgLy8gVE9ETzogTm90IHNwZWMgY29tcGxpYW50LCBzaG91bGQgYmUgZmFsc2UuXG4gIFRleHRUcmFja0N1ZUxpc3Q6IGZhbHNlLFxuICBUZXh0VHJhY2tMaXN0OiBmYWxzZSxcbiAgVG91Y2hMaXN0OiBmYWxzZVxufTtcblxuZm9yICh2YXIgY29sbGVjdGlvbnMgPSBnZXRLZXlzKERPTUl0ZXJhYmxlcyksIGkgPSAwOyBpIDwgY29sbGVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgdmFyIE5BTUUgPSBjb2xsZWN0aW9uc1tpXTtcbiAgdmFyIGV4cGxpY2l0ID0gRE9NSXRlcmFibGVzW05BTUVdO1xuICB2YXIgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXTtcbiAgdmFyIHByb3RvID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgdmFyIGtleTtcbiAgaWYgKHByb3RvKSB7XG4gICAgaWYgKCFwcm90b1tJVEVSQVRPUl0pIGhpZGUocHJvdG8sIElURVJBVE9SLCBBcnJheVZhbHVlcyk7XG4gICAgaWYgKCFwcm90b1tUT19TVFJJTkdfVEFHXSkgaGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7XG4gICAgSXRlcmF0b3JzW05BTUVdID0gQXJyYXlWYWx1ZXM7XG4gICAgaWYgKGV4cGxpY2l0KSBmb3IgKGtleSBpbiAkaXRlcmF0b3JzKSBpZiAoIXByb3RvW2tleV0pIHJlZGVmaW5lKHByb3RvLCBrZXksICRpdGVyYXRvcnNba2V5XSwgdHJ1ZSk7XG4gIH1cbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9jcnlwdC9jcnlwdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9jcnlwdC9jcnlwdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBiYXNlNjRtYXBcbiAgICAgID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nLFxuXG4gIGNyeXB0ID0ge1xuICAgIC8vIEJpdC13aXNlIHJvdGF0aW9uIGxlZnRcbiAgICByb3RsOiBmdW5jdGlvbihuLCBiKSB7XG4gICAgICByZXR1cm4gKG4gPDwgYikgfCAobiA+Pj4gKDMyIC0gYikpO1xuICAgIH0sXG5cbiAgICAvLyBCaXQtd2lzZSByb3RhdGlvbiByaWdodFxuICAgIHJvdHI6IGZ1bmN0aW9uKG4sIGIpIHtcbiAgICAgIHJldHVybiAobiA8PCAoMzIgLSBiKSkgfCAobiA+Pj4gYik7XG4gICAgfSxcblxuICAgIC8vIFN3YXAgYmlnLWVuZGlhbiB0byBsaXR0bGUtZW5kaWFuIGFuZCB2aWNlIHZlcnNhXG4gICAgZW5kaWFuOiBmdW5jdGlvbihuKSB7XG4gICAgICAvLyBJZiBudW1iZXIgZ2l2ZW4sIHN3YXAgZW5kaWFuXG4gICAgICBpZiAobi5jb25zdHJ1Y3RvciA9PSBOdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0LnJvdGwobiwgOCkgJiAweDAwRkYwMEZGIHwgY3J5cHQucm90bChuLCAyNCkgJiAweEZGMDBGRjAwO1xuICAgICAgfVxuXG4gICAgICAvLyBFbHNlLCBhc3N1bWUgYXJyYXkgYW5kIHN3YXAgYWxsIGl0ZW1zXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG4ubGVuZ3RoOyBpKyspXG4gICAgICAgIG5baV0gPSBjcnlwdC5lbmRpYW4obltpXSk7XG4gICAgICByZXR1cm4gbjtcbiAgICB9LFxuXG4gICAgLy8gR2VuZXJhdGUgYW4gYXJyYXkgb2YgYW55IGxlbmd0aCBvZiByYW5kb20gYnl0ZXNcbiAgICByYW5kb21CeXRlczogZnVuY3Rpb24obikge1xuICAgICAgZm9yICh2YXIgYnl0ZXMgPSBbXTsgbiA+IDA7IG4tLSlcbiAgICAgICAgYnl0ZXMucHVzaChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyNTYpKTtcbiAgICAgIHJldHVybiBieXRlcztcbiAgICB9LFxuXG4gICAgLy8gQ29udmVydCBhIGJ5dGUgYXJyYXkgdG8gYmlnLWVuZGlhbiAzMi1iaXQgd29yZHNcbiAgICBieXRlc1RvV29yZHM6IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICBmb3IgKHZhciB3b3JkcyA9IFtdLCBpID0gMCwgYiA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKywgYiArPSA4KVxuICAgICAgICB3b3Jkc1tiID4+PiA1XSB8PSBieXRlc1tpXSA8PCAoMjQgLSBiICUgMzIpO1xuICAgICAgcmV0dXJuIHdvcmRzO1xuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGJpZy1lbmRpYW4gMzItYml0IHdvcmRzIHRvIGEgYnl0ZSBhcnJheVxuICAgIHdvcmRzVG9CeXRlczogZnVuY3Rpb24od29yZHMpIHtcbiAgICAgIGZvciAodmFyIGJ5dGVzID0gW10sIGIgPSAwOyBiIDwgd29yZHMubGVuZ3RoICogMzI7IGIgKz0gOClcbiAgICAgICAgYnl0ZXMucHVzaCgod29yZHNbYiA+Pj4gNV0gPj4+ICgyNCAtIGIgJSAzMikpICYgMHhGRik7XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnQgYSBieXRlIGFycmF5IHRvIGEgaGV4IHN0cmluZ1xuICAgIGJ5dGVzVG9IZXg6IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICBmb3IgKHZhciBoZXggPSBbXSwgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXgucHVzaCgoYnl0ZXNbaV0gPj4+IDQpLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIGhleC5wdXNoKChieXRlc1tpXSAmIDB4RikudG9TdHJpbmcoMTYpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoZXguam9pbignJyk7XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnQgYSBoZXggc3RyaW5nIHRvIGEgYnl0ZSBhcnJheVxuICAgIGhleFRvQnl0ZXM6IGZ1bmN0aW9uKGhleCkge1xuICAgICAgZm9yICh2YXIgYnl0ZXMgPSBbXSwgYyA9IDA7IGMgPCBoZXgubGVuZ3RoOyBjICs9IDIpXG4gICAgICAgIGJ5dGVzLnB1c2gocGFyc2VJbnQoaGV4LnN1YnN0cihjLCAyKSwgMTYpKTtcbiAgICAgIHJldHVybiBieXRlcztcbiAgICB9LFxuXG4gICAgLy8gQ29udmVydCBhIGJ5dGUgYXJyYXkgdG8gYSBiYXNlLTY0IHN0cmluZ1xuICAgIGJ5dGVzVG9CYXNlNjQ6IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICBmb3IgKHZhciBiYXNlNjQgPSBbXSwgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICB2YXIgdHJpcGxldCA9IChieXRlc1tpXSA8PCAxNikgfCAoYnl0ZXNbaSArIDFdIDw8IDgpIHwgYnl0ZXNbaSArIDJdO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDQ7IGorKylcbiAgICAgICAgICBpZiAoaSAqIDggKyBqICogNiA8PSBieXRlcy5sZW5ndGggKiA4KVxuICAgICAgICAgICAgYmFzZTY0LnB1c2goYmFzZTY0bWFwLmNoYXJBdCgodHJpcGxldCA+Pj4gNiAqICgzIC0gaikpICYgMHgzRikpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJhc2U2NC5wdXNoKCc9Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZTY0LmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGEgYmFzZS02NCBzdHJpbmcgdG8gYSBieXRlIGFycmF5XG4gICAgYmFzZTY0VG9CeXRlczogZnVuY3Rpb24oYmFzZTY0KSB7XG4gICAgICAvLyBSZW1vdmUgbm9uLWJhc2UtNjQgY2hhcmFjdGVyc1xuICAgICAgYmFzZTY0ID0gYmFzZTY0LnJlcGxhY2UoL1teQS1aMC05K1xcL10vaWcsICcnKTtcblxuICAgICAgZm9yICh2YXIgYnl0ZXMgPSBbXSwgaSA9IDAsIGltb2Q0ID0gMDsgaSA8IGJhc2U2NC5sZW5ndGg7XG4gICAgICAgICAgaW1vZDQgPSArK2kgJSA0KSB7XG4gICAgICAgIGlmIChpbW9kNCA9PSAwKSBjb250aW51ZTtcbiAgICAgICAgYnl0ZXMucHVzaCgoKGJhc2U2NG1hcC5pbmRleE9mKGJhc2U2NC5jaGFyQXQoaSAtIDEpKVxuICAgICAgICAgICAgJiAoTWF0aC5wb3coMiwgLTIgKiBpbW9kNCArIDgpIC0gMSkpIDw8IChpbW9kNCAqIDIpKVxuICAgICAgICAgICAgfCAoYmFzZTY0bWFwLmluZGV4T2YoYmFzZTY0LmNoYXJBdChpKSkgPj4+ICg2IC0gaW1vZDQgKiAyKSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IGNyeXB0O1xufSkoKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9pcy1idWZmZXIvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgbm8gc3RhdGljIGV4cG9ydHMgZm91bmQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyohXG4gKiBEZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgQnVmZmVyXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG4vLyBUaGUgX2lzQnVmZmVyIGNoZWNrIGlzIGZvciBTYWZhcmkgNS03IHN1cHBvcnQsIGJlY2F1c2UgaXQncyBtaXNzaW5nXG4vLyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLiBSZW1vdmUgdGhpcyBldmVudHVhbGx5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIChpc0J1ZmZlcihvYmopIHx8IGlzU2xvd0J1ZmZlcihvYmopIHx8ICEhb2JqLl9pc0J1ZmZlcilcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIgKG9iaikge1xuICByZXR1cm4gISFvYmouY29uc3RydWN0b3IgJiYgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKVxufVxuXG4vLyBGb3IgTm9kZSB2MC4xMCBzdXBwb3J0LiBSZW1vdmUgdGhpcyBldmVudHVhbGx5LlxuZnVuY3Rpb24gaXNTbG93QnVmZmVyIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmoucmVhZEZsb2F0TEUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5zbGljZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0J1ZmZlcihvYmouc2xpY2UoMCwgMCkpXG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvbWQ1L21kNS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL21kNS9tZDUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4oZnVuY3Rpb24oKXtcclxuICB2YXIgY3J5cHQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjcnlwdCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NyeXB0L2NyeXB0LmpzXCIpLFxyXG4gICAgICB1dGY4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY2hhcmVuYyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NoYXJlbmMvY2hhcmVuYy5qc1wiKS51dGY4LFxyXG4gICAgICBpc0J1ZmZlciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGlzLWJ1ZmZlciAqLyBcIi4vbm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qc1wiKSxcclxuICAgICAgYmluID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY2hhcmVuYyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NoYXJlbmMvY2hhcmVuYy5qc1wiKS5iaW4sXHJcblxyXG4gIC8vIFRoZSBjb3JlXHJcbiAgbWQ1ID0gZnVuY3Rpb24gKG1lc3NhZ2UsIG9wdGlvbnMpIHtcclxuICAgIC8vIENvbnZlcnQgdG8gYnl0ZSBhcnJheVxyXG4gICAgaWYgKG1lc3NhZ2UuY29uc3RydWN0b3IgPT0gU3RyaW5nKVxyXG4gICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmVuY29kaW5nID09PSAnYmluYXJ5JylcclxuICAgICAgICBtZXNzYWdlID0gYmluLnN0cmluZ1RvQnl0ZXMobWVzc2FnZSk7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICBtZXNzYWdlID0gdXRmOC5zdHJpbmdUb0J5dGVzKG1lc3NhZ2UpO1xyXG4gICAgZWxzZSBpZiAoaXNCdWZmZXIobWVzc2FnZSkpXHJcbiAgICAgIG1lc3NhZ2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChtZXNzYWdlLCAwKTtcclxuICAgIGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UpICYmIG1lc3NhZ2UuY29uc3RydWN0b3IgIT09IFVpbnQ4QXJyYXkpXHJcbiAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlLnRvU3RyaW5nKCk7XHJcbiAgICAvLyBlbHNlLCBhc3N1bWUgYnl0ZSBhcnJheSBhbHJlYWR5XHJcblxyXG4gICAgdmFyIG0gPSBjcnlwdC5ieXRlc1RvV29yZHMobWVzc2FnZSksXHJcbiAgICAgICAgbCA9IG1lc3NhZ2UubGVuZ3RoICogOCxcclxuICAgICAgICBhID0gIDE3MzI1ODQxOTMsXHJcbiAgICAgICAgYiA9IC0yNzE3MzM4NzksXHJcbiAgICAgICAgYyA9IC0xNzMyNTg0MTk0LFxyXG4gICAgICAgIGQgPSAgMjcxNzMzODc4O1xyXG5cclxuICAgIC8vIFN3YXAgZW5kaWFuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG0ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgbVtpXSA9ICgobVtpXSA8PCAgOCkgfCAobVtpXSA+Pj4gMjQpKSAmIDB4MDBGRjAwRkYgfFxyXG4gICAgICAgICAgICAgKChtW2ldIDw8IDI0KSB8IChtW2ldID4+PiAgOCkpICYgMHhGRjAwRkYwMDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQYWRkaW5nXHJcbiAgICBtW2wgPj4+IDVdIHw9IDB4ODAgPDwgKGwgJSAzMik7XHJcbiAgICBtWygoKGwgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gbDtcclxuXHJcbiAgICAvLyBNZXRob2Qgc2hvcnRjdXRzXHJcbiAgICB2YXIgRkYgPSBtZDUuX2ZmLFxyXG4gICAgICAgIEdHID0gbWQ1Ll9nZyxcclxuICAgICAgICBISCA9IG1kNS5faGgsXHJcbiAgICAgICAgSUkgPSBtZDUuX2lpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbS5sZW5ndGg7IGkgKz0gMTYpIHtcclxuXHJcbiAgICAgIHZhciBhYSA9IGEsXHJcbiAgICAgICAgICBiYiA9IGIsXHJcbiAgICAgICAgICBjYyA9IGMsXHJcbiAgICAgICAgICBkZCA9IGQ7XHJcblxyXG4gICAgICBhID0gRkYoYSwgYiwgYywgZCwgbVtpKyAwXSwgIDcsIC02ODA4NzY5MzYpO1xyXG4gICAgICBkID0gRkYoZCwgYSwgYiwgYywgbVtpKyAxXSwgMTIsIC0zODk1NjQ1ODYpO1xyXG4gICAgICBjID0gRkYoYywgZCwgYSwgYiwgbVtpKyAyXSwgMTcsICA2MDYxMDU4MTkpO1xyXG4gICAgICBiID0gRkYoYiwgYywgZCwgYSwgbVtpKyAzXSwgMjIsIC0xMDQ0NTI1MzMwKTtcclxuICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIG1baSsgNF0sICA3LCAtMTc2NDE4ODk3KTtcclxuICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIG1baSsgNV0sIDEyLCAgMTIwMDA4MDQyNik7XHJcbiAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBtW2krIDZdLCAxNywgLTE0NzMyMzEzNDEpO1xyXG4gICAgICBiID0gRkYoYiwgYywgZCwgYSwgbVtpKyA3XSwgMjIsIC00NTcwNTk4Myk7XHJcbiAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBtW2krIDhdLCAgNywgIDE3NzAwMzU0MTYpO1xyXG4gICAgICBkID0gRkYoZCwgYSwgYiwgYywgbVtpKyA5XSwgMTIsIC0xOTU4NDE0NDE3KTtcclxuICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIG1baSsxMF0sIDE3LCAtNDIwNjMpO1xyXG4gICAgICBiID0gRkYoYiwgYywgZCwgYSwgbVtpKzExXSwgMjIsIC0xOTkwNDA0MTYyKTtcclxuICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIG1baSsxMl0sICA3LCAgMTgwNDYwMzY4Mik7XHJcbiAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBtW2krMTNdLCAxMiwgLTQwMzQxMTAxKTtcclxuICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIG1baSsxNF0sIDE3LCAtMTUwMjAwMjI5MCk7XHJcbiAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBtW2krMTVdLCAyMiwgIDEyMzY1MzUzMjkpO1xyXG5cclxuICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIG1baSsgMV0sICA1LCAtMTY1Nzk2NTEwKTtcclxuICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIG1baSsgNl0sICA5LCAtMTA2OTUwMTYzMik7XHJcbiAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBtW2krMTFdLCAxNCwgIDY0MzcxNzcxMyk7XHJcbiAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBtW2krIDBdLCAyMCwgLTM3Mzg5NzMwMik7XHJcbiAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBtW2krIDVdLCAgNSwgLTcwMTU1ODY5MSk7XHJcbiAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBtW2krMTBdLCAgOSwgIDM4MDE2MDgzKTtcclxuICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIG1baSsxNV0sIDE0LCAtNjYwNDc4MzM1KTtcclxuICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIG1baSsgNF0sIDIwLCAtNDA1NTM3ODQ4KTtcclxuICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIG1baSsgOV0sICA1LCAgNTY4NDQ2NDM4KTtcclxuICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIG1baSsxNF0sICA5LCAtMTAxOTgwMzY5MCk7XHJcbiAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBtW2krIDNdLCAxNCwgLTE4NzM2Mzk2MSk7XHJcbiAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBtW2krIDhdLCAyMCwgIDExNjM1MzE1MDEpO1xyXG4gICAgICBhID0gR0coYSwgYiwgYywgZCwgbVtpKzEzXSwgIDUsIC0xNDQ0NjgxNDY3KTtcclxuICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIG1baSsgMl0sICA5LCAtNTE0MDM3ODQpO1xyXG4gICAgICBjID0gR0coYywgZCwgYSwgYiwgbVtpKyA3XSwgMTQsICAxNzM1MzI4NDczKTtcclxuICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIG1baSsxMl0sIDIwLCAtMTkyNjYwNzczNCk7XHJcblxyXG4gICAgICBhID0gSEgoYSwgYiwgYywgZCwgbVtpKyA1XSwgIDQsIC0zNzg1NTgpO1xyXG4gICAgICBkID0gSEgoZCwgYSwgYiwgYywgbVtpKyA4XSwgMTEsIC0yMDIyNTc0NDYzKTtcclxuICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIG1baSsxMV0sIDE2LCAgMTgzOTAzMDU2Mik7XHJcbiAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBtW2krMTRdLCAyMywgLTM1MzA5NTU2KTtcclxuICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIG1baSsgMV0sICA0LCAtMTUzMDk5MjA2MCk7XHJcbiAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBtW2krIDRdLCAxMSwgIDEyNzI4OTMzNTMpO1xyXG4gICAgICBjID0gSEgoYywgZCwgYSwgYiwgbVtpKyA3XSwgMTYsIC0xNTU0OTc2MzIpO1xyXG4gICAgICBiID0gSEgoYiwgYywgZCwgYSwgbVtpKzEwXSwgMjMsIC0xMDk0NzMwNjQwKTtcclxuICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIG1baSsxM10sICA0LCAgNjgxMjc5MTc0KTtcclxuICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIG1baSsgMF0sIDExLCAtMzU4NTM3MjIyKTtcclxuICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIG1baSsgM10sIDE2LCAtNzIyNTIxOTc5KTtcclxuICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIG1baSsgNl0sIDIzLCAgNzYwMjkxODkpO1xyXG4gICAgICBhID0gSEgoYSwgYiwgYywgZCwgbVtpKyA5XSwgIDQsIC02NDAzNjQ0ODcpO1xyXG4gICAgICBkID0gSEgoZCwgYSwgYiwgYywgbVtpKzEyXSwgMTEsIC00MjE4MTU4MzUpO1xyXG4gICAgICBjID0gSEgoYywgZCwgYSwgYiwgbVtpKzE1XSwgMTYsICA1MzA3NDI1MjApO1xyXG4gICAgICBiID0gSEgoYiwgYywgZCwgYSwgbVtpKyAyXSwgMjMsIC05OTUzMzg2NTEpO1xyXG5cclxuICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIG1baSsgMF0sICA2LCAtMTk4NjMwODQ0KTtcclxuICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIG1baSsgN10sIDEwLCAgMTEyNjg5MTQxNSk7XHJcbiAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBtW2krMTRdLCAxNSwgLTE0MTYzNTQ5MDUpO1xyXG4gICAgICBiID0gSUkoYiwgYywgZCwgYSwgbVtpKyA1XSwgMjEsIC01NzQzNDA1NSk7XHJcbiAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBtW2krMTJdLCAgNiwgIDE3MDA0ODU1NzEpO1xyXG4gICAgICBkID0gSUkoZCwgYSwgYiwgYywgbVtpKyAzXSwgMTAsIC0xODk0OTg2NjA2KTtcclxuICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIG1baSsxMF0sIDE1LCAtMTA1MTUyMyk7XHJcbiAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBtW2krIDFdLCAyMSwgLTIwNTQ5MjI3OTkpO1xyXG4gICAgICBhID0gSUkoYSwgYiwgYywgZCwgbVtpKyA4XSwgIDYsICAxODczMzEzMzU5KTtcclxuICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIG1baSsxNV0sIDEwLCAtMzA2MTE3NDQpO1xyXG4gICAgICBjID0gSUkoYywgZCwgYSwgYiwgbVtpKyA2XSwgMTUsIC0xNTYwMTk4MzgwKTtcclxuICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIG1baSsxM10sIDIxLCAgMTMwOTE1MTY0OSk7XHJcbiAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBtW2krIDRdLCAgNiwgLTE0NTUyMzA3MCk7XHJcbiAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBtW2krMTFdLCAxMCwgLTExMjAyMTAzNzkpO1xyXG4gICAgICBjID0gSUkoYywgZCwgYSwgYiwgbVtpKyAyXSwgMTUsICA3MTg3ODcyNTkpO1xyXG4gICAgICBiID0gSUkoYiwgYywgZCwgYSwgbVtpKyA5XSwgMjEsIC0zNDM0ODU1NTEpO1xyXG5cclxuICAgICAgYSA9IChhICsgYWEpID4+PiAwO1xyXG4gICAgICBiID0gKGIgKyBiYikgPj4+IDA7XHJcbiAgICAgIGMgPSAoYyArIGNjKSA+Pj4gMDtcclxuICAgICAgZCA9IChkICsgZGQpID4+PiAwO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjcnlwdC5lbmRpYW4oW2EsIGIsIGMsIGRdKTtcclxuICB9O1xyXG5cclxuICAvLyBBdXhpbGlhcnkgZnVuY3Rpb25zXHJcbiAgbWQ1Ll9mZiAgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCwgeCwgcywgdCkge1xyXG4gICAgdmFyIG4gPSBhICsgKGIgJiBjIHwgfmIgJiBkKSArICh4ID4+PiAwKSArIHQ7XHJcbiAgICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xyXG4gIH07XHJcbiAgbWQ1Ll9nZyAgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCwgeCwgcywgdCkge1xyXG4gICAgdmFyIG4gPSBhICsgKGIgJiBkIHwgYyAmIH5kKSArICh4ID4+PiAwKSArIHQ7XHJcbiAgICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xyXG4gIH07XHJcbiAgbWQ1Ll9oaCAgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCwgeCwgcywgdCkge1xyXG4gICAgdmFyIG4gPSBhICsgKGIgXiBjIF4gZCkgKyAoeCA+Pj4gMCkgKyB0O1xyXG4gICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcclxuICB9O1xyXG4gIG1kNS5faWkgID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcclxuICAgIHZhciBuID0gYSArIChjIF4gKGIgfCB+ZCkpICsgKHggPj4+IDApICsgdDtcclxuICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XHJcbiAgfTtcclxuXHJcbiAgLy8gUGFja2FnZSBwcml2YXRlIGJsb2Nrc2l6ZVxyXG4gIG1kNS5fYmxvY2tzaXplID0gMTY7XHJcbiAgbWQ1Ll9kaWdlc3RzaXplID0gMTY7XHJcblxyXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1lc3NhZ2UsIG9wdGlvbnMpIHtcclxuICAgIGlmIChtZXNzYWdlID09PSB1bmRlZmluZWQgfHwgbWVzc2FnZSA9PT0gbnVsbClcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGFyZ3VtZW50ICcgKyBtZXNzYWdlKTtcclxuXHJcbiAgICB2YXIgZGlnZXN0Ynl0ZXMgPSBjcnlwdC53b3Jkc1RvQnl0ZXMobWQ1KG1lc3NhZ2UsIG9wdGlvbnMpKTtcclxuICAgIHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMuYXNCeXRlcyA/IGRpZ2VzdGJ5dGVzIDpcclxuICAgICAgICBvcHRpb25zICYmIG9wdGlvbnMuYXNTdHJpbmcgPyBiaW4uYnl0ZXNUb1N0cmluZyhkaWdlc3RieXRlcykgOlxyXG4gICAgICAgIGNyeXB0LmJ5dGVzVG9IZXgoZGlnZXN0Ynl0ZXMpO1xyXG4gIH07XHJcblxyXG59KSgpO1xyXG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIHJ1bnRpbWUgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqW2tleV07XG4gIH1cbiAgdHJ5IHtcbiAgICAvLyBJRSA4IGhhcyBhIGJyb2tlbiBPYmplY3QuZGVmaW5lUHJvcGVydHkgdGhhdCBvbmx5IHdvcmtzIG9uIERPTSBvYmplY3RzLlxuICAgIGRlZmluZSh7fSwgXCJcIik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGRlZmluZSA9IGZ1bmN0aW9uKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG9ialtrZXldID0gdmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIGV4cG9ydHMud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIEl0ZXJhdG9yUHJvdG90eXBlW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTtcbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmXG4gICAgICBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiZcbiAgICAgIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkpIHtcbiAgICAvLyBUaGlzIGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZSAlSXRlcmF0b3JQcm90b3R5cGUlOyB1c2UgaXQgaW5zdGVhZFxuICAgIC8vIG9mIHRoZSBwb2x5ZmlsbC5cbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG5cbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gZGVmaW5lKFxuICAgIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLFxuICAgIHRvU3RyaW5nVGFnU3ltYm9sLFxuICAgIFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICApO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIGRlZmluZShwcm90b3R5cGUsIG1ldGhvZCwgZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBleHBvcnRzLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGRlZmluZShnZW5GdW4sIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIC8vIElmIGEgcmVqZWN0ZWQgUHJvbWlzZSB3YXMgeWllbGRlZCwgdGhyb3cgdGhlIHJlamVjdGlvbiBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZSBoYW5kbGVkIHRoZXJlLlxuICAgICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2VJbXBsKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgQXN5bmNJdGVyYXRvci5wcm90b3R5cGVbYXN5bmNJdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHtcbiAgICBpZiAoUHJvbWlzZUltcGwgPT09IHZvaWQgMCkgUHJvbWlzZUltcGwgPSBQcm9taXNlO1xuXG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpLFxuICAgICAgUHJvbWlzZUltcGxcbiAgICApO1xuXG4gICAgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIC8vIE5vdGU6IFtcInJldHVyblwiXSBtdXN0IGJlIHVzZWQgZm9yIEVTMyBwYXJzaW5nIGNvbXBhdGliaWxpdHkuXG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXSkge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoISBpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIGRlZmluZShHcCwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yXCIpO1xuXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBleHBvcnRzLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGVcbiAgLy8gb3Igbm90LCByZXR1cm4gdGhlIHJ1bnRpbWUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGRlY2xhcmUgdGhlIHZhcmlhYmxlXG4gIC8vIHJlZ2VuZXJhdG9yUnVudGltZSBpbiB0aGUgb3V0ZXIgc2NvcGUsIHdoaWNoIGFsbG93cyB0aGlzIG1vZHVsZSB0byBiZVxuICAvLyBpbmplY3RlZCBlYXNpbHkgYnkgYGJpbi9yZWdlbmVyYXRvciAtLWluY2x1ZGUtcnVudGltZSBzY3JpcHQuanNgLlxuICByZXR1cm4gZXhwb3J0cztcblxufShcbiAgLy8gSWYgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlLCB1c2UgbW9kdWxlLmV4cG9ydHNcbiAgLy8gYXMgdGhlIHJlZ2VuZXJhdG9yUnVudGltZSBuYW1lc3BhY2UuIE90aGVyd2lzZSBjcmVhdGUgYSBuZXcgZW1wdHlcbiAgLy8gb2JqZWN0LiBFaXRoZXIgd2F5LCB0aGUgcmVzdWx0aW5nIG9iamVjdCB3aWxsIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZVxuICAvLyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIHZhcmlhYmxlIGF0IHRoZSB0b3Agb2YgdGhpcyBmaWxlLlxuICAgdHJ1ZSA/IG1vZHVsZS5leHBvcnRzIDogdW5kZWZpbmVkXG4pKTtcblxudHJ5IHtcbiAgcmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbn0gY2F0Y2ggKGFjY2lkZW50YWxTdHJpY3RNb2RlKSB7XG4gIC8vIFRoaXMgbW9kdWxlIHNob3VsZCBub3QgYmUgcnVubmluZyBpbiBzdHJpY3QgbW9kZSwgc28gdGhlIGFib3ZlXG4gIC8vIGFzc2lnbm1lbnQgc2hvdWxkIGFsd2F5cyB3b3JrIHVubGVzcyBzb21ldGhpbmcgaXMgbWlzY29uZmlndXJlZC4gSnVzdFxuICAvLyBpbiBjYXNlIHJ1bnRpbWUuanMgYWNjaWRlbnRhbGx5IHJ1bnMgaW4gc3RyaWN0IG1vZGUsIHdlIGNhbiBlc2NhcGVcbiAgLy8gc3RyaWN0IG1vZGUgdXNpbmcgYSBnbG9iYWwgRnVuY3Rpb24gY2FsbC4gVGhpcyBjb3VsZCBjb25jZWl2YWJseSBmYWlsXG4gIC8vIGlmIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgZm9yYmlkcyB1c2luZyBGdW5jdGlvbiwgYnV0IGluIHRoYXQgY2FzZVxuICAvLyB0aGUgcHJvcGVyIHNvbHV0aW9uIGlzIHRvIGZpeCB0aGUgYWNjaWRlbnRhbCBzdHJpY3QgbW9kZSBwcm9ibGVtLiBJZlxuICAvLyB5b3UndmUgbWlzY29uZmlndXJlZCB5b3VyIGJ1bmRsZXIgdG8gZm9yY2Ugc3RyaWN0IG1vZGUgYW5kIGFwcGxpZWQgYVxuICAvLyBDU1AgdG8gZm9yYmlkIEZ1bmN0aW9uLCBhbmQgeW91J3JlIG5vdCB3aWxsaW5nIHRvIGZpeCBlaXRoZXIgb2YgdGhvc2VcbiAgLy8gcHJvYmxlbXMsIHBsZWFzZSBkZXRhaWwgeW91ciB1bmlxdWUgcHJlZGljYW1lbnQgaW4gYSBHaXRIdWIgaXNzdWUuXG4gIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvYXBpLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9hcGkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IHNldHVwLCBzZXR1cENhY2hlLCBzZXJpYWxpemVRdWVyeSwgZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJzZXR1cFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHNldHVwOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJzZXR1cENhY2hlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gc2V0dXBDYWNoZTsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzN19vYmplY3RfZ2V0X293bl9wcm9wZXJ0eV9kZXNjcmlwdG9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcnMuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzN19vYmplY3RfZ2V0X293bl9wcm9wZXJ0eV9kZXNjcmlwdG9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lczdfb2JqZWN0X2dldF9vd25fcHJvcGVydHlfZGVzY3JpcHRvcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzNl9zeW1ib2xfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lczYuc3ltYm9sICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zeW1ib2wuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzNl9zeW1ib2xfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXM2X3N5bWJvbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X2FycmF5X2l0ZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X2FycmF5X2l0ZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzNl9hcnJheV9pdGVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X29iamVjdF90b19zdHJpbmdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZy5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X29iamVjdF90b19zdHJpbmdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXM2X29iamVjdF90b19zdHJpbmdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcmVnZW5lcmF0b3JfcnVudGltZV9ydW50aW1lX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISByZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUgKi8gXCIuL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcmVnZW5lcmF0b3JfcnVudGltZV9ydW50aW1lX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4ocmVnZW5lcmF0b3JfcnVudGltZV9ydW50aW1lX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGF4aW9zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBheGlvcyAqLyBcImF4aW9zXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGF4aW9zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oYXhpb3NfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3JlcXVlc3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcmVxdWVzdCAqLyBcIi4vc3JjL3JlcXVlc3QuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NhY2hlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NhY2hlICovIFwiLi9zcmMvY2FjaGUuanNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJzZXJpYWxpemVRdWVyeVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9jYWNoZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wic2VyaWFsaXplUXVlcnlcIl07IH0pO1xuXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbmZpZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jb25maWcgKi8gXCIuL3NyYy9jb25maWcuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxpdGllc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlsaXRpZXMgKi8gXCIuL3NyYy91dGlsaXRpZXMuanNcIik7XG5cblxuXG5cblxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykgeyB0cnkgeyB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7IHZhciB2YWx1ZSA9IGluZm8udmFsdWU7IH0gY2F0Y2ggKGVycm9yKSB7IHJlamVjdChlcnJvcik7IHJldHVybjsgfSBpZiAoaW5mby5kb25lKSB7IHJlc29sdmUodmFsdWUpOyB9IGVsc2UgeyBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7IH0gfVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgc2VsZiA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTsgZnVuY3Rpb24gX25leHQodmFsdWUpIHsgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpOyB9IGZ1bmN0aW9uIF90aHJvdyhlcnIpIHsgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7IH0gX25leHQodW5kZWZpbmVkKTsgfSk7IH07IH1cblxuXG5cblxuXG5cbi8qKlxuICogQ29uZmlndXJlIGNhY2hlIGFkYXB0ZXJcbiAqXG4gKiBAcGFyYW0gICB7b2JqZWN0fSBbY29uZmlnPXt9XSBDYWNoZSBhZGFwdGVyIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtvYmplY3R9IE9iamVjdCBjb250YWluaW5nIGNhY2hlIGBhZGFwdGVyYCBhbmQgYHN0b3JlYFxuICovXG5cbmZ1bmN0aW9uIHNldHVwQ2FjaGUoKSB7XG4gIHZhciBjb25maWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAvLyBFeHRlbmQgZGVmYXVsdCBjb25maWd1cmF0aW9uXG4gIGNvbmZpZyA9IE9iamVjdChfY29uZmlnX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bXCJtYWtlQ29uZmlnXCJdKShjb25maWcpOyAvLyBBeGlvcyBhZGFwdGVyLiBSZWNlaXZlcyB0aGUgYXhpb3MgcmVxdWVzdCBjb25maWd1cmF0aW9uIGFzIG9ubHkgcGFyYW1ldGVyXG5cbiAgZnVuY3Rpb24gYWRhcHRlcihfeCkge1xuICAgIHJldHVybiBfYWRhcHRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9IC8vIFJldHVybiBhZGFwdGVyIGFuZCBzdG9yZSBpbnN0YW5jZVxuXG5cbiAgZnVuY3Rpb24gX2FkYXB0ZXIoKSB7XG4gICAgX2FkYXB0ZXIgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUocmVxKSB7XG4gICAgICB2YXIgcmVxQ29uZmlnLCByZXMsIG5leHQsIG5ldHdvcmtFcnJvciwgcmVhZE9uRXJyb3I7XG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIC8vIE1lcmdlIHRoZSBwZXItcmVxdWVzdCBjb25maWcgd2l0aCB0aGUgaW5zdGFuY2UgY29uZmlnLlxuICAgICAgICAgICAgICByZXFDb25maWcgPSBPYmplY3QoX2NvbmZpZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fW1wibWVyZ2VSZXF1ZXN0Q29uZmlnXCJdKShjb25maWcsIHJlcSk7IC8vIEV4ZWN1dGUgcmVxdWVzdCBhZ2FpbnN0IGxvY2FsIGNhY2hlXG5cbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgICAgICAgIHJldHVybiBPYmplY3QoX3JlcXVlc3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcImRlZmF1bHRcIl0pKHJlcUNvbmZpZywgcmVxKTtcblxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICByZXMgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgICBuZXh0ID0gcmVzLm5leHQ7IC8vIFJlc3BvbnNlIGlzIG5vdCBmdW5jdGlvbiwgc29tZXRoaW5nIHdhcyBpbiBjYWNoZSwgcmV0dXJuIGl0XG5cbiAgICAgICAgICAgICAgaWYgKE9iamVjdChfdXRpbGl0aWVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19bXCJpc0Z1bmN0aW9uXCJdKShuZXh0KSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA3O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBuZXh0KTtcblxuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gNztcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEwO1xuICAgICAgICAgICAgICByZXR1cm4gcmVxQ29uZmlnLmFkYXB0ZXIocmVxKTtcblxuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgcmVzID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE2O1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDEzO1xuICAgICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oNyk7XG4gICAgICAgICAgICAgIG5ldHdvcmtFcnJvciA9IF9jb250ZXh0LnQwO1xuXG4gICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICBpZiAoIW5ldHdvcmtFcnJvcikge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIHNob3VsZCBhdHRlbXB0IHJlYWRpbmcgc3RhbGUgY2FjaGUgZGF0YVxuICAgICAgICAgICAgICByZWFkT25FcnJvciA9IE9iamVjdChfdXRpbGl0aWVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19bXCJpc0Z1bmN0aW9uXCJdKShyZXFDb25maWcucmVhZE9uRXJyb3IpID8gcmVxQ29uZmlnLnJlYWRPbkVycm9yKG5ldHdvcmtFcnJvciwgcmVxKSA6IHJlcUNvbmZpZy5yZWFkT25FcnJvcjtcblxuICAgICAgICAgICAgICBpZiAoIXJlYWRPbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDMwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDE5O1xuICAgICAgICAgICAgICAvLyBGb3JjZSBjYWNoZSB0dSByZXR1cm4gc3RhbGUgZGF0YVxuICAgICAgICAgICAgICByZXFDb25maWcuYWNjZXB0U3RhbGUgPSB0cnVlOyAvLyBUcnkgdG8gcmVhZCBmcm9tIGNhY2hlIGFnYWluXG5cbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDIzO1xuICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0KF9yZXF1ZXN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJkZWZhdWx0XCJdKShyZXFDb25maWcsIHJlcSk7XG5cbiAgICAgICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgICAgIHJlcyA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICAgIC8vIFNpZ25hbCB0aGF0IGRhdGEgaXMgZnJvbSBzdGFsZSBjYWNoZVxuICAgICAgICAgICAgICByZXMubmV4dC5yZXF1ZXN0LnN0YWxlID0gdHJ1ZTsgLy8gTm8gbmVlZCB0byBjaGVjayBpZiBgbmV4dGAgaXMgYSBmdW5jdGlvbiBqdXN0IHJldHVybiBjYWNoZSBkYXRhXG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCByZXMubmV4dCk7XG5cbiAgICAgICAgICAgIGNhc2UgMjg6XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAyODtcbiAgICAgICAgICAgICAgX2NvbnRleHQudDEgPSBfY29udGV4dFtcImNhdGNoXCJdKDE5KTtcblxuICAgICAgICAgICAgY2FzZSAzMDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV0d29ya0Vycm9yO1xuXG4gICAgICAgICAgICBjYXNlIDMxOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIG5leHQocmVzKSk7XG5cbiAgICAgICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlLCBudWxsLCBbWzcsIDEzXSwgWzE5LCAyOF1dKTtcbiAgICB9KSk7XG4gICAgcmV0dXJuIF9hZGFwdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGFkYXB0ZXI6IGFkYXB0ZXIsXG4gICAgY29uZmlnOiBjb25maWcsXG4gICAgc3RvcmU6IGNvbmZpZy5zdG9yZVxuICB9O1xufSAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEVhc3kgQVBJIFNldHVwXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBTZXR1cCBhbiBheGlvcyBpbnN0YW5jZSB3aXRoIHRoZSBjYWNoZSBhZGFwdGVyIHByZS1jb25maWd1cmVkXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zPXt9XSBBeGlvcyBhbmQgY2FjaGUgYWRhcHRlciBvcHRpb25zXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBJbnN0YW5jZSBvZiBBeGlvc1xuICovXG5cblxuZnVuY3Rpb24gc2V0dXAoKSB7XG4gIHZhciBjb25maWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gIHZhciBpbnN0YW5jZUNvbmZpZyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBfY29uZmlnX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bXCJkZWZhdWx0c1wiXS5heGlvcyksIGNvbmZpZyksIHt9LCB7XG4gICAgY2FjaGU6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgX2NvbmZpZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fW1wiZGVmYXVsdHNcIl0uYXhpb3MuY2FjaGUpLCBjb25maWcuY2FjaGUpXG4gIH0pO1xuXG4gIHZhciBjYWNoZSA9IHNldHVwQ2FjaGUoaW5zdGFuY2VDb25maWcuY2FjaGUpO1xuXG4gIHZhciBfID0gaW5zdGFuY2VDb25maWcuY2FjaGUsXG4gICAgICBheGlvc0NvbmZpZyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhpbnN0YW5jZUNvbmZpZywgW1wiY2FjaGVcIl0pO1xuXG4gIHZhciBhcGkgPSBheGlvc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fX2RlZmF1bHQuYS5jcmVhdGUoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBheGlvc0NvbmZpZyksIHt9LCB7XG4gICAgYWRhcHRlcjogY2FjaGUuYWRhcHRlclxuICB9KSk7XG4gIGFwaS5jYWNoZSA9IGNhY2hlLnN0b3JlO1xuICByZXR1cm4gYXBpO1xufVxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICBzZXR1cDogc2V0dXAsXG4gIHNldHVwQ2FjaGU6IHNldHVwQ2FjaGUsXG4gIHNlcmlhbGl6ZVF1ZXJ5OiBfY2FjaGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcInNlcmlhbGl6ZVF1ZXJ5XCJdXG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvY2FjaGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvY2FjaGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogcmVhZCwgd3JpdGUsIGtleSwgaW52YWxpZGF0ZSwgc2VyaWFsaXplUXVlcnksIGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwicmVhZFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHJlYWQ7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIndyaXRlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gd3JpdGU7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImtleVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGtleTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaW52YWxpZGF0ZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGludmFsaWRhdGU7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInNlcmlhbGl6ZVF1ZXJ5XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gc2VyaWFsaXplUXVlcnk7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczdfYXJyYXlfaW5jbHVkZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lczcuYXJyYXkuaW5jbHVkZXMgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LmFycmF5LmluY2x1ZGVzLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczdfYXJyYXlfaW5jbHVkZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXM3X2FycmF5X2luY2x1ZGVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfc3RyaW5nX2luY2x1ZGVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvZXM2LnN0cmluZy5pbmNsdWRlcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmluY2x1ZGVzLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfc3RyaW5nX2luY2x1ZGVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzNl9zdHJpbmdfaW5jbHVkZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcmVnZW5lcmF0b3JfcnVudGltZV9ydW50aW1lX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISByZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUgKi8gXCIuL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcmVnZW5lcmF0b3JfcnVudGltZV9ydW50aW1lX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4ocmVnZW5lcmF0b3JfcnVudGltZV9ydW50aW1lX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfYXJyYXlfaXRlcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfYXJyYXlfaXRlcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXM2X2FycmF5X2l0ZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfb2JqZWN0X3RvX3N0cmluZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfb2JqZWN0X3RvX3N0cmluZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lczZfb2JqZWN0X3RvX3N0cmluZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbGl0aWVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWxpdGllcyAqLyBcIi4vc3JjL3V0aWxpdGllcy5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBtZDVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIG1kNSAqLyBcIi4vbm9kZV9tb2R1bGVzL21kNS9tZDUuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgbWQ1X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4obWQ1X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zZXJpYWxpemVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc2VyaWFsaXplICovIFwiLi9zcmMvc2VyaWFsaXplLmpzXCIpO1xuXG5cblxuXG5cblxuZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykgeyB0cnkgeyB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7IHZhciB2YWx1ZSA9IGluZm8udmFsdWU7IH0gY2F0Y2ggKGVycm9yKSB7IHJlamVjdChlcnJvcik7IHJldHVybjsgfSBpZiAoaW5mby5kb25lKSB7IHJlc29sdmUodmFsdWUpOyB9IGVsc2UgeyBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7IH0gfVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgc2VsZiA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTsgZnVuY3Rpb24gX25leHQodmFsdWUpIHsgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpOyB9IGZ1bmN0aW9uIF90aHJvdyhlcnIpIHsgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7IH0gX25leHQodW5kZWZpbmVkKTsgfSk7IH07IH1cblxuXG5cblxuXG5mdW5jdGlvbiB3cml0ZShfeCwgX3gyLCBfeDMpIHtcbiAgcmV0dXJuIF93cml0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfd3JpdGUoKSB7XG4gIF93cml0ZSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShjb25maWcsIHJlcSwgcmVzKSB7XG4gICAgdmFyIGVudHJ5O1xuICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAwO1xuICAgICAgICAgICAgZW50cnkgPSB7XG4gICAgICAgICAgICAgIGV4cGlyZXM6IGNvbmZpZy5leHBpcmVzLFxuICAgICAgICAgICAgICBkYXRhOiBPYmplY3QoX3NlcmlhbGl6ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1wiZGVmYXVsdFwiXSkoY29uZmlnLCByZXEsIHJlcylcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgIHJldHVybiBjb25maWcuc3RvcmUuc2V0SXRlbShjb25maWcudXVpZCwgZW50cnkpO1xuXG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE5O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gNjtcbiAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgIGNvbmZpZy5kZWJ1ZygnQ291bGQgbm90IHN0b3JlIHJlc3BvbnNlJywgX2NvbnRleHQudDApO1xuXG4gICAgICAgICAgICBpZiAoIWNvbmZpZy5jbGVhck9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE4O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDEwO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEzO1xuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy5zdG9yZS5jbGVhcigpO1xuXG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxODtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxNTtcbiAgICAgICAgICAgIF9jb250ZXh0LnQxID0gX2NvbnRleHRbXCJjYXRjaFwiXSgxMCk7XG4gICAgICAgICAgICBjb25maWcuZGVidWcoJ0NvdWxkIG5vdCBjbGVhciBzdG9yZScsIF9jb250ZXh0LnQxKTtcblxuICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGZhbHNlKTtcblxuICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHRydWUpO1xuXG4gICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSwgbnVsbCwgW1swLCA2XSwgWzEwLCAxNV1dKTtcbiAgfSkpO1xuICByZXR1cm4gX3dyaXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIHJlYWQoX3g0LCBfeDUpIHtcbiAgcmV0dXJuIF9yZWFkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9yZWFkKCkge1xuICBfcmVhZCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoY29uZmlnLCByZXEpIHtcbiAgICB2YXIgdXVpZCwgaWdub3JlQ2FjaGUsIGVudHJ5LCBlcnJvciwgZXhwaXJlcywgZGF0YSwgb2ZmbGluZSwgX2Vycm9yO1xuXG4gICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHV1aWQgPSBjb25maWcudXVpZCwgaWdub3JlQ2FjaGUgPSBjb25maWcuaWdub3JlQ2FjaGU7XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gY29uZmlnLnN0b3JlLmdldEl0ZW0odXVpZCk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBlbnRyeSA9IF9jb250ZXh0Mi5zZW50O1xuXG4gICAgICAgICAgICBpZiAoIShpZ25vcmVDYWNoZSB8fCAhZW50cnkgfHwgIWVudHJ5LmRhdGEpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25maWcuZGVidWcoJ2NhY2hlLW1pc3MnLCByZXEudXJsKTtcbiAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKCk7XG4gICAgICAgICAgICBlcnJvci5yZWFzb24gPSAnY2FjaGUtbWlzcyc7XG4gICAgICAgICAgICBlcnJvci5tZXNzYWdlID0gJ0VudHJ5IG5vdCBmb3VuZCBmcm9tIGNhY2hlJztcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuXG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIGV4cGlyZXMgPSBlbnRyeS5leHBpcmVzLCBkYXRhID0gZW50cnkuZGF0YTsgLy8gRG8gbm90IGNoZWNrIGZvciBzdGFsZSBjYWNoZSBpZiBvZmZsaW5lIG9uIGNsaWVudC1zaWRlXG5cbiAgICAgICAgICAgIG9mZmxpbmUgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAnb25MaW5lJyBpbiBuYXZpZ2F0b3IgJiYgIW5hdmlnYXRvci5vbkxpbmU7XG5cbiAgICAgICAgICAgIGlmICghKCFvZmZsaW5lICYmICFjb25maWcuYWNjZXB0U3RhbGUgJiYgZXhwaXJlcyAhPT0gMCAmJiBleHBpcmVzIDwgRGF0ZS5ub3coKSkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxODtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbmZpZy5kZWJ1ZygnY2FjaGUtc3RhbGUnLCByZXEudXJsKTtcbiAgICAgICAgICAgIF9lcnJvciA9IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgX2Vycm9yLnJlYXNvbiA9ICdjYWNoZS1zdGFsZSc7XG4gICAgICAgICAgICBfZXJyb3IubWVzc2FnZSA9ICdFbnRyeSBpcyBzdGFsZSc7XG4gICAgICAgICAgICB0aHJvdyBfZXJyb3I7XG5cbiAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgY29uZmlnLmRlYnVnKGNvbmZpZy5hY2NlcHRTdGFsZSA/ICdjYWNoZS1oaXQtc3RhbGUnIDogJ2NhY2hlLWhpdCcsIHJlcS51cmwpO1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgZGF0YSk7XG5cbiAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZTIpO1xuICB9KSk7XG4gIHJldHVybiBfcmVhZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBrZXkoY29uZmlnKSB7XG4gIGlmIChPYmplY3QoX3V0aWxpdGllc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiaXNGdW5jdGlvblwiXSkoY29uZmlnLmtleSkpIHJldHVybiBjb25maWcua2V5O1xuICB2YXIgY2FjaGVLZXk7XG5cbiAgaWYgKE9iamVjdChfdXRpbGl0aWVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJpc1N0cmluZ1wiXSkoY29uZmlnLmtleSkpIHtcbiAgICBjYWNoZUtleSA9IGZ1bmN0aW9uIGNhY2hlS2V5KHJlcSkge1xuICAgICAgdmFyIHVybCA9IFwiXCIuY29uY2F0KHJlcS5iYXNlVVJMID8gcmVxLmJhc2VVUkwgOiAnJykuY29uY2F0KHJlcS51cmwpO1xuICAgICAgdmFyIGtleSA9IFwiXCIuY29uY2F0KGNvbmZpZy5rZXksIFwiL1wiKS5jb25jYXQodXJsKS5jb25jYXQoc2VyaWFsaXplUXVlcnkocmVxKSk7XG4gICAgICByZXR1cm4gcmVxLmRhdGEgPyBrZXkgKyBtZDVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX19kZWZhdWx0KCkocmVxLmRhdGEpIDoga2V5O1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgY2FjaGVLZXkgPSBmdW5jdGlvbiBjYWNoZUtleShyZXEpIHtcbiAgICAgIHZhciB1cmwgPSBcIlwiLmNvbmNhdChyZXEuYmFzZVVSTCA/IHJlcS5iYXNlVVJMIDogJycpLmNvbmNhdChyZXEudXJsKTtcbiAgICAgIHZhciBrZXkgPSB1cmwgKyBzZXJpYWxpemVRdWVyeShyZXEpO1xuICAgICAgcmV0dXJuIHJlcS5kYXRhID8ga2V5ICsgbWQ1X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19fZGVmYXVsdCgpKHJlcS5kYXRhKSA6IGtleTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGNhY2hlS2V5O1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0SW52YWxpZGF0ZShfeDYsIF94Nykge1xuICByZXR1cm4gX2RlZmF1bHRJbnZhbGlkYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9kZWZhdWx0SW52YWxpZGF0ZSgpIHtcbiAgX2RlZmF1bHRJbnZhbGlkYXRlID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhjb25maWcsIHJlcSkge1xuICAgIHZhciBtZXRob2Q7XG4gICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIG1ldGhvZCA9IHJlcS5tZXRob2QudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgaWYgKCFjb25maWcuZXhjbHVkZS5tZXRob2RzLmluY2x1ZGVzKG1ldGhvZCkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA0O1xuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy5zdG9yZS5yZW1vdmVJdGVtKGNvbmZpZy51dWlkKTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUzKTtcbiAgfSkpO1xuICByZXR1cm4gX2RlZmF1bHRJbnZhbGlkYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIGludmFsaWRhdGUoKSB7XG4gIHZhciBjb25maWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICBpZiAoT2JqZWN0KF91dGlsaXRpZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImlzRnVuY3Rpb25cIl0pKGNvbmZpZy5pbnZhbGlkYXRlKSkgcmV0dXJuIGNvbmZpZy5pbnZhbGlkYXRlO1xuICByZXR1cm4gZGVmYXVsdEludmFsaWRhdGU7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZVF1ZXJ5KHJlcSkge1xuICBpZiAoIXJlcS5wYXJhbXMpIHJldHVybiAnJzsgLy8gUHJvYmFibHkgc2VydmVyLXNpZGUsIGp1c3Qgc3RyaW5naWZ5IHRoZSBvYmplY3RcblxuICBpZiAodHlwZW9mIFVSTFNlYXJjaFBhcmFtcyA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBKU09OLnN0cmluZ2lmeShyZXEucGFyYW1zKTtcbiAgdmFyIHBhcmFtcyA9IHJlcS5wYXJhbXM7XG4gIHZhciBpc0luc3RhbmNlT2ZVUkxTZWFyY2hQYXJhbXMgPSByZXEucGFyYW1zIGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zOyAvLyBDb252ZXJ0IHRvIGFuIGluc3RhbmNlIG9mIFVSTFNlYXJjaFBhcmFtcyBzbyBpdCBnZXQgc2VyaWFsaXplZCB0aGUgc2FtZSB3YXlcblxuICBpZiAoIWlzSW5zdGFuY2VPZlVSTFNlYXJjaFBhcmFtcykge1xuICAgIHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICBPYmplY3Qua2V5cyhyZXEucGFyYW1zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHJldHVybiBwYXJhbXMuYXBwZW5kKGtleSwgcmVxLnBhcmFtc1trZXldKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBcIj9cIi5jb25jYXQocGFyYW1zLnRvU3RyaW5nKCkpO1xufVxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICByZWFkOiByZWFkLFxuICB3cml0ZTogd3JpdGUsXG4gIGtleToga2V5LFxuICBpbnZhbGlkYXRlOiBpbnZhbGlkYXRlLFxuICBzZXJpYWxpemVRdWVyeTogc2VyaWFsaXplUXVlcnlcbn0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9jb25maWcuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2NvbmZpZy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdHMsIG1ha2VDb25maWcsIG1lcmdlUmVxdWVzdENvbmZpZywgZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZWZhdWx0c1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGRlZmF1bHRzOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJtYWtlQ29uZmlnXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbWFrZUNvbmZpZzsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibWVyZ2VSZXF1ZXN0Q29uZmlnXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbWVyZ2VSZXF1ZXN0Q29uZmlnOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM3X29iamVjdF9nZXRfb3duX3Byb3BlcnR5X2Rlc2NyaXB0b3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvZXM3Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycy5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM3X29iamVjdF9nZXRfb3duX3Byb3BlcnR5X2Rlc2NyaXB0b3JzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzN19vYmplY3RfZ2V0X293bl9wcm9wZXJ0eV9kZXNjcmlwdG9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X3N5bWJvbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzNi5zeW1ib2wgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LnN5bWJvbC5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X3N5bWJvbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lczZfc3ltYm9sX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfYXJyYXlfaXRlcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfYXJyYXlfaXRlcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXM2X2FycmF5X2l0ZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfb2JqZWN0X3RvX3N0cmluZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfb2JqZWN0X3RvX3N0cmluZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lczZfb2JqZWN0X3RvX3N0cmluZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBheGlvc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgYXhpb3MgKi8gXCJheGlvc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBheGlvc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGF4aW9zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9tZW1vcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbWVtb3J5ICovIFwiLi9zcmMvbWVtb3J5LmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jYWNoZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jYWNoZSAqLyBcIi4vc3JjL2NhY2hlLmpzXCIpO1xuXG5cblxuXG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5cblxuXG5cbnZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbiBkZWJ1ZygpIHtcbiAgdmFyIF9jb25zb2xlO1xuXG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gKF9jb25zb2xlID0gY29uc29sZSkubG9nLmFwcGx5KF9jb25zb2xlLCBbJ1theGlvcy1jYWNoZS1hZGFwdGVyXSddLmNvbmNhdChhcmdzKSk7XG59O1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gIC8vIERlZmF1bHQgc2V0dGluZ3Mgd2hlbiBzb2xlbHkgY3JlYXRpbmcgdGhlIGNhY2hlIGFkYXB0ZXIgd2l0aCBzZXR1cENhY2hlLlxuICBjYWNoZToge1xuICAgIG1heEFnZTogMCxcbiAgICBsaW1pdDogZmFsc2UsXG4gICAgc3RvcmU6IG51bGwsXG4gICAga2V5OiBudWxsLFxuICAgIGludmFsaWRhdGU6IG51bGwsXG4gICAgZXhjbHVkZToge1xuICAgICAgcGF0aHM6IFtdLFxuICAgICAgcXVlcnk6IHRydWUsXG4gICAgICBmaWx0ZXI6IG51bGwsXG4gICAgICBtZXRob2RzOiBbJ3Bvc3QnLCAncGF0Y2gnLCAncHV0JywgJ2RlbGV0ZSddXG4gICAgfSxcbiAgICBhZGFwdGVyOiBheGlvc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fX2RlZmF1bHQuYS5kZWZhdWx0cy5hZGFwdGVyLFxuICAgIGNsZWFyT25TdGFsZTogdHJ1ZSxcbiAgICBjbGVhck9uRXJyb3I6IHRydWUsXG4gICAgcmVhZE9uRXJyb3I6IGZhbHNlLFxuICAgIHJlYWRIZWFkZXJzOiBmYWxzZSxcbiAgICBkZWJ1ZzogZmFsc2UsXG4gICAgaWdub3JlQ2FjaGU6IGZhbHNlXG4gIH0sXG4gIC8vIEFkZGl0aW9uYWwgZGVmYXVsdHMgd2hlbiBjcmVhdGluZyB0aGUgYXhpb3MgaW5zdGFuY2Ugd2l0aCB0aGUgY2FjaGUgYWRhcHRlci5cbiAgYXhpb3M6IHtcbiAgICBjYWNoZToge1xuICAgICAgbWF4QWdlOiAxNSAqIDYwICogMTAwMFxuICAgIH1cbiAgfVxufTsgLy8gTGlzdCBvZiBkaXNhbGxvd2VkIGluIHRoZSBwZXItcmVxdWVzdCBjb25maWcuXG5cbnZhciBkaXNhbGxvd2VkUGVyUmVxdWVzdEtleXMgPSBbJ2xpbWl0JywgJ3N0b3JlJywgJ2FkYXB0ZXInLCAndXVpZCcsICdhY2NlcHRTdGFsZSddO1xuLyoqXG4gKiBNYWtlIGEgZ2xvYmFsIGNvbmZpZyBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvdmVycmlkZT17fV0gT3B0aW9uYWwgY29uZmlnIG92ZXJyaWRlLlxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5cbnZhciBtYWtlQ29uZmlnID0gZnVuY3Rpb24gbWFrZUNvbmZpZygpIHtcbiAgdmFyIG92ZXJyaWRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICB2YXIgY29uZmlnID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGRlZmF1bHRzLmNhY2hlKSwgb3ZlcnJpZGUpLCB7fSwge1xuICAgIGV4Y2x1ZGU6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdHMuY2FjaGUuZXhjbHVkZSksIG92ZXJyaWRlLmV4Y2x1ZGUpXG4gIH0pOyAvLyBDcmVhdGUgYSBjYWNoZSBrZXkgbWV0aG9kXG5cblxuICBjb25maWcua2V5ID0gT2JqZWN0KF9jYWNoZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wia2V5XCJdKShjb25maWcpO1xuICBjb25maWcuaW52YWxpZGF0ZSA9IE9iamVjdChfY2FjaGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcImludmFsaWRhdGVcIl0pKGNvbmZpZyk7IC8vIElmIGRlYnVnIG1vZGUgaXMgb24sIGNyZWF0ZSBhIHNpbXBsZSBsb2dnZXIgbWV0aG9kXG5cbiAgaWYgKGNvbmZpZy5kZWJ1ZyAhPT0gZmFsc2UpIHtcbiAgICBjb25maWcuZGVidWcgPSB0eXBlb2YgY29uZmlnLmRlYnVnID09PSAnZnVuY3Rpb24nID8gY29uZmlnLmRlYnVnIDogZGVidWc7XG4gIH0gZWxzZSB7XG4gICAgY29uZmlnLmRlYnVnID0gbm9vcDtcbiAgfSAvLyBDcmVhdGUgYW4gaW4gbWVtb3J5IHN0b3JlIGlmIG5vbmUgd2FzIGdpdmVuXG5cblxuICBpZiAoIWNvbmZpZy5zdG9yZSkgY29uZmlnLnN0b3JlID0gbmV3IF9tZW1vcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImRlZmF1bHRcIl0oKTtcbiAgY29uZmlnLmRlYnVnKCdHbG9iYWwgY2FjaGUgY29uZmlnJywgY29uZmlnKTtcbiAgcmV0dXJuIGNvbmZpZztcbn07XG4vKipcbiAqIE1lcmdlIHRoZSBwZXItcmVxdWVzdCBjb25maWcgaW4gYW5vdGhlciBjb25maWcuXG4gKlxuICogVGhpcyBtZXRob2QgZXhpc3RzIGJlY2F1c2Ugbm90IGFsbCBrZXlzIHNob3VsZCBiZSBhbGxvd2VkIGFzIGl0XG4gKiBtYXkgbGVhZCB0byB1bmV4cGVjdGVkIGJlaGF2aW91cnMuIEZvciBpbnN0YW5jZSwgc2V0dGluZyBhbm90aGVyXG4gKiBzdG9yZSBvciBhZGFwdGVyIHBlciByZXF1ZXN0IGlzIHdyb25nLCBpbnN0ZWFkIGFub3RoZXIgaW5zdGFuY2VcbiAqIGF4aW9zLCBvciB0aGUgYWRhcHRlciwgc2hvdWxkIGJlIHVzZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBDb25maWcgb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHJlcSAgICBUaGUgY3VycmVudCBheGlvcyByZXF1ZXN0XG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblxuXG52YXIgbWVyZ2VSZXF1ZXN0Q29uZmlnID0gZnVuY3Rpb24gbWVyZ2VSZXF1ZXN0Q29uZmlnKGNvbmZpZywgcmVxKSB7XG4gIHZhciByZXF1ZXN0Q29uZmlnID0gcmVxLmNhY2hlIHx8IHt9O1xuXG4gIGlmIChyZXF1ZXN0Q29uZmlnKSB7XG4gICAgZGlzYWxsb3dlZFBlclJlcXVlc3RLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIHJlcXVlc3RDb25maWdba2V5XSA/IGRlbGV0ZSByZXF1ZXN0Q29uZmlnW2tleV0gOiB1bmRlZmluZWQ7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgbWVyZ2VkQ29uZmlnID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGNvbmZpZyksIHJlcXVlc3RDb25maWcpLCB7fSwge1xuICAgIGV4Y2x1ZGU6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgY29uZmlnLmV4Y2x1ZGUpLCByZXF1ZXN0Q29uZmlnLmV4Y2x1ZGUpXG4gIH0pO1xuXG4gIGlmIChtZXJnZWRDb25maWcuZGVidWcgPT09IHRydWUpIHtcbiAgICBtZXJnZWRDb25maWcuZGVidWcgPSBkZWJ1ZztcbiAgfSAvLyBDcmVhdGUgYSBjYWNoZSBrZXkgbWV0aG9kXG5cblxuICBpZiAocmVxdWVzdENvbmZpZy5rZXkpIHtcbiAgICBtZXJnZWRDb25maWcua2V5ID0gT2JqZWN0KF9jYWNoZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wia2V5XCJdKShyZXF1ZXN0Q29uZmlnKTtcbiAgfSAvLyBHZW5lcmF0ZSByZXF1ZXN0IFVVSURcblxuXG4gIG1lcmdlZENvbmZpZy51dWlkID0gbWVyZ2VkQ29uZmlnLmtleShyZXEpO1xuICBjb25maWcuZGVidWcoXCJSZXF1ZXN0IGNvbmZpZyBmb3IgXCIuY29uY2F0KHJlcS51cmwpLCBtZXJnZWRDb25maWcpO1xuICByZXR1cm4gbWVyZ2VkQ29uZmlnO1xufTtcblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKHtcbiAgZGVmYXVsdHM6IGRlZmF1bHRzLFxuICBtYWtlQ29uZmlnOiBtYWtlQ29uZmlnLFxuICBtZXJnZVJlcXVlc3RDb25maWc6IG1lcmdlUmVxdWVzdENvbmZpZ1xufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2V4Y2x1ZGUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9leGNsdWRlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X2FycmF5X2l0ZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X2FycmF5X2l0ZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzNl9hcnJheV9pdGVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X29iamVjdF90b19zdHJpbmdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZy5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X29iamVjdF90b19zdHJpbmdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXM2X29iamVjdF90b19zdHJpbmdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzN19hcnJheV9pbmNsdWRlc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzNy5hcnJheS5pbmNsdWRlcyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcuYXJyYXkuaW5jbHVkZXMuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzN19hcnJheV9pbmNsdWRlc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lczdfYXJyYXlfaW5jbHVkZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzNl9zdHJpbmdfaW5jbHVkZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lczYuc3RyaW5nLmluY2x1ZGVzICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5zdHJpbmcuaW5jbHVkZXMuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzNl9zdHJpbmdfaW5jbHVkZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXM2X3N0cmluZ19pbmNsdWRlc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbGl0aWVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWxpdGllcyAqLyBcIi4vc3JjL3V0aWxpdGllcy5qc1wiKTtcblxuXG5cblxuXG5cbmZ1bmN0aW9uIGV4Y2x1ZGUoKSB7XG4gIHZhciBjb25maWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICB2YXIgcmVxID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gIHZhciBfY29uZmlnJGV4Y2x1ZGUgPSBjb25maWcuZXhjbHVkZSxcbiAgICAgIGV4Y2x1ZGUgPSBfY29uZmlnJGV4Y2x1ZGUgPT09IHZvaWQgMCA/IHt9IDogX2NvbmZpZyRleGNsdWRlLFxuICAgICAgZGVidWcgPSBjb25maWcuZGVidWc7XG4gIHZhciBtZXRob2QgPSByZXEubWV0aG9kLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKG1ldGhvZCA9PT0gJ2hlYWQnIHx8IGV4Y2x1ZGUubWV0aG9kcy5pbmNsdWRlcyhtZXRob2QpKSB7XG4gICAgZGVidWcoXCJFeGNsdWRpbmcgcmVxdWVzdCBieSBIVFRQIG1ldGhvZCBcIi5jb25jYXQocmVxLnVybCkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBleGNsdWRlLmZpbHRlciA9PT0gJ2Z1bmN0aW9uJyAmJiBleGNsdWRlLmZpbHRlcihyZXEpKSB7XG4gICAgZGVidWcoXCJFeGNsdWRpbmcgcmVxdWVzdCBieSBmaWx0ZXIgXCIuY29uY2F0KHJlcS51cmwpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBkbyBub3QgY2FjaGUgcmVxdWVzdCB3aXRoIHF1ZXJ5XG5cblxuICB2YXIgaGFzUXVlcnlQYXJhbXMgPSAvXFw/LiokLy50ZXN0KHJlcS51cmwpIHx8IE9iamVjdChfdXRpbGl0aWVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJpc09iamVjdFwiXSkocmVxLnBhcmFtcykgJiYgT2JqZWN0LmtleXMocmVxLnBhcmFtcykubGVuZ3RoICE9PSAwIHx8IHR5cGVvZiBVUkxTZWFyY2hQYXJhbXMgIT09ICd1bmRlZmluZWQnICYmIHJlcS5wYXJhbXMgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXM7XG5cbiAgaWYgKGV4Y2x1ZGUucXVlcnkgJiYgaGFzUXVlcnlQYXJhbXMpIHtcbiAgICBkZWJ1ZyhcIkV4Y2x1ZGluZyByZXF1ZXN0IGJ5IHF1ZXJ5IFwiLmNvbmNhdChyZXEudXJsKSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgcGF0aHMgPSBleGNsdWRlLnBhdGhzIHx8IFtdO1xuICB2YXIgZm91bmQgPSBwYXRocy5zb21lKGZ1bmN0aW9uIChyZWdleHApIHtcbiAgICByZXR1cm4gcmVxLnVybC5tYXRjaChyZWdleHApO1xuICB9KTtcblxuICBpZiAoZm91bmQpIHtcbiAgICBkZWJ1ZyhcIkV4Y2x1ZGluZyByZXF1ZXN0IGJ5IHVybCBtYXRjaCBcIi5jb25jYXQocmVxLnVybCkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKGV4Y2x1ZGUpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9pbmRleC5ub2RlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvaW5kZXgubm9kZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IHNldHVwLCBzZXR1cENhY2hlLCBzZXJpYWxpemVRdWVyeSwgUmVkaXNTdG9yZSwgUmVkaXNEZWZhdWx0U3RvcmUsIGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2FwaV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9hcGkgKi8gXCIuL3NyYy9hcGkuanNcIik7XG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJzZXR1cFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9hcGlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcInNldHVwXCJdOyB9KTtcblxuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwic2V0dXBDYWNoZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9hcGlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcInNldHVwQ2FjaGVcIl07IH0pO1xuXG4vKiBoYXJtb255IHJlZXhwb3J0IChzYWZlKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJzZXJpYWxpemVRdWVyeVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9hcGlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcInNlcmlhbGl6ZVF1ZXJ5XCJdOyB9KTtcblxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9yZWRpc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9yZWRpcyAqLyBcIi4vc3JjL3JlZGlzLmpzXCIpO1xuLyogaGFybW9ueSByZWV4cG9ydCAoc2FmZSkgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiUmVkaXNTdG9yZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9yZWRpc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wiZGVmYXVsdFwiXTsgfSk7XG5cbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcmVkaXNfZGVmYXVsdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9yZWRpcy1kZWZhdWx0ICovIFwiLi9zcmMvcmVkaXMtZGVmYXVsdC5qc1wiKTtcbi8qIGhhcm1vbnkgcmVleHBvcnQgKHNhZmUpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlJlZGlzRGVmYXVsdFN0b3JlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX3JlZGlzX2RlZmF1bHRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl07IH0pO1xuXG5cblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICBzZXR1cDogX2FwaV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wic2V0dXBcIl0sXG4gIHNldHVwQ2FjaGU6IF9hcGlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcInNldHVwQ2FjaGVcIl0sXG4gIHNlcmlhbGl6ZVF1ZXJ5OiBfYXBpX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJzZXJpYWxpemVRdWVyeVwiXSxcbiAgUmVkaXNTdG9yZTogX3JlZGlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJkZWZhdWx0XCJdLFxuICBSZWRpc0RlZmF1bHRTdG9yZTogX3JlZGlzX2RlZmF1bHRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl1cbn0pO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9saW1pdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9saW1pdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHJlZ2VuZXJhdG9yX3J1bnRpbWVfcnVudGltZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lICovIFwiLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHJlZ2VuZXJhdG9yX3J1bnRpbWVfcnVudGltZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHJlZ2VuZXJhdG9yX3J1bnRpbWVfcnVudGltZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X29iamVjdF90b19zdHJpbmdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZy5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X29iamVjdF90b19zdHJpbmdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXM2X29iamVjdF90b19zdHJpbmdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XG5cblxuXG5mdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTsgfSB9XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBzZWxmID0gdGhpcywgYXJncyA9IGFyZ3VtZW50czsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpOyBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkgeyBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7IH0gZnVuY3Rpb24gX3Rocm93KGVycikgeyBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTsgfSBfbmV4dCh1bmRlZmluZWQpOyB9KTsgfTsgfVxuXG5mdW5jdGlvbiBsaW1pdChfeCkge1xuICByZXR1cm4gX2xpbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9saW1pdCgpIHtcbiAgX2xpbWl0ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKGNvbmZpZykge1xuICAgIHZhciBsZW5ndGgsIGZpcnN0SXRlbTtcbiAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjtcbiAgICAgICAgICAgIHJldHVybiBjb25maWcuc3RvcmUubGVuZ3RoKCk7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBsZW5ndGggPSBfY29udGV4dC5zZW50O1xuXG4gICAgICAgICAgICBpZiAoIShsZW5ndGggPCBjb25maWcubGltaXQpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA1O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiKTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIGNvbmZpZy5kZWJ1ZyhcIkN1cnJlbnQgc3RvcmUgc2l6ZTogXCIuY29uY2F0KGxlbmd0aCkpO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDg7XG4gICAgICAgICAgICByZXR1cm4gY29uZmlnLnN0b3JlLml0ZXJhdGUoZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgICAgaWYgKCFmaXJzdEl0ZW0pIGZpcnN0SXRlbSA9IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAga2V5OiBrZXlcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlLmV4cGlyZXMgPCBmaXJzdEl0ZW0udmFsdWUuZXhwaXJlcykgZmlyc3RJdGVtID0ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBrZXk6IGtleVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBpZiAoIWZpcnN0SXRlbSkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25maWcuZGVidWcoXCJSZW1vdmluZyBpdGVtOiBcIi5jb25jYXQoZmlyc3RJdGVtLmtleSkpO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEyO1xuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy5zdG9yZS5yZW1vdmVJdGVtKGZpcnN0SXRlbS5rZXkpO1xuXG4gICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9saW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKGxpbWl0KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvbWVtb3J5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy9tZW1vcnkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzNl9hcnJheV9pdGVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvciAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzNl9hcnJheV9pdGVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lczZfYXJyYXlfaXRlcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzNl9vYmplY3RfdG9fc3RyaW5nX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzNl9vYmplY3RfdG9fc3RyaW5nX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzNl9vYmplY3RfdG9fc3RyaW5nX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHJlZ2VuZXJhdG9yX3J1bnRpbWVfcnVudGltZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lICovIFwiLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHJlZ2VuZXJhdG9yX3J1bnRpbWVfcnVudGltZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHJlZ2VuZXJhdG9yX3J1bnRpbWVfcnVudGltZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbGl0aWVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWxpdGllcyAqLyBcIi4vc3JjL3V0aWxpdGllcy5qc1wiKTtcblxuXG5cblxuZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykgeyB0cnkgeyB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7IHZhciB2YWx1ZSA9IGluZm8udmFsdWU7IH0gY2F0Y2ggKGVycm9yKSB7IHJlamVjdChlcnJvcik7IHJldHVybjsgfSBpZiAoaW5mby5kb25lKSB7IHJlc29sdmUodmFsdWUpOyB9IGVsc2UgeyBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7IH0gfVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgc2VsZiA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTsgZnVuY3Rpb24gX25leHQodmFsdWUpIHsgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpOyB9IGZ1bmN0aW9uIF90aHJvdyhlcnIpIHsgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7IH0gX25leHQodW5kZWZpbmVkKTsgfSk7IH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5cblxudmFyIE1lbW9yeVN0b3JlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTWVtb3J5U3RvcmUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1lbW9yeVN0b3JlKTtcblxuICAgIHRoaXMuc3RvcmUgPSB7fTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhNZW1vcnlTdG9yZSwgW3tcbiAgICBrZXk6IFwiZ2V0SXRlbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldEl0ZW0gPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoa2V5KSB7XG4gICAgICAgIHZhciBpdGVtO1xuICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgaXRlbSA9IHRoaXMuc3RvcmVba2V5XSB8fCBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgSlNPTi5wYXJzZShpdGVtKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBnZXRJdGVtKF94KSB7XG4gICAgICAgIHJldHVybiBfZ2V0SXRlbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2V0SXRlbTtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJzZXRJdGVtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfc2V0SXRlbSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoa2V5LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHRoaXMuc3RvcmVba2V5XSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCB2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHNldEl0ZW0oX3gyLCBfeDMpIHtcbiAgICAgICAgcmV0dXJuIF9zZXRJdGVtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZXRJdGVtO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZUl0ZW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZW1vdmVJdGVtID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zdG9yZVtrZXldO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTMsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiByZW1vdmVJdGVtKF94NCkge1xuICAgICAgICByZXR1cm4gX3JlbW92ZUl0ZW0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlbW92ZUl0ZW07XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9jbGVhciA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoKSB7XG4gICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlNCQoX2NvbnRleHQ0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yZSA9IHt9O1xuXG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTQsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgcmV0dXJuIF9jbGVhci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xlYXI7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwibGVuZ3RoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfbGVuZ3RoID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlNSgpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU1JChfY29udGV4dDUpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDUucHJldiA9IF9jb250ZXh0NS5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCBPYmplY3Qua2V5cyh0aGlzLnN0b3JlKS5sZW5ndGgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTUsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiBfbGVuZ3RoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiaXRlcmF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpdGVyYXRlKGZuKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoT2JqZWN0KF91dGlsaXRpZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIm1hcE9iamVjdFwiXSkodGhpcy5zdG9yZSwgZm4pKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTWVtb3J5U3RvcmU7XG59KCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoTWVtb3J5U3RvcmUpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9yZWRpcy1kZWZhdWx0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvcmVkaXMtZGVmYXVsdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzNl9hcnJheV9pdGVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvciAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzNl9hcnJheV9pdGVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lczZfYXJyYXlfaXRlcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzNl9vYmplY3RfdG9fc3RyaW5nX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzNl9vYmplY3RfdG9fc3RyaW5nX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzNl9vYmplY3RfdG9fc3RyaW5nX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHJlZ2VuZXJhdG9yX3J1bnRpbWVfcnVudGltZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lICovIFwiLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHJlZ2VuZXJhdG9yX3J1bnRpbWVfcnVudGltZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHJlZ2VuZXJhdG9yX3J1bnRpbWVfcnVudGltZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X2Z1bmN0aW9uX2JpbmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24uYmluZCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24uYmluZC5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X2Z1bmN0aW9uX2JpbmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXM2X2Z1bmN0aW9uX2JpbmRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzNl9mdW5jdGlvbl9uYW1lX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLm5hbWUgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLm5hbWUuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzNl9mdW5jdGlvbl9uYW1lX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzNl9mdW5jdGlvbl9uYW1lX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHV0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHV0aWwgKi8gXCJ1dGlsXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHV0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubih1dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18pO1xuXG5cblxuXG5cblxuZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykgeyB0cnkgeyB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7IHZhciB2YWx1ZSA9IGluZm8udmFsdWU7IH0gY2F0Y2ggKGVycm9yKSB7IHJlamVjdChlcnJvcik7IHJldHVybjsgfSBpZiAoaW5mby5kb25lKSB7IHJlc29sdmUodmFsdWUpOyB9IGVsc2UgeyBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7IH0gfVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgc2VsZiA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTsgZnVuY3Rpb24gX25leHQodmFsdWUpIHsgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpOyB9IGZ1bmN0aW9uIF90aHJvdyhlcnIpIHsgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7IH0gX25leHQodW5kZWZpbmVkKTsgfSk7IH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5cblxudmFyIFJlZGlzRGVmYXVsdFN0b3JlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVkaXNEZWZhdWx0U3RvcmUoY2xpZW50KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlZGlzRGVmYXVsdFN0b3JlKTtcblxuICAgIHZhciBpbnZhbGlkQ2xpZW50RXJyb3IgPSBuZXcgVHlwZUVycm9yKCdGaXJzdCBwYXJhbWV0ZXIgbXVzdCBiZSBhIHZhbGlkIFJlZGlzQ2xpZW50IGluc3RhbmNlLicpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChjbGllbnQuY29uc3RydWN0b3IubmFtZSAhPT0gJ1JlZGlzQ2xpZW50Jykge1xuICAgICAgICB0aHJvdyBpbnZhbGlkQ2xpZW50RXJyb3I7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBpbnZhbGlkQ2xpZW50RXJyb3I7XG4gICAgfVxuXG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgdGhpcy5wcmVmaXggPSBvcHRpb25zLnByZWZpeCB8fCAnYXhpb3MtY2FjaGUnO1xuICAgIHRoaXMubWF4U2NhbkNvdW50ID0gb3B0aW9ucy5tYXhTY2FuQ291bnQgfHwgMTAwMDtcbiAgICB0aGlzLmdldEFzeW5jID0gT2JqZWN0KHV0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcInByb21pc2lmeVwiXSkoY2xpZW50LmdldCkuYmluZChjbGllbnQpO1xuICAgIHRoaXMucHNldGV4QXN5bmMgPSBPYmplY3QodXRpbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wicHJvbWlzaWZ5XCJdKShjbGllbnQucHNldGV4KS5iaW5kKGNsaWVudCk7XG4gICAgdGhpcy5kZWxBc3luYyA9IE9iamVjdCh1dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJwcm9taXNpZnlcIl0pKGNsaWVudC5kZWwpLmJpbmQoY2xpZW50KTtcbiAgICB0aGlzLnNjYW5Bc3luYyA9IE9iamVjdCh1dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJwcm9taXNpZnlcIl0pKGNsaWVudC5zY2FuKS5iaW5kKGNsaWVudCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUmVkaXNEZWZhdWx0U3RvcmUsIFt7XG4gICAga2V5OiBcImNhbGN1bGF0ZVRUTFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVUVEwodmFsdWUpIHtcbiAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuXG4gICAgICBpZiAodmFsdWUuZXhwaXJlcyAmJiB2YWx1ZS5leHBpcmVzID4gbm93KSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5leHBpcmVzIC0gbm93O1xuICAgICAgfSAvLyBJZiB0aGVyZSBpcyBubyBleHBpcmVzIGluIHZhbHVlIG9yIHRoZSBwcm92aWRlZCBleHBpcmUgaXMgYmVmb3JlIHRoZSBjdXJyZW50IHRpbWVcblxuXG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRyYW5zZm9ybUtleVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFuc2Zvcm1LZXkoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmVmaXggKyAnXycgKyBrZXk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEl0ZW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRJdGVtID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKGtleSkge1xuICAgICAgICB2YXIgaXRlbTtcbiAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFzeW5jKHRoaXMudHJhbnNmb3JtS2V5KGtleSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0LnNlbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoX2NvbnRleHQudDApIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA1O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQudDAgPSBudWxsO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICBpdGVtID0gX2NvbnRleHQudDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBKU09OLnBhcnNlKGl0ZW0pKTtcblxuICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGdldEl0ZW0oX3gpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRJdGVtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBnZXRJdGVtO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcInNldEl0ZW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9zZXRJdGVtID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMihrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciBjb21wdXRlZEtleSwgdHRsO1xuICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGNvbXB1dGVkS2V5ID0gdGhpcy50cmFuc2Zvcm1LZXkoa2V5KTtcbiAgICAgICAgICAgICAgICB0dGwgPSB0aGlzLmNhbGN1bGF0ZVRUTCh2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoISh0dGwgPiAwKSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA1O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA1O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBzZXRleEFzeW5jKGNvbXB1dGVkS2V5LCB0dGwsIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHZhbHVlKTtcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUyLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gc2V0SXRlbShfeDIsIF94Mykge1xuICAgICAgICByZXR1cm4gX3NldEl0ZW0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNldEl0ZW07XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlSXRlbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3JlbW92ZUl0ZW0gPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKGtleSkge1xuICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZWxBc3luYyh0aGlzLnRyYW5zZm9ybUtleShrZXkpKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUzLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gcmVtb3ZlSXRlbShfeDQpIHtcbiAgICAgICAgcmV0dXJuIF9yZW1vdmVJdGVtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZW1vdmVJdGVtO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcInNjYW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9zY2FuID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlNChvcGVyYXRpb24pIHtcbiAgICAgICAgdmFyIGN1cnNvciwgcmVwbHk7XG4gICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlNCQoX2NvbnRleHQ0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgY3Vyc29yID0gJzAnO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbkFzeW5jKGN1cnNvciwgJ01BVENIJywgdGhpcy50cmFuc2Zvcm1LZXkoJyonKSwgJ0NPVU5UJywgdGhpcy5tYXhTY2FuQ291bnQpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXBseSA9IF9jb250ZXh0NC5zZW50O1xuICAgICAgICAgICAgICAgIGN1cnNvciA9IHJlcGx5WzBdO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmF0aW9uKHJlcGx5WzFdKTtcblxuICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvciAhPT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDE7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNCwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHNjYW4oX3g1KSB7XG4gICAgICAgIHJldHVybiBfc2Nhbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2NhbjtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJjbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2NsZWFyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlNSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTUkKF9jb250ZXh0NSkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NS5wcmV2ID0gX2NvbnRleHQ1Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FuKGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZGVsQXN5bmMoa2V5cyk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgICByZXR1cm4gX2NsZWFyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjbGVhcjtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJsZW5ndGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9sZW5ndGggPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU2KCkge1xuICAgICAgICB2YXIgbGVuZ3RoO1xuICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTYkKF9jb250ZXh0Nikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ni5wcmV2ID0gX2NvbnRleHQ2Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW4oZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgICAgICAgICAgIGxlbmd0aCArPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIiwgbGVuZ3RoKTtcblxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU2LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gX2xlbmd0aC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcIml0ZXJhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9pdGVyYXRlID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlOChmbikge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICB2YXIgcnVuRnVuY3Rpb24sIF9ydW5GdW5jdGlvbjtcblxuICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTgkKF9jb250ZXh0OCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0OC5wcmV2ID0gX2NvbnRleHQ4Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9ydW5GdW5jdGlvbiA9IGZ1bmN0aW9uIF9ydW5GdW5jdGlvbjMoKSB7XG4gICAgICAgICAgICAgICAgICBfcnVuRnVuY3Rpb24gPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU3KGtleSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSwgdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlNyQoX2NvbnRleHQ3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ3LnByZXYgPSBfY29udGV4dDcubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFzeW5jKGtleSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ny50MCA9IF9jb250ZXh0Ny5zZW50O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9jb250ZXh0Ny50MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ3LnQwID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9IF9jb250ZXh0Ny50MDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IEpTT04ucGFyc2UoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSA5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmbih2YWx1ZSwga2V5KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQ3LnNlbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIF9jYWxsZWU3LCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfcnVuRnVuY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcnVuRnVuY3Rpb24gPSBmdW5jdGlvbiBfcnVuRnVuY3Rpb24yKF94Nykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9ydW5GdW5jdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NhbihmdW5jdGlvbiAoa2V5cykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGtleXMubWFwKHJ1bkZ1bmN0aW9uLmJpbmQoX3RoaXMyKSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LmFicnVwdChcInJldHVyblwiLCBQcm9taXNlLnJlc29sdmUoW10pKTtcblxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU4LCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gaXRlcmF0ZShfeDYpIHtcbiAgICAgICAgcmV0dXJuIF9pdGVyYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpdGVyYXRlO1xuICAgIH0oKVxuICB9XSk7XG5cbiAgcmV0dXJuIFJlZGlzRGVmYXVsdFN0b3JlO1xufSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKFJlZGlzRGVmYXVsdFN0b3JlKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvcmVkaXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvcmVkaXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKiovXG4vKiEgZXhwb3J0cyBwcm92aWRlZDogZGVmYXVsdCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X2FycmF5X2l0ZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5Lml0ZXJhdG9yICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X2FycmF5X2l0ZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzNl9hcnJheV9pdGVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X29iamVjdF90b19zdHJpbmdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZy5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X29iamVjdF90b19zdHJpbmdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXM2X29iamVjdF90b19zdHJpbmdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcmVnZW5lcmF0b3JfcnVudGltZV9ydW50aW1lX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISByZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUgKi8gXCIuL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcmVnZW5lcmF0b3JfcnVudGltZV9ydW50aW1lX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4ocmVnZW5lcmF0b3JfcnVudGltZV9ydW50aW1lX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfZnVuY3Rpb25fYmluZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5iaW5kICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5mdW5jdGlvbi5iaW5kLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfZnVuY3Rpb25fYmluZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lczZfZnVuY3Rpb25fYmluZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X2Z1bmN0aW9uX25hbWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24ubmFtZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24ubmFtZS5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X2Z1bmN0aW9uX25hbWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXM2X2Z1bmN0aW9uX25hbWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgdXRpbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgdXRpbCAqLyBcInV0aWxcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgdXRpbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHV0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxpdGllc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlsaXRpZXMgKi8gXCIuL3NyYy91dGlsaXRpZXMuanNcIik7XG5cblxuXG5cblxuXG5mdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTsgfSB9XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBzZWxmID0gdGhpcywgYXJncyA9IGFyZ3VtZW50czsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpOyBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkgeyBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7IH0gZnVuY3Rpb24gX3Rocm93KGVycikgeyBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTsgfSBfbmV4dCh1bmRlZmluZWQpOyB9KTsgfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cblxuXG5cbnZhciBSZWRpc1N0b3JlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVkaXNTdG9yZShjbGllbnQpIHtcbiAgICB2YXIgSEFTSF9LRVkgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICdheGlvcy1jYWNoZSc7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVkaXNTdG9yZSk7XG5cbiAgICB2YXIgaW52YWxpZENsaWVudEVycm9yID0gbmV3IFR5cGVFcnJvcignRmlyc3QgcGFyYW1ldGVyIG11c3QgYmUgYSB2YWxpZCBSZWRpc0NsaWVudCBpbnN0YW5jZS4nKTtcblxuICAgIHRyeSB7XG4gICAgICBpZiAoY2xpZW50LmNvbnN0cnVjdG9yLm5hbWUgIT09ICdSZWRpc0NsaWVudCcpIHtcbiAgICAgICAgdGhyb3cgaW52YWxpZENsaWVudEVycm9yO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgaW52YWxpZENsaWVudEVycm9yO1xuICAgIH1cblxuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMuSEFTSF9LRVkgPSBIQVNIX0tFWTtcbiAgICB0aGlzLmhnZXRBc3luYyA9IE9iamVjdCh1dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJwcm9taXNpZnlcIl0pKGNsaWVudC5oZ2V0KS5iaW5kKGNsaWVudCk7XG4gICAgdGhpcy5oc2V0QXN5bmMgPSBPYmplY3QodXRpbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wicHJvbWlzaWZ5XCJdKShjbGllbnQuaHNldCkuYmluZChjbGllbnQpO1xuICAgIHRoaXMuaGRlbEFzeW5jID0gT2JqZWN0KHV0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcInByb21pc2lmeVwiXSkoY2xpZW50LmhkZWwpLmJpbmQoY2xpZW50KTtcbiAgICB0aGlzLmRlbEFzeW5jID0gT2JqZWN0KHV0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcInByb21pc2lmeVwiXSkoY2xpZW50LmRlbCkuYmluZChjbGllbnQpO1xuICAgIHRoaXMuaGxlbkFzeW5jID0gT2JqZWN0KHV0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcInByb21pc2lmeVwiXSkoY2xpZW50LmhsZW4pLmJpbmQoY2xpZW50KTtcbiAgICB0aGlzLmhnZXRhbGxBc3luYyA9IE9iamVjdCh1dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJwcm9taXNpZnlcIl0pKGNsaWVudC5oZ2V0YWxsKS5iaW5kKGNsaWVudCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUmVkaXNTdG9yZSwgW3tcbiAgICBrZXk6IFwiZ2V0SXRlbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldEl0ZW0gPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoa2V5KSB7XG4gICAgICAgIHZhciBpdGVtO1xuICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGdldEFzeW5jKHRoaXMuSEFTSF9LRVksIGtleSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHQuc2VudDtcblxuICAgICAgICAgICAgICAgIGlmIChfY29udGV4dC50MCkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dC50MCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIGl0ZW0gPSBfY29udGV4dC50MDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIEpTT04ucGFyc2UoaXRlbSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gZ2V0SXRlbShfeCkge1xuICAgICAgICByZXR1cm4gX2dldEl0ZW0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdldEl0ZW07XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0SXRlbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3NldEl0ZW0gPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKGtleSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaHNldEFzeW5jKHRoaXMuSEFTSF9LRVksIGtleSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgdmFsdWUpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBzZXRJdGVtKF94MiwgX3gzKSB7XG4gICAgICAgIHJldHVybiBfc2V0SXRlbS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2V0SXRlbTtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVJdGVtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcmVtb3ZlSXRlbSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoa2V5KSB7XG4gICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhkZWxBc3luYyh0aGlzLkhBU0hfS0VZLCBrZXkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTMsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiByZW1vdmVJdGVtKF94NCkge1xuICAgICAgICByZXR1cm4gX3JlbW92ZUl0ZW0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlbW92ZUl0ZW07XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9jbGVhciA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoKSB7XG4gICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlNCQoX2NvbnRleHQ0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlbEFzeW5jKHRoaXMuSEFTSF9LRVkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTQsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgcmV0dXJuIF9jbGVhci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xlYXI7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwibGVuZ3RoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfbGVuZ3RoID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlNSgpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU1JChfY29udGV4dDUpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDUucHJldiA9IF9jb250ZXh0NS5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiLCB0aGlzLmhsZW5Bc3luYyh0aGlzLkhBU0hfS0VZKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIF9sZW5ndGguYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJpdGVyYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfaXRlcmF0ZSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTYoZm4pIHtcbiAgICAgICAgdmFyIGhhc2hEYXRhO1xuICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTYkKF9jb250ZXh0Nikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ni5wcmV2ID0gX2NvbnRleHQ2Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oZ2V0YWxsQXN5bmModGhpcy5IQVNIX0tFWSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGhhc2hEYXRhID0gX2NvbnRleHQ2LnNlbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5hYnJ1cHQoXCJyZXR1cm5cIiwgUHJvbWlzZS5hbGwoT2JqZWN0KF91dGlsaXRpZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcIm1hcE9iamVjdFwiXSkoaGFzaERhdGEsIGZuKSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTYsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBpdGVyYXRlKF94NSkge1xuICAgICAgICByZXR1cm4gX2l0ZXJhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGl0ZXJhdGU7XG4gICAgfSgpXG4gIH1dKTtcblxuICByZXR1cm4gUmVkaXNTdG9yZTtcbn0oKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChSZWRpc1N0b3JlKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvcmVxdWVzdC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3JlcXVlc3QuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHJlZ2VuZXJhdG9yX3J1bnRpbWVfcnVudGltZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lICovIFwiLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHJlZ2VuZXJhdG9yX3J1bnRpbWVfcnVudGltZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHJlZ2VuZXJhdG9yX3J1bnRpbWVfcnVudGltZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X29iamVjdF90b19zdHJpbmdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZyAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZy5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM2X29iamVjdF90b19zdHJpbmdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjb3JlX2pzX21vZHVsZXNfZXM2X29iamVjdF90b19zdHJpbmdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3Jlc3BvbnNlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3Jlc3BvbnNlICovIFwiLi9zcmMvcmVzcG9uc2UuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2V4Y2x1ZGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZXhjbHVkZSAqLyBcIi4vc3JjL2V4Y2x1ZGUuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NhY2hlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NhY2hlICovIFwiLi9zcmMvY2FjaGUuanNcIik7XG5cblxuXG5mdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTsgfSB9XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBzZWxmID0gdGhpcywgYXJncyA9IGFyZ3VtZW50czsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpOyBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkgeyBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7IH0gZnVuY3Rpb24gX3Rocm93KGVycikgeyBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTsgfSBfbmV4dCh1bmRlZmluZWQpOyB9KTsgfTsgfVxuXG5cblxuXG5cbmZ1bmN0aW9uIHJlcXVlc3QoX3gsIF94Mikge1xuICByZXR1cm4gX3JlcXVlc3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX3JlcXVlc3QoKSB7XG4gIF9yZXF1ZXN0ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKGNvbmZpZywgcmVxKSB7XG4gICAgdmFyIG5leHQsIHJlcywgZXhjbHVkZUZyb21DYWNoZTtcbiAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBleGNsdWRlRnJvbUNhY2hlID0gZnVuY3Rpb24gX2V4Y2x1ZGVGcm9tQ2FjaGUoKSB7XG4gICAgICAgICAgICAgIGNvbmZpZy5leGNsdWRlRnJvbUNhY2hlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgICAgICAgICBuZXh0OiBuZXh0XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb25maWcuZGVidWcoJ3V1aWQnLCBjb25maWcudXVpZCk7XG5cbiAgICAgICAgICAgIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIF9yZXNwb25zZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiZGVmYXVsdFwiXS5hcHBseSh2b2lkIDAsIFtjb25maWcsIHJlcV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgICAgIH07IC8vIHJ1biBpbnZhbGlkYXRlIGZ1bmN0aW9uIHRvIGNoZWNrIGlmIGFueSBjYWNoZSBpdGVtcyBuZWVkIHRvIGJlIGludmFsaWRhdGVkLlxuXG5cbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA1O1xuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy5pbnZhbGlkYXRlKGNvbmZpZywgcmVxKTtcblxuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIGlmICghT2JqZWN0KF9leGNsdWRlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXCJkZWZhdWx0XCJdKShjb25maWcsIHJlcSkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGV4Y2x1ZGVGcm9tQ2FjaGUoKSk7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gNztcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMDtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QoX2NhY2hlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJyZWFkXCJdKShjb25maWcsIHJlcSk7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgcmVzID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgIHJlcy5jb25maWcgPSByZXE7XG4gICAgICAgICAgICByZXMucmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgZnJvbUNhY2hlOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICAgICAgICBuZXh0OiByZXNcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxNjtcbiAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSg3KTtcblxuICAgICAgICAgICAgaWYgKCEoY29uZmlnLmNsZWFyT25TdGFsZSAmJiBfY29udGV4dC50MC5yZWFzb24gPT09ICdjYWNoZS1zdGFsZScpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyMTtcbiAgICAgICAgICAgIHJldHVybiBjb25maWcuc3RvcmUucmVtb3ZlSXRlbShjb25maWcudXVpZCk7XG5cbiAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICAgICAgICBuZXh0OiBuZXh0XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUsIG51bGwsIFtbNywgMTZdXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9yZXF1ZXN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAocmVxdWVzdCk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3Jlc3BvbnNlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL3Jlc3BvbnNlLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGRlZmF1bHQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcmVnZW5lcmF0b3JfcnVudGltZV9ydW50aW1lX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISByZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUgKi8gXCIuL25vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcmVnZW5lcmF0b3JfcnVudGltZV9ydW50aW1lX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4ocmVnZW5lcmF0b3JfcnVudGltZV9ydW50aW1lX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfb2JqZWN0X3RvX3N0cmluZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nICovIFwiLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfb2JqZWN0X3RvX3N0cmluZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lczZfb2JqZWN0X3RvX3N0cmluZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbGltaXRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vbGltaXQgKi8gXCIuL3NyYy9saW1pdC5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY2FjaGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY2FjaGUgKi8gXCIuL3NyYy9jYWNoZS5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjYWNoZV9jb250cm9sX2VzbV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY2FjaGUtY29udHJvbC1lc20gKi8gXCIuL25vZGVfbW9kdWxlcy9jYWNoZS1jb250cm9sLWVzbS9pbmRleC5qc1wiKTtcblxuXG5cbmZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHsgdHJ5IHsgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOyB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOyB9IGNhdGNoIChlcnJvcikgeyByZWplY3QoZXJyb3IpOyByZXR1cm47IH0gaWYgKGluZm8uZG9uZSkgeyByZXNvbHZlKHZhbHVlKTsgfSBlbHNlIHsgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpOyB9IH1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIHNlbGYgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzOyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7IGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7IGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTsgfSBmdW5jdGlvbiBfdGhyb3coZXJyKSB7IGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpOyB9IF9uZXh0KHVuZGVmaW5lZCk7IH0pOyB9OyB9XG5cblxuXG5cblxuZnVuY3Rpb24gcmVzcG9uc2UoX3gsIF94MiwgX3gzKSB7XG4gIHJldHVybiBfcmVzcG9uc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX3Jlc3BvbnNlKCkge1xuICBfcmVzcG9uc2UgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoY29uZmlnLCByZXEsIHJlcykge1xuICAgIHZhciBfcmVzJHJlcXVlc3QsIHJlcXVlc3QsIF9yZXMkaGVhZGVycywgaGVhZGVycywgY2FjaGVDb250cm9sO1xuXG4gICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgX3JlcyRyZXF1ZXN0ID0gcmVzLnJlcXVlc3QsIHJlcXVlc3QgPSBfcmVzJHJlcXVlc3QgPT09IHZvaWQgMCA/IHt9IDogX3JlcyRyZXF1ZXN0LCBfcmVzJGhlYWRlcnMgPSByZXMuaGVhZGVycywgaGVhZGVycyA9IF9yZXMkaGVhZGVycyA9PT0gdm9pZCAwID8ge30gOiBfcmVzJGhlYWRlcnM7IC8vIGV4Y2x1ZGUgYmluYXJ5IHJlc3BvbnNlIGZyb20gY2FjaGVcblxuICAgICAgICAgICAgaWYgKCEoWydhcnJheWJ1ZmZlcicsICdibG9iJ10uaW5kZXhPZihyZXF1ZXN0LnJlc3BvbnNlVHlwZSkgPiAtMSkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHJlcyk7XG5cbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYWNoZUNvbnRyb2wgPSB7fTsgLy8gU2hvdWxkIHdlIHRyeSB0byBkZXRlcm1pbmUgcmVxdWVzdCBjYWNoZSBleHBpcmF0aW9uIGZyb20gaGVhZGVycyBvciBub3RcblxuICAgICAgICAgICAgaWYgKGNvbmZpZy5yZWFkSGVhZGVycykge1xuICAgICAgICAgICAgICBpZiAoaGVhZGVyc1snY2FjaGUtY29udHJvbCddKSB7XG4gICAgICAgICAgICAgICAgLy8gVHJ5IHBhcnNpbmcgYGNhY2hlLWNvbnRyb2xgIGhlYWRlciBmcm9tIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgY2FjaGVDb250cm9sID0gT2JqZWN0KGNhY2hlX2NvbnRyb2xfZXNtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJwYXJzZVwiXSkoaGVhZGVyc1snY2FjaGUtY29udHJvbCddKTsgLy8gRm9yY2UgY2FjaGUgZXhsY3VzaW9uIGZvciBgY2FjaGUtY29udHJvbDogbm8tY2FjaGVgIGFuZCBgY2FjaGUtY29udHJvbDogbm8tc3RvcmVgXG5cbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVDb250cm9sLm5vQ2FjaGUgfHwgY2FjaGVDb250cm9sLm5vU3RvcmUpIHtcbiAgICAgICAgICAgICAgICAgIGNvbmZpZy5leGNsdWRlRnJvbUNhY2hlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGVhZGVycy5leHBpcmVzKSB7XG4gICAgICAgICAgICAgICAgLy8gRWxzZSB0cnkgcmVhZGluZyBgZXhwaXJlc2AgaGVhZGVyXG4gICAgICAgICAgICAgICAgY29uZmlnLmV4cGlyZXMgPSBuZXcgRGF0ZShoZWFkZXJzLmV4cGlyZXMpLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25maWcuZXhwaXJlcyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjb25maWcuZXhjbHVkZUZyb21DYWNoZSkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2FjaGVDb250cm9sLm1heEFnZSB8fCBjYWNoZUNvbnRyb2wubWF4QWdlID09PSAwKSB7XG4gICAgICAgICAgICAgIC8vIFVzZSBgY2FjaGUtY29udHJvbGAgaGVhZGVyIGBtYXgtYWdlYCB2YWx1ZSBhbmQgY29udmVydCB0byBtaWxsaXNlY29uZHNcbiAgICAgICAgICAgICAgY29uZmlnLmV4cGlyZXMgPSBEYXRlLm5vdygpICsgY2FjaGVDb250cm9sLm1heEFnZSAqIDEwMDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFjb25maWcucmVhZEhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgLy8gVXNlIGZpeGVkIGBtYXhBZ2VgIGRlZmluZWQgaW4gdGhlIGdsb2JhbCBvciBwZXItcmVxdWVzdCBjb25maWdcbiAgICAgICAgICAgICAgY29uZmlnLmV4cGlyZXMgPSBjb25maWcubWF4QWdlID09PSAwID8gRGF0ZS5ub3coKSA6IERhdGUubm93KCkgKyBjb25maWcubWF4QWdlO1xuICAgICAgICAgICAgfSAvLyBDaGVjayBpZiBhIGNhY2hlIGxpbWl0IGhhcyBiZWVuIGNvbmZpZ3VyZWRcblxuXG4gICAgICAgICAgICBpZiAoIWNvbmZpZy5saW1pdCkge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25maWcuZGVidWcoXCJEZXRlY3RlZCBsaW1pdDogXCIuY29uY2F0KGNvbmZpZy5saW1pdCkpO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDExO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdChfbGltaXRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcImRlZmF1bHRcIl0pKGNvbmZpZyk7XG5cbiAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEzO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdChfY2FjaGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIndyaXRlXCJdKShjb25maWcsIHJlcSwgcmVzKTtcblxuICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTY7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAvLyBNYXJrIHJlcXVlc3QgYXMgZXhjbHVkZWQgZnJvbSBjYWNoZVxuICAgICAgICAgICAgcmVzLnJlcXVlc3QuZXhjbHVkZWRGcm9tQ2FjaGUgPSB0cnVlO1xuXG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzKTtcblxuICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUpO1xuICB9KSk7XG4gIHJldHVybiBfcmVzcG9uc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChyZXNwb25zZSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3NlcmlhbGl6ZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvc2VyaWFsaXplLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBleHBvcnRzIHByb3ZpZGVkOiBkZWZhdWx0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfc3ltYm9sX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvZXM2LnN5bWJvbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3ltYm9sLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfc3ltYm9sX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzNl9zeW1ib2xfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzNl9hcnJheV9pdGVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvciAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzNl9hcnJheV9pdGVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lczZfYXJyYXlfaXRlcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzNl9vYmplY3RfdG9fc3RyaW5nX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzNl9vYmplY3RfdG9fc3RyaW5nX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzNl9vYmplY3RfdG9fc3RyaW5nX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18pO1xuXG5cblxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IHt9OyB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7IHZhciBrZXksIGk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZUtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBzZXJpYWxpemUoY29uZmlnLCByZXEsIHJlcykge1xuICBpZiAocmVzLmRhdGEpIHtcbiAgICAvLyBGSVhNRTogTWF5IGJlIHVzZWxlc3MgYXMgbG9jYWxGb3JhZ2UgYW5kIGF4aW9zIGFscmVhZHkgcGFyc2UgYXV0b21hdGljYWxseVxuICAgIHRyeSB7XG4gICAgICByZXMuZGF0YSA9IEpTT04ucGFyc2UocmVzLmRhdGEpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uZmlnLmRlYnVnKCdDb3VsZCBub3QgcGFyc2UgZGF0YSBhcyBKU09OJywgZXJyKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcmVxdWVzdCA9IHJlcy5yZXF1ZXN0LFxuICAgICAgXyA9IHJlcy5jb25maWcsXG4gICAgICBzZXJpYWxpemVkID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHJlcywgW1wicmVxdWVzdFwiLCBcImNvbmZpZ1wiXSk7XG5cbiAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoc2VyaWFsaXplKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvdXRpbGl0aWVzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91dGlsaXRpZXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIGV4cG9ydHMgcHJvdmlkZWQ6IGlzT2JqZWN0LCBnZXRUYWcsIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBtYXBPYmplY3QgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaXNPYmplY3RcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc09iamVjdDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZ2V0VGFnXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZ2V0VGFnOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJpc0Z1bmN0aW9uXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gaXNGdW5jdGlvbjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaXNTdHJpbmdcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBpc1N0cmluZzsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibWFwT2JqZWN0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbWFwT2JqZWN0OyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM3X3N5bWJvbF9hc3luY19pdGVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvci5qc1wiKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb3JlX2pzX21vZHVsZXNfZXM3X3N5bWJvbF9hc3luY19pdGVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lczdfc3ltYm9sX2FzeW5jX2l0ZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfc3ltYm9sX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvZXM2LnN5bWJvbCAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuc3ltYm9sLmpzXCIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvcmVfanNfbW9kdWxlc19lczZfc3ltYm9sX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzNl9zeW1ib2xfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzNl9hcnJheV9pdGVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvciAqLyBcIi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzNl9hcnJheV9pdGVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvcmVfanNfbW9kdWxlc19lczZfYXJyYXlfaXRlcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzNl9vYmplY3RfdG9fc3RyaW5nX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcgKi8gXCIuL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcuanNcIik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY29yZV9qc19tb2R1bGVzX2VzNl9vYmplY3RfdG9fc3RyaW5nX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29yZV9qc19tb2R1bGVzX2VzNl9vYmplY3RfdG9fc3RyaW5nX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18pO1xuXG5cblxuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi9tYXN0ZXIvaXNPYmplY3QuanNcbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gX3R5cGVvZih2YWx1ZSk7XG5cbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT09ICdvYmplY3QnIHx8IHR5cGUgPT09ICdmdW5jdGlvbicpO1xufSAvLyBodHRwczovL2dpdGh1Yi5jb20vbG9kYXNoL2xvZGFzaC9ibG9iL21hc3Rlci8uaW50ZXJuYWwvZ2V0VGFnLmpzXG5cbmZ1bmN0aW9uIGdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/ICdbb2JqZWN0IFVuZGVmaW5lZF0nIDogJ1tvYmplY3QgTnVsbF0nO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9sb2Rhc2gvbG9kYXNoL2Jsb2IvbWFzdGVyL2lzRnVuY3Rpb24uanNcblxuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09PSAnW29iamVjdCBGdW5jdGlvbl0nIHx8IHRhZyA9PT0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nIHx8IHRhZyA9PT0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyB8fCB0YWcgPT09ICdbb2JqZWN0IFByb3h5XSc7XG59IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9sb2Rhc2gvbG9kYXNoL2Jsb2IvbWFzdGVyL2lzU3RyaW5nLmpzXG5cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gX3R5cGVvZih2YWx1ZSk7XG5cbiAgcmV0dXJuIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9IG51bGwgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xufVxuZnVuY3Rpb24gbWFwT2JqZWN0KHZhbHVlLCBmbikge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZSkubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gZm4odmFsdWVba2V5XSwga2V5KTtcbiAgfSk7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcImF4aW9zXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIGV4dGVybmFsIHtcInVtZFwiOlwiYXhpb3NcIixcImFtZFwiOlwiYXhpb3NcIixcImNvbW1vbmpzXCI6XCJheGlvc1wiLFwiY29tbW9uanMyXCI6XCJheGlvc1wifSAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qISBubyBzdGF0aWMgZXhwb3J0cyBmb3VuZCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfYXhpb3NfXztcblxuLyoqKi8gfSksXG5cbi8qKiovIFwidXRpbFwiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogZXh0ZXJuYWwgXCJ1dGlsXCIgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqL1xuLyohIG5vIHN0YXRpYyBleHBvcnRzIGZvdW5kICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInV0aWxcIik7XG5cbi8qKiovIH0pXG5cbi8qKioqKiovIH0pO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYWNoZS5ub2RlLmpzLm1hcCJdLCJuYW1lcyI6WyJ3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsInJvb3QiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsInJlcXVpcmUiLCJkZWZpbmUiLCJhbWQiLCJ1bmRlZmluZWQiLCJnbG9iYWwiLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2F4aW9zX18iLCJtb2R1bGVzIiwiaW5zdGFsbGVkTW9kdWxlcyIsIl9fd2VicGFja19yZXF1aXJlX18iLCJtb2R1bGVJZCIsImkiLCJsIiwiY2FsbCIsIm0iLCJjIiwiZCIsIm5hbWUiLCJnZXR0ZXIiLCJvIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiciIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwidmFsdWUiLCJ0IiwibW9kZSIsIl9fZXNNb2R1bGUiLCJucyIsImNyZWF0ZSIsImtleSIsImJpbmQiLCJuIiwiZ2V0RGVmYXVsdCIsImdldE1vZHVsZUV4cG9ydHMiLCJvYmplY3QiLCJwcm9wZXJ0eSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwicCIsInMiLCJfX3dlYnBhY2tfZXhwb3J0c19fIiwiQ2FjaGVDb250cm9sIiwicGFyc2UiLCJmb3JtYXQiLCJjb3JlX2pzX21vZHVsZXNfZXM2X2FycmF5X2Zyb21fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyIsImNvcmVfanNfbW9kdWxlc19lczZfYXJyYXlfZnJvbV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQiLCJjb3JlX2pzX21vZHVsZXNfZXM2X2Z1bmN0aW9uX25hbWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyIsImNvcmVfanNfbW9kdWxlc19lczZfZnVuY3Rpb25fbmFtZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQiLCJjb3JlX2pzX21vZHVsZXNfZXM2X29iamVjdF90b19zdHJpbmdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyIsImNvcmVfanNfbW9kdWxlc19lczZfb2JqZWN0X3RvX3N0cmluZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fX2RlZmF1bHQiLCJjb3JlX2pzX21vZHVsZXNfd2ViX2RvbV9pdGVyYWJsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fIiwiY29yZV9qc19tb2R1bGVzX3dlYl9kb21faXRlcmFibGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX19kZWZhdWx0IiwiY29yZV9qc19tb2R1bGVzX2VzN19zeW1ib2xfYXN5bmNfaXRlcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyIsImNvcmVfanNfbW9kdWxlc19lczdfc3ltYm9sX2FzeW5jX2l0ZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19fZGVmYXVsdCIsImNvcmVfanNfbW9kdWxlc19lczZfc3ltYm9sX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18iLCJjb3JlX2pzX21vZHVsZXNfZXM2X3N5bWJvbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fX2RlZmF1bHQiLCJjb3JlX2pzX21vZHVsZXNfZXM2X3JlZ2V4cF9zcGxpdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fIiwiY29yZV9qc19tb2R1bGVzX2VzNl9yZWdleHBfc3BsaXRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX19kZWZhdWx0IiwiY29yZV9qc19tb2R1bGVzX2VzNl9udW1iZXJfaXNfZmluaXRlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18iLCJjb3JlX2pzX21vZHVsZXNfZXM2X251bWJlcl9pc19maW5pdGVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX19kZWZhdWx0IiwiX3NsaWNlZFRvQXJyYXkiLCJhcnIiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVSZXN0IiwiVHlwZUVycm9yIiwibWluTGVuIiwiX2FycmF5TGlrZVRvQXJyYXkiLCJ0b1N0cmluZyIsInNsaWNlIiwiY29uc3RydWN0b3IiLCJBcnJheSIsImZyb20iLCJ0ZXN0IiwibGVuIiwibGVuZ3RoIiwiYXJyMiIsIml0ZXJhdG9yIiwiX2FyciIsIl9uIiwiX2QiLCJfZSIsIl9pIiwiX3MiLCJuZXh0IiwiZG9uZSIsInB1c2giLCJlcnIiLCJpc0FycmF5IiwiX2NsYXNzQ2FsbENoZWNrIiwiaW5zdGFuY2UiLCJDb25zdHJ1Y3RvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwidGFyZ2V0IiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfY3JlYXRlQ2xhc3MiLCJwcm90b1Byb3BzIiwic3RhdGljUHJvcHMiLCJIRUFERVJfUkVHRVhQIiwiU1RSSU5HUyIsIm1heEFnZSIsInNoYXJlZE1heEFnZSIsIm1heFN0YWxlIiwibWluRnJlc2giLCJpbW11dGFibGUiLCJtdXN0UmV2YWxpZGF0ZSIsIm5vQ2FjaGUiLCJub1N0b3JlIiwibm9UcmFuc2Zvcm0iLCJvbmx5SWZDYWNoZWQiLCJwcm94eVJldmFsaWRhdGUiLCJwYXJzZUJvb2xlYW5Pbmx5IiwicGFyc2VEdXJhdGlvbiIsImR1cmF0aW9uIiwicGFyc2VJbnQiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsIm1heFN0YWxlRHVyYXRpb24iLCJoZWFkZXIiLCJ2YWx1ZXMiLCJtYXRjaGVzIiwibWF0Y2giLCJmb3JFYWNoIiwidG9rZW5zIiwic3BsaXQiLCJfdG9rZW5zIiwidHJpbSIsInRvTG93ZXJDYXNlIiwiY29uY2F0Iiwiam9pbiIsImNjIiwiY2hhcmVuYyIsInV0ZjgiLCJzdHJpbmdUb0J5dGVzIiwic3RyIiwiYmluIiwidW5lc2NhcGUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJieXRlc1RvU3RyaW5nIiwiYnl0ZXMiLCJkZWNvZGVVUklDb21wb25lbnQiLCJlc2NhcGUiLCJjaGFyQ29kZUF0IiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiaXQiLCJVTlNDT1BBQkxFUyIsIkFycmF5UHJvdG8iLCJhdCIsIlMiLCJpbmRleCIsInVuaWNvZGUiLCJpc09iamVjdCIsInRvSU9iamVjdCIsInRvTGVuZ3RoIiwidG9BYnNvbHV0ZUluZGV4IiwiSVNfSU5DTFVERVMiLCIkdGhpcyIsImVsIiwiZnJvbUluZGV4IiwiTyIsImFGdW5jdGlvbiIsImludm9rZSIsImFycmF5U2xpY2UiLCJmYWN0b3JpZXMiLCJjb25zdHJ1Y3QiLCJGIiwiYXJncyIsIkZ1bmN0aW9uIiwidGhhdCIsImZuIiwicGFydEFyZ3MiLCJhcmd1bWVudHMiLCJib3VuZCIsImNvZiIsIlRBRyIsIkFSRyIsInRyeUdldCIsImUiLCJUIiwiQiIsImNhbGxlZSIsImNvcmUiLCJ2ZXJzaW9uIiwiX19lIiwiJGRlZmluZVByb3BlcnR5IiwiY3JlYXRlRGVzYyIsImYiLCJhIiwiYiIsImFwcGx5IiwiZG9jdW1lbnQiLCJpcyIsImNyZWF0ZUVsZW1lbnQiLCJnZXRLZXlzIiwiZ09QUyIsInBJRSIsInJlc3VsdCIsImdldFN5bWJvbHMiLCJzeW1ib2xzIiwiaXNFbnVtIiwiaGlkZSIsInJlZGVmaW5lIiwiY3R4IiwiUFJPVE9UWVBFIiwiJGV4cG9ydCIsInR5cGUiLCJzb3VyY2UiLCJJU19GT1JDRUQiLCJJU19HTE9CQUwiLCJHIiwiSVNfU1RBVElDIiwiSVNfUFJPVE8iLCJQIiwiSVNfQklORCIsImV4cFByb3RvIiwib3duIiwib3V0IiwiZXhwIiwiVSIsIlciLCJSIiwiTUFUQ0giLCJLRVkiLCJyZSIsImV4ZWMiLCJmYWlscyIsImRlZmluZWQiLCJ3a3MiLCJyZWdleHBFeGVjIiwiU1BFQ0lFUyIsIlJFUExBQ0VfU1VQUE9SVFNfTkFNRURfR1JPVVBTIiwiZ3JvdXBzIiwicmVwbGFjZSIsIlNQTElUX1dPUktTX1dJVEhfT1ZFUldSSVRURU5fRVhFQyIsIm9yaWdpbmFsRXhlYyIsIlNZTUJPTCIsIkRFTEVHQVRFU19UT19TWU1CT0wiLCJERUxFR0FURVNfVE9fRVhFQyIsImV4ZWNDYWxsZWQiLCJuYXRpdmVSZWdFeHBNZXRob2QiLCJmbnMiLCJtYXliZUNhbGxOYXRpdmUiLCJuYXRpdmVNZXRob2QiLCJyZWdleHAiLCJhcmcyIiwiZm9yY2VTdHJpbmdNZXRob2QiLCJzdHJmbiIsInJ4Zm4iLCJSZWdFeHAiLCJzdHJpbmciLCJhcmciLCJhbk9iamVjdCIsImlnbm9yZUNhc2UiLCJtdWx0aWxpbmUiLCJzdGlja3kiLCJ3aW5kb3ciLCJNYXRoIiwic2VsZiIsIl9fZyIsImRQIiwiZG9jdW1lbnRFbGVtZW50IiwidW4iLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIkl0ZXJhdG9ycyIsIklURVJBVE9SIiwiaXNSZWdFeHAiLCJlbnRyaWVzIiwicmV0Iiwic2V0VG9TdHJpbmdUYWciLCJJdGVyYXRvclByb3RvdHlwZSIsIk5BTUUiLCJMSUJSQVJZIiwiJGl0ZXJDcmVhdGUiLCJnZXRQcm90b3R5cGVPZiIsIkJVR0dZIiwia2V5cyIsIkZGX0lURVJBVE9SIiwiS0VZUyIsIlZBTFVFUyIsInJldHVyblRoaXMiLCJCYXNlIiwiREVGQVVMVCIsIklTX1NFVCIsIkZPUkNFRCIsImdldE1ldGhvZCIsImtpbmQiLCJwcm90byIsIkRFRl9WQUxVRVMiLCJWQUxVRVNfQlVHIiwiJG5hdGl2ZSIsIiRkZWZhdWx0IiwiJGVudHJpZXMiLCIkYW55TmF0aXZlIiwibWV0aG9kcyIsIlNBRkVfQ0xPU0lORyIsInJpdGVyIiwic2tpcENsb3NpbmciLCJzYWZlIiwiaXRlciIsIk1FVEEiLCJoYXMiLCJzZXREZXNjIiwiaWQiLCJpc0V4dGVuc2libGUiLCJGUkVFWkUiLCJwcmV2ZW50RXh0ZW5zaW9ucyIsInNldE1ldGEiLCJ3IiwiZmFzdEtleSIsImdldFdlYWsiLCJvbkZyZWV6ZSIsIm1ldGEiLCJORUVEIiwiZFBzIiwiZW51bUJ1Z0tleXMiLCJJRV9QUk9UTyIsIkVtcHR5IiwiY3JlYXRlRGljdCIsImlmcmFtZSIsImx0IiwiZ3QiLCJpZnJhbWVEb2N1bWVudCIsInN0eWxlIiwiZGlzcGxheSIsImFwcGVuZENoaWxkIiwic3JjIiwiY29udGVudFdpbmRvdyIsIm9wZW4iLCJ3cml0ZSIsImNsb3NlIiwiUHJvcGVydGllcyIsIklFOF9ET01fREVGSU5FIiwidG9QcmltaXRpdmUiLCJBdHRyaWJ1dGVzIiwiZGVmaW5lUHJvcGVydGllcyIsImdPUEQiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJnT1BOIiwid2luZG93TmFtZXMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiZ2V0V2luZG93TmFtZXMiLCIka2V5cyIsImhpZGRlbktleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJ0b09iamVjdCIsIk9iamVjdFByb3RvIiwiYXJyYXlJbmRleE9mIiwibmFtZXMiLCJSZWZsZWN0Iiwib3duS2V5cyIsImJpdG1hcCIsIlNSQyIsIiR0b1N0cmluZyIsIlRPX1NUUklORyIsIlRQTCIsImluc3BlY3RTb3VyY2UiLCJ2YWwiLCJpc0Z1bmN0aW9uIiwiY2xhc3NvZiIsImJ1aWx0aW5FeGVjIiwicmVnZXhwRmxhZ3MiLCJuYXRpdmVFeGVjIiwibmF0aXZlUmVwbGFjZSIsInBhdGNoZWRFeGVjIiwiTEFTVF9JTkRFWCIsIlVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyIsInJlMSIsInJlMiIsIk5QQ0dfSU5DTFVERUQiLCJQQVRDSCIsImxhc3RJbmRleCIsInJlQ29weSIsImRlZiIsInRhZyIsInN0YXQiLCJzaGFyZWQiLCJ1aWQiLCJTSEFSRUQiLCJzdG9yZSIsImNvcHlyaWdodCIsIkQiLCJDIiwidG9JbnRlZ2VyIiwicG9zIiwiY2hhckF0Iiwic2VhcmNoU3RyaW5nIiwibWF4IiwibWluIiwiY2VpbCIsImZsb29yIiwiaXNOYU4iLCJJT2JqZWN0IiwidmFsdWVPZiIsInB4IiwicmFuZG9tIiwid2tzRXh0IiwiJFN5bWJvbCIsIlVTRV9TWU1CT0wiLCIkZXhwb3J0cyIsImdldEl0ZXJhdG9yTWV0aG9kIiwiaXNBcnJheUl0ZXIiLCJjcmVhdGVQcm9wZXJ0eSIsImdldEl0ZXJGbiIsImFycmF5TGlrZSIsImFMZW4iLCJtYXBmbiIsIm1hcHBpbmciLCJpdGVyRm4iLCJzdGVwIiwiYWRkVG9VbnNjb3BhYmxlcyIsIml0ZXJhdGVkIiwiX3QiLCJfayIsIkFyZ3VtZW50cyIsIkZQcm90byIsIm5hbWVSRSIsIl9pc0Zpbml0ZSIsImZvcmNlZCIsInNwZWNpZXNDb25zdHJ1Y3RvciIsImFkdmFuY2VTdHJpbmdJbmRleCIsImNhbGxSZWdFeHBFeGVjIiwiJG1pbiIsIiRwdXNoIiwiJFNQTElUIiwiTEVOR1RIIiwiTUFYX1VJTlQzMiIsIlNVUFBPUlRTX1kiLCJTUExJVCIsIiRzcGxpdCIsImludGVybmFsU3BsaXQiLCJzZXBhcmF0b3IiLCJsaW1pdCIsIm91dHB1dCIsImZsYWdzIiwibGFzdExhc3RJbmRleCIsInNwbGl0TGltaXQiLCJzZXBhcmF0b3JDb3B5IiwibGFzdExlbmd0aCIsInNwbGl0dGVyIiwicmVzIiwicngiLCJ1bmljb2RlTWF0Y2hpbmciLCJsaW0iLCJxIiwiQSIsInoiLCJjb250ZXh0IiwiSU5DTFVERVMiLCJpbmNsdWRlcyIsImluZGV4T2YiLCJERVNDUklQVE9SUyIsIiRmYWlscyIsIndrc0RlZmluZSIsImVudW1LZXlzIiwiX2NyZWF0ZSIsImdPUE5FeHQiLCIkR09QRCIsIiRHT1BTIiwiJERQIiwiJEpTT04iLCJKU09OIiwiX3N0cmluZ2lmeSIsInN0cmluZ2lmeSIsIkhJRERFTiIsIlRPX1BSSU1JVElWRSIsIlN5bWJvbFJlZ2lzdHJ5IiwiQWxsU3ltYm9scyIsIk9QU3ltYm9scyIsIlVTRV9OQVRJVkUiLCJRT2JqZWN0Iiwic2V0dGVyIiwiZmluZENoaWxkIiwic2V0U3ltYm9sRGVzYyIsInByb3RvRGVzYyIsIndyYXAiLCJzeW0iLCJpc1N5bWJvbCIsIiRkZWZpbmVQcm9wZXJ0aWVzIiwiJGNyZWF0ZSIsIiRwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIkUiLCIkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiJGdldE93blByb3BlcnR5TmFtZXMiLCIkZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiSVNfT1AiLCIkc2V0Iiwic2V0IiwiZXM2U3ltYm9scyIsImoiLCJ3ZWxsS25vd25TeW1ib2xzIiwiayIsImtleUZvciIsInVzZVNldHRlciIsInVzZVNpbXBsZSIsIkZBSUxTX09OX1BSSU1JVElWRVMiLCJyZXBsYWNlciIsIiRyZXBsYWNlciIsIiRpbmNsdWRlcyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJnZXREZXNjIiwiZGVzYyIsIiRpdGVyYXRvcnMiLCJUT19TVFJJTkdfVEFHIiwiQXJyYXlWYWx1ZXMiLCJET01JdGVyYWJsZXMiLCJDU1NSdWxlTGlzdCIsIkNTU1N0eWxlRGVjbGFyYXRpb24iLCJDU1NWYWx1ZUxpc3QiLCJDbGllbnRSZWN0TGlzdCIsIkRPTVJlY3RMaXN0IiwiRE9NU3RyaW5nTGlzdCIsIkRPTVRva2VuTGlzdCIsIkRhdGFUcmFuc2Zlckl0ZW1MaXN0IiwiRmlsZUxpc3QiLCJIVE1MQWxsQ29sbGVjdGlvbiIsIkhUTUxDb2xsZWN0aW9uIiwiSFRNTEZvcm1FbGVtZW50IiwiSFRNTFNlbGVjdEVsZW1lbnQiLCJNZWRpYUxpc3QiLCJNaW1lVHlwZUFycmF5IiwiTmFtZWROb2RlTWFwIiwiTm9kZUxpc3QiLCJQYWludFJlcXVlc3RMaXN0IiwiUGx1Z2luIiwiUGx1Z2luQXJyYXkiLCJTVkdMZW5ndGhMaXN0IiwiU1ZHTnVtYmVyTGlzdCIsIlNWR1BhdGhTZWdMaXN0IiwiU1ZHUG9pbnRMaXN0IiwiU1ZHU3RyaW5nTGlzdCIsIlNWR1RyYW5zZm9ybUxpc3QiLCJTb3VyY2VCdWZmZXJMaXN0IiwiU3R5bGVTaGVldExpc3QiLCJUZXh0VHJhY2tDdWVMaXN0IiwiVGV4dFRyYWNrTGlzdCIsIlRvdWNoTGlzdCIsImNvbGxlY3Rpb25zIiwiZXhwbGljaXQiLCJDb2xsZWN0aW9uIiwiYmFzZTY0bWFwIiwiY3J5cHQiLCJyb3RsIiwicm90ciIsImVuZGlhbiIsInJhbmRvbUJ5dGVzIiwiYnl0ZXNUb1dvcmRzIiwid29yZHMiLCJ3b3Jkc1RvQnl0ZXMiLCJieXRlc1RvSGV4IiwiaGV4IiwiaGV4VG9CeXRlcyIsInN1YnN0ciIsImJ5dGVzVG9CYXNlNjQiLCJiYXNlNjQiLCJ0cmlwbGV0IiwiYmFzZTY0VG9CeXRlcyIsImltb2Q0IiwicG93Iiwib2JqIiwiaXNCdWZmZXIiLCJpc1Nsb3dCdWZmZXIiLCJfaXNCdWZmZXIiLCJyZWFkRmxvYXRMRSIsIm1kNSIsIm1lc3NhZ2UiLCJvcHRpb25zIiwiZW5jb2RpbmciLCJVaW50OEFycmF5IiwiRkYiLCJfZmYiLCJHRyIsIl9nZyIsIkhIIiwiX2hoIiwiSUkiLCJfaWkiLCJhYSIsImJiIiwiZGQiLCJ4IiwiX2Jsb2Nrc2l6ZSIsIl9kaWdlc3RzaXplIiwiRXJyb3IiLCJkaWdlc3RieXRlcyIsImFzQnl0ZXMiLCJhc1N0cmluZyIsInJ1bnRpbWUiLCJPcCIsImhhc093biIsIml0ZXJhdG9yU3ltYm9sIiwiYXN5bmNJdGVyYXRvclN5bWJvbCIsImFzeW5jSXRlcmF0b3IiLCJ0b1N0cmluZ1RhZ1N5bWJvbCIsImlubmVyRm4iLCJvdXRlckZuIiwidHJ5TG9jc0xpc3QiLCJwcm90b0dlbmVyYXRvciIsIkdlbmVyYXRvciIsImdlbmVyYXRvciIsIkNvbnRleHQiLCJfaW52b2tlIiwibWFrZUludm9rZU1ldGhvZCIsInRyeUNhdGNoIiwiR2VuU3RhdGVTdXNwZW5kZWRTdGFydCIsIkdlblN0YXRlU3VzcGVuZGVkWWllbGQiLCJHZW5TdGF0ZUV4ZWN1dGluZyIsIkdlblN0YXRlQ29tcGxldGVkIiwiQ29udGludWVTZW50aW5lbCIsIkdlbmVyYXRvckZ1bmN0aW9uIiwiR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUiLCJnZXRQcm90byIsIk5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlIiwiR3AiLCJkaXNwbGF5TmFtZSIsImRlZmluZUl0ZXJhdG9yTWV0aG9kcyIsIm1ldGhvZCIsImlzR2VuZXJhdG9yRnVuY3Rpb24iLCJnZW5GdW4iLCJjdG9yIiwibWFyayIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiYXdyYXAiLCJfX2F3YWl0IiwiQXN5bmNJdGVyYXRvciIsIlByb21pc2VJbXBsIiwicmVzb2x2ZSIsInJlamVjdCIsInJlY29yZCIsInRoZW4iLCJ1bndyYXBwZWQiLCJlcnJvciIsInByZXZpb3VzUHJvbWlzZSIsImVucXVldWUiLCJjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyIsImFzeW5jIiwiUHJvbWlzZSIsInN0YXRlIiwiZG9uZVJlc3VsdCIsImRlbGVnYXRlIiwiZGVsZWdhdGVSZXN1bHQiLCJtYXliZUludm9rZURlbGVnYXRlIiwic2VudCIsIl9zZW50IiwiZGlzcGF0Y2hFeGNlcHRpb24iLCJhYnJ1cHQiLCJpbmZvIiwicmVzdWx0TmFtZSIsIm5leHRMb2MiLCJwdXNoVHJ5RW50cnkiLCJsb2NzIiwiZW50cnkiLCJ0cnlMb2MiLCJjYXRjaExvYyIsImZpbmFsbHlMb2MiLCJhZnRlckxvYyIsInRyeUVudHJpZXMiLCJyZXNldFRyeUVudHJ5IiwiY29tcGxldGlvbiIsInJlc2V0IiwicmV2ZXJzZSIsInBvcCIsIml0ZXJhYmxlIiwiaXRlcmF0b3JNZXRob2QiLCJza2lwVGVtcFJlc2V0IiwicHJldiIsInN0b3AiLCJyb290RW50cnkiLCJyb290UmVjb3JkIiwicnZhbCIsImV4Y2VwdGlvbiIsImhhbmRsZSIsImxvYyIsImNhdWdodCIsImhhc0NhdGNoIiwiaGFzRmluYWxseSIsImZpbmFsbHlFbnRyeSIsImNvbXBsZXRlIiwiZmluaXNoIiwidGhyb3duIiwiZGVsZWdhdGVZaWVsZCIsInJlZ2VuZXJhdG9yUnVudGltZSIsImFjY2lkZW50YWxTdHJpY3RNb2RlIiwic2V0dXAiLCJzZXR1cENhY2hlIiwiY29yZV9qc19tb2R1bGVzX2VzN19vYmplY3RfZ2V0X293bl9wcm9wZXJ0eV9kZXNjcmlwdG9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fIiwiY29yZV9qc19tb2R1bGVzX2VzN19vYmplY3RfZ2V0X293bl9wcm9wZXJ0eV9kZXNjcmlwdG9yc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQiLCJjb3JlX2pzX21vZHVsZXNfZXM2X3N5bWJvbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fIiwiY29yZV9qc19tb2R1bGVzX2VzNl9zeW1ib2xfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0IiwiY29yZV9qc19tb2R1bGVzX2VzNl9hcnJheV9pdGVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fIiwiY29yZV9qc19tb2R1bGVzX2VzNl9hcnJheV9pdGVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fX2RlZmF1bHQiLCJjb3JlX2pzX21vZHVsZXNfZXM2X29iamVjdF90b19zdHJpbmdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyIsImNvcmVfanNfbW9kdWxlc19lczZfb2JqZWN0X3RvX3N0cmluZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fX2RlZmF1bHQiLCJyZWdlbmVyYXRvcl9ydW50aW1lX3J1bnRpbWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyIsInJlZ2VuZXJhdG9yX3J1bnRpbWVfcnVudGltZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fX2RlZmF1bHQiLCJheGlvc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fIiwiYXhpb3NfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX19kZWZhdWx0IiwiX3JlcXVlc3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyIsIl9jYWNoZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fIiwiX2NvbmZpZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fIiwiX3V0aWxpdGllc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fIiwiX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIiwiZXhjbHVkZWQiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsInNvdXJjZVN5bWJvbEtleXMiLCJzb3VyY2VLZXlzIiwiZW51bWVyYWJsZU9ubHkiLCJmaWx0ZXIiLCJfb2JqZWN0U3ByZWFkIiwiX2RlZmluZVByb3BlcnR5IiwiYXN5bmNHZW5lcmF0b3JTdGVwIiwiZ2VuIiwiX25leHQiLCJfdGhyb3ciLCJfYXN5bmNUb0dlbmVyYXRvciIsImNvbmZpZyIsImFkYXB0ZXIiLCJfeCIsIl9hZGFwdGVyIiwiX2NhbGxlZSIsInJlcSIsInJlcUNvbmZpZyIsIm5ldHdvcmtFcnJvciIsInJlYWRPbkVycm9yIiwiX2NhbGxlZSQiLCJfY29udGV4dCIsInQwIiwiYWNjZXB0U3RhbGUiLCJyZXF1ZXN0Iiwic3RhbGUiLCJ0MSIsImluc3RhbmNlQ29uZmlnIiwiYXhpb3MiLCJjYWNoZSIsIl8iLCJheGlvc0NvbmZpZyIsImFwaSIsInNlcmlhbGl6ZVF1ZXJ5IiwicmVhZCIsImludmFsaWRhdGUiLCJjb3JlX2pzX21vZHVsZXNfZXM3X2FycmF5X2luY2x1ZGVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18iLCJjb3JlX2pzX21vZHVsZXNfZXM3X2FycmF5X2luY2x1ZGVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCIsImNvcmVfanNfbW9kdWxlc19lczZfc3RyaW5nX2luY2x1ZGVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18iLCJjb3JlX2pzX21vZHVsZXNfZXM2X3N0cmluZ19pbmNsdWRlc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQiLCJyZWdlbmVyYXRvcl9ydW50aW1lX3J1bnRpbWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyIsInJlZ2VuZXJhdG9yX3J1bnRpbWVfcnVudGltZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fX2RlZmF1bHQiLCJjb3JlX2pzX21vZHVsZXNfZXM2X2FycmF5X2l0ZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18iLCJjb3JlX2pzX21vZHVsZXNfZXM2X2FycmF5X2l0ZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19fZGVmYXVsdCIsImNvcmVfanNfbW9kdWxlc19lczZfb2JqZWN0X3RvX3N0cmluZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fIiwiY29yZV9qc19tb2R1bGVzX2VzNl9vYmplY3RfdG9fc3RyaW5nX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19fZGVmYXVsdCIsIl91dGlsaXRpZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyIsIm1kNV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fIiwibWQ1X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19fZGVmYXVsdCIsIl9zZXJpYWxpemVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyIsIl94MiIsIl94MyIsIl93cml0ZSIsImV4cGlyZXMiLCJkYXRhIiwic2V0SXRlbSIsInV1aWQiLCJkZWJ1ZyIsImNsZWFyT25FcnJvciIsImNsZWFyIiwiX3g0IiwiX3g1IiwiX3JlYWQiLCJfY2FsbGVlMiIsImlnbm9yZUNhY2hlIiwib2ZmbGluZSIsIl9lcnJvciIsIl9jYWxsZWUyJCIsIl9jb250ZXh0MiIsImdldEl0ZW0iLCJ1cmwiLCJyZWFzb24iLCJuYXZpZ2F0b3IiLCJvbkxpbmUiLCJEYXRlIiwibm93IiwiY2FjaGVLZXkiLCJiYXNlVVJMIiwiZGVmYXVsdEludmFsaWRhdGUiLCJfeDYiLCJfeDciLCJfZGVmYXVsdEludmFsaWRhdGUiLCJfY2FsbGVlMyIsIl9jYWxsZWUzJCIsIl9jb250ZXh0MyIsImV4Y2x1ZGUiLCJyZW1vdmVJdGVtIiwicGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwiaXNJbnN0YW5jZU9mVVJMU2VhcmNoUGFyYW1zIiwiYXBwZW5kIiwiZGVmYXVsdHMiLCJtYWtlQ29uZmlnIiwibWVyZ2VSZXF1ZXN0Q29uZmlnIiwiYXhpb3NfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyIsImF4aW9zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19fZGVmYXVsdCIsIl9tZW1vcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyIsIl9jYWNoZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fIiwibm9vcCIsIl9jb25zb2xlIiwiX2xlbiIsIl9rZXkiLCJjb25zb2xlIiwibG9nIiwicGF0aHMiLCJxdWVyeSIsImNsZWFyT25TdGFsZSIsInJlYWRIZWFkZXJzIiwiZGlzYWxsb3dlZFBlclJlcXVlc3RLZXlzIiwib3ZlcnJpZGUiLCJyZXF1ZXN0Q29uZmlnIiwibWVyZ2VkQ29uZmlnIiwiY29yZV9qc19tb2R1bGVzX2VzNl9hcnJheV9pdGVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fIiwiY29yZV9qc19tb2R1bGVzX2VzNl9hcnJheV9pdGVyYXRvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQiLCJjb3JlX2pzX21vZHVsZXNfZXM2X29iamVjdF90b19zdHJpbmdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyIsImNvcmVfanNfbW9kdWxlc19lczZfb2JqZWN0X3RvX3N0cmluZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQiLCJjb3JlX2pzX21vZHVsZXNfZXM3X2FycmF5X2luY2x1ZGVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18iLCJjb3JlX2pzX21vZHVsZXNfZXM3X2FycmF5X2luY2x1ZGVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19fZGVmYXVsdCIsImNvcmVfanNfbW9kdWxlc19lczZfc3RyaW5nX2luY2x1ZGVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18iLCJjb3JlX2pzX21vZHVsZXNfZXM2X3N0cmluZ19pbmNsdWRlc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fX2RlZmF1bHQiLCJfdXRpbGl0aWVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18iLCJfY29uZmlnJGV4Y2x1ZGUiLCJoYXNRdWVyeVBhcmFtcyIsImZvdW5kIiwic29tZSIsIl9hcGlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyIsIl9yZWRpc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fIiwiX3JlZGlzX2RlZmF1bHRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyIsIlJlZGlzU3RvcmUiLCJSZWRpc0RlZmF1bHRTdG9yZSIsInJlZ2VuZXJhdG9yX3J1bnRpbWVfcnVudGltZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fIiwicmVnZW5lcmF0b3JfcnVudGltZV9ydW50aW1lX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCIsIl9saW1pdCIsImZpcnN0SXRlbSIsIml0ZXJhdGUiLCJfdXRpbGl0aWVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18iLCJNZW1vcnlTdG9yZSIsIl9nZXRJdGVtIiwiaXRlbSIsIl9zZXRJdGVtIiwiX3JlbW92ZUl0ZW0iLCJfY2xlYXIiLCJfY2FsbGVlNCIsIl9jYWxsZWU0JCIsIl9jb250ZXh0NCIsIl9sZW5ndGgiLCJfY2FsbGVlNSIsIl9jYWxsZWU1JCIsIl9jb250ZXh0NSIsImFsbCIsImNvcmVfanNfbW9kdWxlc19lczZfZnVuY3Rpb25fYmluZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fIiwiY29yZV9qc19tb2R1bGVzX2VzNl9mdW5jdGlvbl9iaW5kX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19fZGVmYXVsdCIsImNvcmVfanNfbW9kdWxlc19lczZfZnVuY3Rpb25fbmFtZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fIiwiY29yZV9qc19tb2R1bGVzX2VzNl9mdW5jdGlvbl9uYW1lX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19fZGVmYXVsdCIsInV0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyIsInV0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX19kZWZhdWx0IiwiY2xpZW50IiwiaW52YWxpZENsaWVudEVycm9yIiwicHJlZml4IiwibWF4U2NhbkNvdW50IiwiZ2V0QXN5bmMiLCJwc2V0ZXhBc3luYyIsInBzZXRleCIsImRlbEFzeW5jIiwiZGVsIiwic2NhbkFzeW5jIiwic2NhbiIsImNhbGN1bGF0ZVRUTCIsInRyYW5zZm9ybUtleSIsImNvbXB1dGVkS2V5IiwidHRsIiwiX3NjYW4iLCJvcGVyYXRpb24iLCJjdXJzb3IiLCJyZXBseSIsIl90aGlzIiwiX2NhbGxlZTYiLCJfY2FsbGVlNiQiLCJfY29udGV4dDYiLCJfaXRlcmF0ZSIsIl9jYWxsZWU4IiwiX3RoaXMyIiwicnVuRnVuY3Rpb24iLCJfcnVuRnVuY3Rpb24iLCJfY2FsbGVlOCQiLCJfY29udGV4dDgiLCJfcnVuRnVuY3Rpb24zIiwiX2NhbGxlZTciLCJfY2FsbGVlNyQiLCJfY29udGV4dDciLCJfcnVuRnVuY3Rpb24yIiwibWFwIiwiX3V0aWxpdGllc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fIiwiSEFTSF9LRVkiLCJoZ2V0QXN5bmMiLCJoZ2V0IiwiaHNldEFzeW5jIiwiaHNldCIsImhkZWxBc3luYyIsImhkZWwiLCJobGVuQXN5bmMiLCJobGVuIiwiaGdldGFsbEFzeW5jIiwiaGdldGFsbCIsImhhc2hEYXRhIiwiX3Jlc3BvbnNlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18iLCJfZXhjbHVkZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fIiwiX2NhY2hlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18iLCJfcmVxdWVzdCIsImV4Y2x1ZGVGcm9tQ2FjaGUiLCJfZXhjbHVkZUZyb21DYWNoZSIsImZyb21DYWNoZSIsIl9saW1pdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fIiwiX2NhY2hlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18iLCJjYWNoZV9jb250cm9sX2VzbV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fIiwicmVzcG9uc2UiLCJfcmVzcG9uc2UiLCJfcmVzJHJlcXVlc3QiLCJfcmVzJGhlYWRlcnMiLCJoZWFkZXJzIiwiY2FjaGVDb250cm9sIiwicmVzcG9uc2VUeXBlIiwiZ2V0VGltZSIsImV4Y2x1ZGVkRnJvbUNhY2hlIiwiY29yZV9qc19tb2R1bGVzX2VzNl9zeW1ib2xfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyIsImNvcmVfanNfbW9kdWxlc19lczZfc3ltYm9sX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCIsImNvcmVfanNfbW9kdWxlc19lczZfYXJyYXlfaXRlcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyIsImNvcmVfanNfbW9kdWxlc19lczZfYXJyYXlfaXRlcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0Iiwic2VyaWFsaXplIiwic2VyaWFsaXplZCIsImdldFRhZyIsImlzU3RyaW5nIiwibWFwT2JqZWN0IiwiY29yZV9qc19tb2R1bGVzX2VzN19zeW1ib2xfYXN5bmNfaXRlcmF0b3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyIsImNvcmVfanNfbW9kdWxlc19lczdfc3ltYm9sX2FzeW5jX2l0ZXJhdG9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCIsIl90eXBlb2YiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/axios-cache-adapter/dist/cache.node.js\n");

/***/ })

};
;