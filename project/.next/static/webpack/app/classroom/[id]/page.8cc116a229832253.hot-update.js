"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/classroom/[id]/page",{

/***/ "(app-pages-browser)/./src/utils/textToSpeech.ts":
/*!***********************************!*\
  !*** ./src/utils/textToSpeech.ts ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clearSpeechQueue: function() { return /* binding */ clearSpeechQueue; },\n/* harmony export */   getSpeechStatus: function() { return /* binding */ getSpeechStatus; },\n/* harmony export */   isTTSAvailable: function() { return /* binding */ isTTSAvailable; },\n/* harmony export */   pauseSpeaking: function() { return /* binding */ pauseSpeaking; },\n/* harmony export */   resumeSpeaking: function() { return /* binding */ resumeSpeaking; },\n/* harmony export */   speakLongContent: function() { return /* binding */ speakLongContent; },\n/* harmony export */   speakText: function() { return /* binding */ speakText; },\n/* harmony export */   speakWithVoiceId: function() { return /* binding */ speakWithVoiceId; },\n/* harmony export */   stopSpeaking: function() { return /* binding */ stopSpeaking; },\n/* harmony export */   ttsService: function() { return /* binding */ ttsService; }\n/* harmony export */ });\n/* harmony import */ var react_hot_toast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-hot-toast */ \"(app-pages-browser)/./node_modules/react-hot-toast/dist/index.mjs\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n/* harmony import */ var axios_cache_adapter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! axios-cache-adapter */ \"(app-pages-browser)/./node_modules/axios-cache-adapter/dist/cache.js\");\n/* harmony import */ var axios_cache_adapter__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(axios_cache_adapter__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\nclass TextToSpeechService {\n    async fetchVoiceAudioBuffer(text, voiceId) {\n        console.log(\"Fetching audio buffer for: \\n\".concat(text, \" \\nVoice ID: \").concat(voiceId));\n        const apiResponse = await this.api({\n            url: this.murfApiUrl,\n            method: \"POST\",\n            headers: {\n                Authorization: \"Bearer \".concat(this.murfApiKey)\n            },\n            data: {\n                text: text,\n                voiceId: voiceId\n            }\n        });\n        return apiResponse.data;\n    }\n    /**\n   * Convert text to speech using ElevenLabs API\n   */ async textToSpeech(text) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        if (!this.apiKey) {\n            throw new Error(\"ElevenLabs API key is required\");\n        }\n        if (!text.trim()) {\n            throw new Error(\"Text cannot be empty\");\n        }\n        const { voice = this.defaultVoices.narrator, model = \"eleven_monolingual_v1\", stability = 0.5, similarityBoost = 0.75, style = 0, useSpeakerBoost = true } = options;\n        const voiceSettings = {\n            stability,\n            similarity_boost: similarityBoost,\n            style,\n            use_speaker_boost: useSpeakerBoost\n        };\n        try {\n            const response = await fetch(\"\".concat(this.baseUrl, \"/text-to-speech/\").concat(voice), {\n                method: \"POST\",\n                headers: {\n                    \"Accept\": \"audio/mpeg\",\n                    \"Content-Type\": \"application/json\",\n                    \"xi-api-key\": this.apiKey\n                },\n                body: JSON.stringify({\n                    text: this.cleanTextForTTS(text.trim()),\n                    model_id: model,\n                    voice_settings: voiceSettings\n                })\n            });\n            if (!response.ok) {\n                const errorText = await response.text();\n                throw new Error(\"TTS API error: \".concat(response.status, \" - \").concat(errorText));\n            }\n            return await response.arrayBuffer();\n        } catch (error) {\n            console.error(\"Text-to-speech error:\", error);\n            throw error;\n        }\n    }\n    /**\n   * Play audio from ArrayBuffer\n   */ async playAudio(audioBuffer, queueId) {\n        return new Promise((resolve, reject)=>{\n            try {\n                // Check if this queue item is still valid\n                if (this.currentQueueId !== queueId) {\n                    resolve(); // Silently resolve if queue item was cancelled\n                    return;\n                }\n                const blob = new Blob([\n                    audioBuffer\n                ], {\n                    type: \"audio/mpeg\"\n                });\n                const audioUrl = URL.createObjectURL(blob);\n                // Stop current audio if playing\n                this.stopAudio();\n                this.currentAudio = new Audio(audioUrl);\n                this.currentAudio.preload = \"auto\";\n                this.currentAudio.onloadeddata = ()=>{\n                    console.log(\"Audio loaded successfully\");\n                };\n                this.currentAudio.onplay = ()=>{\n                    this.isPlaying = true;\n                };\n                this.currentAudio.onended = ()=>{\n                    this.isPlaying = false;\n                    this.currentQueueId = null;\n                    URL.revokeObjectURL(audioUrl);\n                    resolve();\n                };\n                this.currentAudio.onerror = (error)=>{\n                    this.isPlaying = false;\n                    this.currentQueueId = null;\n                    URL.revokeObjectURL(audioUrl);\n                    console.error(\"Audio playback error:\", error);\n                    reject(new Error(\"Audio playback failed\"));\n                };\n                this.currentAudio.onpause = ()=>{\n                    this.isPlaying = false;\n                };\n                // Start playback\n                this.currentAudio.play().catch(reject);\n            } catch (error) {\n                console.error(\"Error creating audio:\", error);\n                this.currentQueueId = null;\n                reject(error);\n            }\n        });\n    }\n    /**\n   * Speak text with options\n   */ async speak(text) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        return new Promise((resolve, reject)=>{\n            const queueItem = {\n                text,\n                options,\n                resolve,\n                reject,\n                id: \"tts-\".concat(Date.now(), \"-\").concat(Math.random())\n            };\n            this.queue.push(queueItem);\n            console.log(\"Audio queued:\", this.queue);\n            this.processQueue();\n        });\n    }\n    /**\n   * Speak with specific voice ID (for discussion messages)\n   */ async speakWithVoiceId(text, voiceId) {\n        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        const voiceOptions = {\n            voice: voiceId,\n            stability: 0.6,\n            similarityBoost: 0.75,\n            style: 0.2,\n            useSpeakerBoost: true,\n            ...options\n        };\n        console.log(\"called speakWithVoiceId()\");\n        return this.speak(text, voiceOptions);\n    }\n    /**\n   * Process the TTS queue\n   */ async processQueue() {\n        if (this.isProcessing || this.queue.length === 0) {\n            return;\n        }\n        this.isProcessing = true;\n        while(this.queue.length > 0){\n            const queueItem = this.queue.shift();\n            const { text, options, resolve, reject, id } = queueItem;\n            try {\n                this.currentQueueId = id;\n                // Show loading toast for longer texts\n                let loadingToast;\n                if (text.length > 100) {\n                    loadingToast = react_hot_toast__WEBPACK_IMPORTED_MODULE_0__[\"default\"].loading(\"Generating speech...\", {\n                        duration: 5000\n                    });\n                }\n                const audioBuffer = await this.textToSpeech(text, options);\n                if (loadingToast) {\n                    react_hot_toast__WEBPACK_IMPORTED_MODULE_0__[\"default\"].dismiss(loadingToast);\n                }\n                // Check if this queue item is still valid before playing\n                if (this.currentQueueId === id) {\n                    await this.playAudio(audioBuffer, id);\n                }\n                resolve();\n            } catch (error) {\n                console.error(\"TTS processing error:\", error);\n                // Only show error toast if this was the current item\n                if (this.currentQueueId === id) {\n                    react_hot_toast__WEBPACK_IMPORTED_MODULE_0__[\"default\"].error(\"Speech generation failed\");\n                }\n                this.currentQueueId = null;\n                reject(error);\n            }\n        }\n        this.isProcessing = false;\n    }\n    /**\n   * Stop current audio playback and clear queue\n   */ stopAudio() {\n        if (this.currentAudio) {\n            this.currentAudio.pause();\n            this.currentAudio.currentTime = 0;\n            this.isPlaying = false;\n        }\n        this.currentQueueId = null;\n    }\n    /**\n   * Pause current audio playback\n   */ pauseAudio() {\n        if (this.currentAudio && this.isPlaying) {\n            this.currentAudio.pause();\n        }\n    }\n    /**\n   * Resume current audio playback\n   */ resumeAudio() {\n        if (this.currentAudio && !this.isPlaying) {\n            this.currentAudio.play().catch(console.error);\n        }\n    }\n    /**\n   * Clear the TTS queue\n   */ clearQueue() {\n        this.queue.forEach((param)=>{\n            let { reject } = param;\n            reject(new Error(\"Queue cleared\"));\n        });\n        this.queue = [];\n        this.currentQueueId = null;\n        this.stopAudio();\n    }\n    /**\n   * Get current playback status\n   */ getStatus() {\n        var _this_currentAudio, _this_currentAudio1;\n        return {\n            isPlaying: this.isPlaying,\n            queueLength: this.queue.length,\n            isProcessing: this.isProcessing,\n            currentTime: ((_this_currentAudio = this.currentAudio) === null || _this_currentAudio === void 0 ? void 0 : _this_currentAudio.currentTime) || 0,\n            duration: ((_this_currentAudio1 = this.currentAudio) === null || _this_currentAudio1 === void 0 ? void 0 : _this_currentAudio1.duration) || 0\n        };\n    }\n    /**\n   * Speak text with persona-specific voice\n   */ /**\n   * Utility method to clean text for better TTS\n   */ cleanTextForTTS(text) {\n        return text.replace(/\\*\\*(.*?)\\*\\*/g, \"$1\") // Remove markdown bold\n        .replace(/\\*(.*?)\\*/g, \"$1\") // Remove markdown italic\n        .replace(/`(.*?)`/g, \"$1\") // Remove code blocks\n        .replace(/#{1,6}\\s/g, \"\") // Remove markdown headers\n        .replace(/\\[([^\\]]+)\\]\\([^)]+\\)/g, \"$1\") // Convert links to text\n        .replace(/\\n{2,}/g, \". \") // Replace multiple newlines with periods\n        .replace(/\\n/g, \" \") // Replace single newlines with spaces\n        .replace(/\\s{2,}/g, \" \") // Replace multiple spaces with single space\n        .replace(/[^\\w\\s.,!?;:'\"()-]/g, \"\") // Remove special characters that might cause issues\n        .trim();\n    }\n    /**\n   * Speak cleaned text\n   */ async speakCleaned(text) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const cleanedText = this.cleanTextForTTS(text);\n        return this.speak(cleanedText, options);\n    }\n    /**\n   * Break long text into chunks and speak them\n   */ async speakLongText(text) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, maxChunkLength = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 500;\n        const cleanedText = this.cleanTextForTTS(text);\n        if (cleanedText.length <= maxChunkLength) {\n            return this.speak(cleanedText, options);\n        }\n        // Split text into sentences\n        const sentences = cleanedText.split(/[.!?]+/).filter((s)=>s.trim().length > 0);\n        const chunks = [];\n        let currentChunk = \"\";\n        for (const sentence of sentences){\n            const trimmedSentence = sentence.trim();\n            if (currentChunk.length + trimmedSentence.length + 1 <= maxChunkLength) {\n                currentChunk += (currentChunk ? \". \" : \"\") + trimmedSentence;\n            } else {\n                if (currentChunk) {\n                    chunks.push(currentChunk + \".\");\n                }\n                currentChunk = trimmedSentence;\n            }\n        }\n        if (currentChunk) {\n            chunks.push(currentChunk + \".\");\n        }\n        // Speak each chunk sequentially\n        for (const chunk of chunks){\n            await this.speak(chunk, options);\n        }\n    }\n    /**\n   * Check if TTS is available\n   */ isAvailable() {\n        return !!this.apiKey;\n    }\n    constructor(){\n        this.baseUrl = \"https://api.elevenlabs.io/v1\";\n        this.murfApiUrl = \"https://api.murf.ai/v1/speech/generate\";\n        this.murfApiKey = \"ap2_5a73745b-600e-4343-8b1c-bd5f8034fdc5\";\n        this.currentAudio = null;\n        this.isPlaying = false;\n        this.queue = [];\n        this.isProcessing = false;\n        this.currentQueueId = null;\n        this.api = axios__WEBPACK_IMPORTED_MODULE_2__[\"default\"].create({\n            adapter: (0,axios_cache_adapter__WEBPACK_IMPORTED_MODULE_1__.setupCache)({\n                maxAge: 3 * 60 * 60 * 1000\n            }).adapter\n        });\n        // Default voices for different personas (fallback)\n        this.defaultVoices = {\n            teacher: \"EXAVITQu4vr4xnSDxMaL\",\n            student: \"pNInz6obpgDQGcFmaJgB\",\n            narrator: \"21m00Tcm4TlvDq8ikWAM\"\n        };\n        this.apiKey = \"sk_e30926529c1ec50c9af5ee50f2f17ad788ac0dbe55af3ea9\" || 0;\n        if (!this.apiKey) {\n            console.warn(\"ElevenLabs API key not found. TTS functionality will be limited.\");\n        }\n    }\n}\n// Create singleton instance\nconst ttsService = new TextToSpeechService();\n// Export utility functions\nconst speakText = (text, options)=>ttsService.speakCleaned(text, options);\nconst speakWithVoiceId = (text, voiceId, options)=>ttsService.speakWithVoiceId(text, voiceId, options);\nconst speakLongContent = (text, options)=>ttsService.speakLongText(text, options);\nconst stopSpeaking = ()=>ttsService.stopAudio();\nconst pauseSpeaking = ()=>ttsService.pauseAudio();\nconst resumeSpeaking = ()=>ttsService.resumeAudio();\nconst clearSpeechQueue = ()=>ttsService.clearQueue();\nconst getSpeechStatus = ()=>ttsService.getStatus();\nconst isTTSAvailable = ()=>ttsService.isAvailable();\n/* harmony default export */ __webpack_exports__[\"default\"] = (ttsService);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy90ZXh0VG9TcGVlY2gudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0M7QUFDVjtBQUNxQjtBQTBCL0MsTUFBTUc7SUFnQ0osTUFBTUMsc0JBQXNCQyxJQUFZLEVBQUVDLE9BQWUsRUFBQztRQUN4REMsUUFBUUMsR0FBRyxDQUFDLGdDQUFvREYsT0FBcEJELE1BQUssaUJBQXVCLE9BQVJDO1FBQ2hFLE1BQU1HLGNBQWMsTUFBTSxJQUFJLENBQUNDLEdBQUcsQ0FBQztZQUNqQ0MsS0FBSyxJQUFJLENBQUNDLFVBQVU7WUFDcEJDLFFBQVE7WUFDUkMsU0FBUztnQkFDUEMsZUFBZSxVQUEwQixPQUFoQixJQUFJLENBQUNDLFVBQVU7WUFDMUM7WUFDQUMsTUFBTTtnQkFDSlosTUFBTUE7Z0JBQ05DLFNBQVNBO1lBQ1g7UUFDRjtRQUVBLE9BQU9HLFlBQVlRLElBQUk7SUFDekI7SUFFQTs7R0FFQyxHQUNELE1BQU1DLGFBQ0piLElBQVksRUFFVTtZQUR0QmMsVUFBQUEsaUVBQXNCLENBQUM7UUFFdkIsSUFBSSxDQUFDLElBQUksQ0FBQ0MsTUFBTSxFQUFFO1lBQ2hCLE1BQU0sSUFBSUMsTUFBTTtRQUNsQjtRQUVBLElBQUksQ0FBQ2hCLEtBQUtpQixJQUFJLElBQUk7WUFDaEIsTUFBTSxJQUFJRCxNQUFNO1FBQ2xCO1FBRUEsTUFBTSxFQUNKRSxRQUFRLElBQUksQ0FBQ0MsYUFBYSxDQUFDQyxRQUFRLEVBQ25DQyxRQUFRLHVCQUF1QixFQUMvQkMsWUFBWSxHQUFHLEVBQ2ZDLGtCQUFrQixJQUFJLEVBQ3RCQyxRQUFRLENBQUMsRUFDVEMsa0JBQWtCLElBQUksRUFDdkIsR0FBR1g7UUFFSixNQUFNWSxnQkFBK0I7WUFDbkNKO1lBQ0FLLGtCQUFrQko7WUFDbEJDO1lBQ0FJLG1CQUFtQkg7UUFDckI7UUFFQSxJQUFJO1lBQ0YsTUFBTUksV0FBVyxNQUFNQyxNQUFNLEdBQWtDWixPQUEvQixJQUFJ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QU1xQyxtQkFBbUIsSUFBTU4sV0FBVzlCLFVBQVUsR0FBRztBQUN2RCxNQUFNcUMsa0JBQWtCLElBQU1QLFdBQVc1QixTQUFTLEdBQUc7QUFDckQsTUFBTW9DLGlCQUFpQixJQUFNUixXQUFXWixXQUFXLEdBQUc7QUFFN0QsK0RBQWVZLFVBQVVBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3V0aWxzL3RleHRUb1NwZWVjaC50cz84MDU4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0b2FzdCBmcm9tICdyZWFjdC1ob3QtdG9hc3QnO1xuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcbmltcG9ydCB7c2V0dXBDYWNoZX0gZnJvbSAnYXhpb3MtY2FjaGUtYWRhcHRlcic7XG5cbmludGVyZmFjZSBUVFNPcHRpb25zIHtcbiAgdm9pY2U/OiBzdHJpbmc7XG4gIG1vZGVsPzogc3RyaW5nO1xuICBzdGFiaWxpdHk/OiBudW1iZXI7XG4gIHNpbWlsYXJpdHlCb29zdD86IG51bWJlcjtcbiAgc3R5bGU/OiBudW1iZXI7XG4gIHVzZVNwZWFrZXJCb29zdD86IGJvb2xlYW47XG59XG5cbmludGVyZmFjZSBWb2ljZVNldHRpbmdzIHtcbiAgc3RhYmlsaXR5OiBudW1iZXI7XG4gIHNpbWlsYXJpdHlfYm9vc3Q6IG51bWJlcjtcbiAgc3R5bGU/OiBudW1iZXI7XG4gIHVzZV9zcGVha2VyX2Jvb3N0PzogYm9vbGVhbjtcbn1cblxuaW50ZXJmYWNlIFF1ZXVlSXRlbSB7XG4gIHRleHQ6IHN0cmluZztcbiAgb3B0aW9ucz86IFRUU09wdGlvbnM7XG4gIHJlc29sdmU6IEZ1bmN0aW9uO1xuICByZWplY3Q6IEZ1bmN0aW9uO1xuICBpZDogc3RyaW5nO1xufVxuXG5jbGFzcyBUZXh0VG9TcGVlY2hTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBhcGlLZXk6IHN0cmluZztcbiAgcHJpdmF0ZSBiYXNlVXJsOiBzdHJpbmcgPSAnaHR0cHM6Ly9hcGkuZWxldmVubGFicy5pby92MSc7XG4gIHByaXZhdGUgbXVyZkFwaVVybDogc3RyaW5nID0gJ2h0dHBzOi8vYXBpLm11cmYuYWkvdjEvc3BlZWNoL2dlbmVyYXRlJztcbiAgcHJpdmF0ZSBtdXJmQXBpS2V5OiBzdHJpbmcgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19NVVJGX0FQSV9LRVkhO1xuICBwcml2YXRlIGN1cnJlbnRBdWRpbzogSFRNTEF1ZGlvRWxlbWVudCB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGlzUGxheWluZzogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIHF1ZXVlOiBRdWV1ZUl0ZW1bXSA9IFtdO1xuICBwcml2YXRlIGlzUHJvY2Vzc2luZzogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIGN1cnJlbnRRdWV1ZUlkOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBhcGkgPSBheGlvcy5jcmVhdGUoe2FkYXB0ZXI6IHNldHVwQ2FjaGUoe1xuICAgIG1heEFnZTogMyAqIDYwICogNjAgKiAxMDAwLFxuXG4gIH0pLmFkYXB0ZXJcbn0pXG5cbiAgLy8gRGVmYXVsdCB2b2ljZXMgZm9yIGRpZmZlcmVudCBwZXJzb25hcyAoZmFsbGJhY2spXG4gIHByaXZhdGUgZGVmYXVsdFZvaWNlcyA9IHtcbiAgICB0ZWFjaGVyOiAnRVhBVklUUXU0dnI0eG5TRHhNYUwnLCAvLyBCZWxsYSAtIFByb2Zlc3Npb25hbCBmZW1hbGUgdm9pY2VcbiAgICBzdHVkZW50OiAncE5Jbno2b2JwZ0RRR2NGbWFKZ0InLCAvLyBBZGFtIC0gWW91bmcgbWFsZSB2b2ljZVxuICAgIG5hcnJhdG9yOiAnMjFtMDBUY200VGx2RHE4aWtXQU0nLCAvLyBSYWNoZWwgLSBDbGVhciBmZW1hbGUgdm9pY2VcbiAgfTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmFwaUtleSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0VMRVZFTkxBQlNfQVBJX0tFWSB8fCAnJztcbiAgICBpZiAoIXRoaXMuYXBpS2V5KSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0VsZXZlbkxhYnMgQVBJIGtleSBub3QgZm91bmQuIFRUUyBmdW5jdGlvbmFsaXR5IHdpbGwgYmUgbGltaXRlZC4nKTtcbiAgICB9XG4gIH1cblxuXG5cbiAgYXN5bmMgZmV0Y2hWb2ljZUF1ZGlvQnVmZmVyKHRleHQ6IHN0cmluZywgdm9pY2VJZDogc3RyaW5nKXtcbiAgICBjb25zb2xlLmxvZyhgRmV0Y2hpbmcgYXVkaW8gYnVmZmVyIGZvcjogXFxuJHt0ZXh0fSBcXG5Wb2ljZSBJRDogJHt2b2ljZUlkfWApXG4gICAgY29uc3QgYXBpUmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaSh7XG4gICAgICB1cmw6IHRoaXMubXVyZkFwaVVybCxcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dGhpcy5tdXJmQXBpS2V5fWBcbiAgICAgIH0sXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgIHZvaWNlSWQ6IHZvaWNlSWRcbiAgICAgIH1cbiAgICB9KVxuICAgIFxuICAgIHJldHVybiBhcGlSZXNwb25zZS5kYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgdGV4dCB0byBzcGVlY2ggdXNpbmcgRWxldmVuTGFicyBBUElcbiAgICovXG4gIGFzeW5jIHRleHRUb1NwZWVjaChcbiAgICB0ZXh0OiBzdHJpbmcsIFxuICAgIG9wdGlvbnM6IFRUU09wdGlvbnMgPSB7fVxuICApOiBQcm9taXNlPEFycmF5QnVmZmVyPiB7XG4gICAgaWYgKCF0aGlzLmFwaUtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbGV2ZW5MYWJzIEFQSSBrZXkgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG5cbiAgICBpZiAoIXRleHQudHJpbSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RleHQgY2Fubm90IGJlIGVtcHR5Jyk7XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgdm9pY2UgPSB0aGlzLmRlZmF1bHRWb2ljZXMubmFycmF0b3IsXG4gICAgICBtb2RlbCA9ICdlbGV2ZW5fbW9ub2xpbmd1YWxfdjEnLFxuICAgICAgc3RhYmlsaXR5ID0gMC41LFxuICAgICAgc2ltaWxhcml0eUJvb3N0ID0gMC43NSxcbiAgICAgIHN0eWxlID0gMCxcbiAgICAgIHVzZVNwZWFrZXJCb29zdCA9IHRydWUsXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICBjb25zdCB2b2ljZVNldHRpbmdzOiBWb2ljZVNldHRpbmdzID0ge1xuICAgICAgc3RhYmlsaXR5LFxuICAgICAgc2ltaWxhcml0eV9ib29zdDogc2ltaWxhcml0eUJvb3N0LFxuICAgICAgc3R5bGUsXG4gICAgICB1c2Vfc3BlYWtlcl9ib29zdDogdXNlU3BlYWtlckJvb3N0LFxuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVcmx9L3RleHQtdG8tc3BlZWNoLyR7dm9pY2V9YCwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdBY2NlcHQnOiAnYXVkaW8vbXBlZycsXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAneGktYXBpLWtleSc6IHRoaXMuYXBpS2V5LFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgdGV4dDogdGhpcy5jbGVhblRleHRGb3JUVFModGV4dC50cmltKCkpLFxuICAgICAgICAgIG1vZGVsX2lkOiBtb2RlbCxcbiAgICAgICAgICB2b2ljZV9zZXR0aW5nczogdm9pY2VTZXR0aW5ncyxcbiAgICAgICAgfSksXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVFRTIEFQSSBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9IC0gJHtlcnJvclRleHR9YCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdUZXh0LXRvLXNwZWVjaCBlcnJvcjonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGxheSBhdWRpbyBmcm9tIEFycmF5QnVmZmVyXG4gICAqL1xuICBhc3luYyBwbGF5QXVkaW8oYXVkaW9CdWZmZXI6IEFycmF5QnVmZmVyLCBxdWV1ZUlkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBxdWV1ZSBpdGVtIGlzIHN0aWxsIHZhbGlkXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRRdWV1ZUlkICE9PSBxdWV1ZUlkKSB7XG4gICAgICAgICAgcmVzb2x2ZSgpOyAvLyBTaWxlbnRseSByZXNvbHZlIGlmIHF1ZXVlIGl0ZW0gd2FzIGNhbmNlbGxlZFxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbYXVkaW9CdWZmZXJdLCB7IHR5cGU6ICdhdWRpby9tcGVnJyB9KTtcbiAgICAgICAgY29uc3QgYXVkaW9VcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICBcbiAgICAgICAgLy8gU3RvcCBjdXJyZW50IGF1ZGlvIGlmIHBsYXlpbmdcbiAgICAgICAgdGhpcy5zdG9wQXVkaW8oKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuY3VycmVudEF1ZGlvID0gbmV3IEF1ZGlvKGF1ZGlvVXJsKTtcbiAgICAgICAgdGhpcy5jdXJyZW50QXVkaW8ucHJlbG9hZCA9ICdhdXRvJztcbiAgICAgICAgXG4gICAgICAgIHRoaXMuY3VycmVudEF1ZGlvLm9ubG9hZGVkZGF0YSA9ICgpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnQXVkaW8gbG9hZGVkIHN1Y2Nlc3NmdWxseScpO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgdGhpcy5jdXJyZW50QXVkaW8ub25wbGF5ID0gKCkgPT4ge1xuICAgICAgICAgIHRoaXMuaXNQbGF5aW5nID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuY3VycmVudEF1ZGlvLm9uZW5kZWQgPSAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmN1cnJlbnRRdWV1ZUlkID0gbnVsbDtcbiAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKGF1ZGlvVXJsKTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICB0aGlzLmN1cnJlbnRBdWRpby5vbmVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICAgICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmN1cnJlbnRRdWV1ZUlkID0gbnVsbDtcbiAgICAgICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKGF1ZGlvVXJsKTtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdBdWRpbyBwbGF5YmFjayBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignQXVkaW8gcGxheWJhY2sgZmFpbGVkJykpO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgdGhpcy5jdXJyZW50QXVkaW8ub25wYXVzZSA9ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLy8gU3RhcnQgcGxheWJhY2tcbiAgICAgICAgdGhpcy5jdXJyZW50QXVkaW8ucGxheSgpLmNhdGNoKHJlamVjdCk7XG4gICAgICAgIFxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgYXVkaW86JywgZXJyb3IpO1xuICAgICAgICB0aGlzLmN1cnJlbnRRdWV1ZUlkID0gbnVsbDtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGVhayB0ZXh0IHdpdGggb3B0aW9uc1xuICAgKi9cbiAgYXN5bmMgc3BlYWsodGV4dDogc3RyaW5nLCBvcHRpb25zOiBUVFNPcHRpb25zID0ge30pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgcXVldWVJdGVtOiBRdWV1ZUl0ZW0gPSB7XG4gICAgICAgIHRleHQsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIHJlc29sdmUsXG4gICAgICAgIHJlamVjdCxcbiAgICAgICAgaWQ6IGB0dHMtJHtEYXRlLm5vdygpfS0ke01hdGgucmFuZG9tKCl9YFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgdGhpcy5xdWV1ZS5wdXNoKHF1ZXVlSXRlbSk7XG4gICAgICBjb25zb2xlLmxvZygnQXVkaW8gcXVldWVkOicsIHRoaXMucXVldWUpXG4gICAgICB0aGlzLnByb2Nlc3NRdWV1ZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwZWFrIHdpdGggc3BlY2lmaWMgdm9pY2UgSUQgKGZvciBkaXNjdXNzaW9uIG1lc3NhZ2VzKVxuICAgKi9cbiAgYXN5bmMgc3BlYWtXaXRoVm9pY2VJZCh0ZXh0OiBzdHJpbmcsIHZvaWNlSWQ6IHN0cmluZywgb3B0aW9uczogUGFydGlhbDxUVFNPcHRpb25zPiA9IHt9KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3Qgdm9pY2VPcHRpb25zOiBUVFNPcHRpb25zID0ge1xuICAgICAgdm9pY2U6IHZvaWNlSWQsXG4gICAgICBzdGFiaWxpdHk6IDAuNixcbiAgICAgIHNpbWlsYXJpdHlCb29zdDogMC43NSxcbiAgICAgIHN0eWxlOiAwLjIsXG4gICAgICB1c2VTcGVha2VyQm9vc3Q6IHRydWUsXG4gICAgICAuLi5vcHRpb25zLFxuICAgIH07XG4gICAgY29uc29sZS5sb2coJ2NhbGxlZCBzcGVha1dpdGhWb2ljZUlkKCknKVxuICAgIHJldHVybiB0aGlzLnNwZWFrKHRleHQsIHZvaWNlT3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogUHJvY2VzcyB0aGUgVFRTIHF1ZXVlXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHByb2Nlc3NRdWV1ZSgpIHtcbiAgICBpZiAodGhpcy5pc1Byb2Nlc3NpbmcgfHwgdGhpcy5xdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmlzUHJvY2Vzc2luZyA9IHRydWU7XG5cbiAgICB3aGlsZSAodGhpcy5xdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBxdWV1ZUl0ZW0gPSB0aGlzLnF1ZXVlLnNoaWZ0KCkhO1xuICAgICAgY29uc3QgeyB0ZXh0LCBvcHRpb25zLCByZXNvbHZlLCByZWplY3QsIGlkIH0gPSBxdWV1ZUl0ZW07XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuY3VycmVudFF1ZXVlSWQgPSBpZDtcblxuICAgICAgICAvLyBTaG93IGxvYWRpbmcgdG9hc3QgZm9yIGxvbmdlciB0ZXh0c1xuICAgICAgICBsZXQgbG9hZGluZ1RvYXN0OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDEwMCkge1xuICAgICAgICAgIGxvYWRpbmdUb2FzdCA9IHRvYXN0LmxvYWRpbmcoJ0dlbmVyYXRpbmcgc3BlZWNoLi4uJywge1xuICAgICAgICAgICAgZHVyYXRpb246IDUwMDAsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhdWRpb0J1ZmZlciA9IGF3YWl0IHRoaXMudGV4dFRvU3BlZWNoKHRleHQsIG9wdGlvbnMpO1xuICAgICAgICBcbiAgICAgICAgaWYgKGxvYWRpbmdUb2FzdCkge1xuICAgICAgICAgIHRvYXN0LmRpc21pc3MobG9hZGluZ1RvYXN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoaXMgcXVldWUgaXRlbSBpcyBzdGlsbCB2YWxpZCBiZWZvcmUgcGxheWluZ1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50UXVldWVJZCA9PT0gaWQpIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLnBsYXlBdWRpbyhhdWRpb0J1ZmZlciwgaWQpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdUVFMgcHJvY2Vzc2luZyBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgIFxuICAgICAgICAvLyBPbmx5IHNob3cgZXJyb3IgdG9hc3QgaWYgdGhpcyB3YXMgdGhlIGN1cnJlbnQgaXRlbVxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UXVldWVJZCA9PT0gaWQpIHtcbiAgICAgICAgICB0b2FzdC5lcnJvcignU3BlZWNoIGdlbmVyYXRpb24gZmFpbGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRoaXMuY3VycmVudFF1ZXVlSWQgPSBudWxsO1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuaXNQcm9jZXNzaW5nID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogU3RvcCBjdXJyZW50IGF1ZGlvIHBsYXliYWNrIGFuZCBjbGVhciBxdWV1ZVxuICAgKi9cbiAgc3RvcEF1ZGlvKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmN1cnJlbnRBdWRpbykge1xuICAgICAgdGhpcy5jdXJyZW50QXVkaW8ucGF1c2UoKTtcbiAgICAgIHRoaXMuY3VycmVudEF1ZGlvLmN1cnJlbnRUaW1lID0gMDtcbiAgICAgIHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudFF1ZXVlSWQgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhdXNlIGN1cnJlbnQgYXVkaW8gcGxheWJhY2tcbiAgICovXG4gIHBhdXNlQXVkaW8oKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY3VycmVudEF1ZGlvICYmIHRoaXMuaXNQbGF5aW5nKSB7XG4gICAgICB0aGlzLmN1cnJlbnRBdWRpby5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXN1bWUgY3VycmVudCBhdWRpbyBwbGF5YmFja1xuICAgKi9cbiAgcmVzdW1lQXVkaW8oKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY3VycmVudEF1ZGlvICYmICF0aGlzLmlzUGxheWluZykge1xuICAgICAgdGhpcy5jdXJyZW50QXVkaW8ucGxheSgpLmNhdGNoKGNvbnNvbGUuZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciB0aGUgVFRTIHF1ZXVlXG4gICAqL1xuICBjbGVhclF1ZXVlKCk6IHZvaWQge1xuICAgIHRoaXMucXVldWUuZm9yRWFjaCgoeyByZWplY3QgfSkgPT4ge1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcignUXVldWUgY2xlYXJlZCcpKTtcbiAgICB9KTtcbiAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgdGhpcy5jdXJyZW50UXVldWVJZCA9IG51bGw7XG4gICAgdGhpcy5zdG9wQXVkaW8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgY3VycmVudCBwbGF5YmFjayBzdGF0dXNcbiAgICovXG4gIGdldFN0YXR1cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNQbGF5aW5nOiB0aGlzLmlzUGxheWluZyxcbiAgICAgIHF1ZXVlTGVuZ3RoOiB0aGlzLnF1ZXVlLmxlbmd0aCxcbiAgICAgIGlzUHJvY2Vzc2luZzogdGhpcy5pc1Byb2Nlc3NpbmcsXG4gICAgICBjdXJyZW50VGltZTogdGhpcy5jdXJyZW50QXVkaW8/LmN1cnJlbnRUaW1lIHx8IDAsXG4gICAgICBkdXJhdGlvbjogdGhpcy5jdXJyZW50QXVkaW8/LmR1cmF0aW9uIHx8IDAsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGVhayB0ZXh0IHdpdGggcGVyc29uYS1zcGVjaWZpYyB2b2ljZVxuICAgKi9cblxuICAvKipcbiAgICogVXRpbGl0eSBtZXRob2QgdG8gY2xlYW4gdGV4dCBmb3IgYmV0dGVyIFRUU1xuICAgKi9cbiAgcHJpdmF0ZSBjbGVhblRleHRGb3JUVFModGV4dDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGV4dFxuICAgICAgLnJlcGxhY2UoL1xcKlxcKiguKj8pXFwqXFwqL2csICckMScpIC8vIFJlbW92ZSBtYXJrZG93biBib2xkXG4gICAgICAucmVwbGFjZSgvXFwqKC4qPylcXCovZywgJyQxJykgLy8gUmVtb3ZlIG1hcmtkb3duIGl0YWxpY1xuICAgICAgLnJlcGxhY2UoL2AoLio/KWAvZywgJyQxJykgLy8gUmVtb3ZlIGNvZGUgYmxvY2tzXG4gICAgICAucmVwbGFjZSgvI3sxLDZ9XFxzL2csICcnKSAvLyBSZW1vdmUgbWFya2Rvd24gaGVhZGVyc1xuICAgICAgLnJlcGxhY2UoL1xcWyhbXlxcXV0rKVxcXVxcKFteKV0rXFwpL2csICckMScpIC8vIENvbnZlcnQgbGlua3MgdG8gdGV4dFxuICAgICAgLnJlcGxhY2UoL1xcbnsyLH0vZywgJy4gJykgLy8gUmVwbGFjZSBtdWx0aXBsZSBuZXdsaW5lcyB3aXRoIHBlcmlvZHNcbiAgICAgIC5yZXBsYWNlKC9cXG4vZywgJyAnKSAvLyBSZXBsYWNlIHNpbmdsZSBuZXdsaW5lcyB3aXRoIHNwYWNlc1xuICAgICAgLnJlcGxhY2UoL1xcc3syLH0vZywgJyAnKSAvLyBSZXBsYWNlIG11bHRpcGxlIHNwYWNlcyB3aXRoIHNpbmdsZSBzcGFjZVxuICAgICAgLnJlcGxhY2UoL1teXFx3XFxzLiwhPzs6J1wiKCktXS9nLCAnJykgLy8gUmVtb3ZlIHNwZWNpYWwgY2hhcmFjdGVycyB0aGF0IG1pZ2h0IGNhdXNlIGlzc3Vlc1xuICAgICAgLnRyaW0oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGVhayBjbGVhbmVkIHRleHRcbiAgICovXG4gIGFzeW5jIHNwZWFrQ2xlYW5lZCh0ZXh0OiBzdHJpbmcsIG9wdGlvbnM6IFRUU09wdGlvbnMgPSB7fSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGNsZWFuZWRUZXh0ID0gdGhpcy5jbGVhblRleHRGb3JUVFModGV4dCk7XG4gICAgcmV0dXJuIHRoaXMuc3BlYWsoY2xlYW5lZFRleHQsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJyZWFrIGxvbmcgdGV4dCBpbnRvIGNodW5rcyBhbmQgc3BlYWsgdGhlbVxuICAgKi9cbiAgYXN5bmMgc3BlYWtMb25nVGV4dChcbiAgICB0ZXh0OiBzdHJpbmcsIFxuICAgIG9wdGlvbnM6IFRUU09wdGlvbnMgPSB7fSxcbiAgICBtYXhDaHVua0xlbmd0aDogbnVtYmVyID0gNTAwXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGNsZWFuZWRUZXh0ID0gdGhpcy5jbGVhblRleHRGb3JUVFModGV4dCk7XG4gICAgXG4gICAgaWYgKGNsZWFuZWRUZXh0Lmxlbmd0aCA8PSBtYXhDaHVua0xlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3BlYWsoY2xlYW5lZFRleHQsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8vIFNwbGl0IHRleHQgaW50byBzZW50ZW5jZXNcbiAgICBjb25zdCBzZW50ZW5jZXMgPSBjbGVhbmVkVGV4dC5zcGxpdCgvWy4hP10rLykuZmlsdGVyKHMgPT4gcy50cmltKCkubGVuZ3RoID4gMCk7XG4gICAgY29uc3QgY2h1bmtzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGxldCBjdXJyZW50Q2h1bmsgPSAnJztcblxuICAgIGZvciAoY29uc3Qgc2VudGVuY2Ugb2Ygc2VudGVuY2VzKSB7XG4gICAgICBjb25zdCB0cmltbWVkU2VudGVuY2UgPSBzZW50ZW5jZS50cmltKCk7XG4gICAgICBpZiAoY3VycmVudENodW5rLmxlbmd0aCArIHRyaW1tZWRTZW50ZW5jZS5sZW5ndGggKyAxIDw9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgICAgIGN1cnJlbnRDaHVuayArPSAoY3VycmVudENodW5rID8gJy4gJyA6ICcnKSArIHRyaW1tZWRTZW50ZW5jZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjdXJyZW50Q2h1bmspIHtcbiAgICAgICAgICBjaHVua3MucHVzaChjdXJyZW50Q2h1bmsgKyAnLicpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRDaHVuayA9IHRyaW1tZWRTZW50ZW5jZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY3VycmVudENodW5rKSB7XG4gICAgICBjaHVua3MucHVzaChjdXJyZW50Q2h1bmsgKyAnLicpO1xuICAgIH1cblxuICAgIC8vIFNwZWFrIGVhY2ggY2h1bmsgc2VxdWVudGlhbGx5XG4gICAgZm9yIChjb25zdCBjaHVuayBvZiBjaHVua3MpIHtcbiAgICAgIGF3YWl0IHRoaXMuc3BlYWsoY2h1bmssIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBUVFMgaXMgYXZhaWxhYmxlXG4gICAqL1xuICBpc0F2YWlsYWJsZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISF0aGlzLmFwaUtleTtcbiAgfVxufVxuXG4vLyBDcmVhdGUgc2luZ2xldG9uIGluc3RhbmNlXG5leHBvcnQgY29uc3QgdHRzU2VydmljZSA9IG5ldyBUZXh0VG9TcGVlY2hTZXJ2aWNlKCk7XG5cbi8vIEV4cG9ydCB1dGlsaXR5IGZ1bmN0aW9uc1xuZXhwb3J0IGNvbnN0IHNwZWFrVGV4dCA9ICh0ZXh0OiBzdHJpbmcsIG9wdGlvbnM/OiBUVFNPcHRpb25zKSA9PiBcbiAgdHRzU2VydmljZS5zcGVha0NsZWFuZWQodGV4dCwgb3B0aW9ucyk7XG5cblxuZXhwb3J0IGNvbnN0IHNwZWFrV2l0aFZvaWNlSWQgPSAodGV4dDogc3RyaW5nLCB2b2ljZUlkOiBzdHJpbmcsIG9wdGlvbnM/OiBQYXJ0aWFsPFRUU09wdGlvbnM+KSA9PlxuICB0dHNTZXJ2aWNlLnNwZWFrV2l0aFZvaWNlSWQodGV4dCwgdm9pY2VJZCwgb3B0aW9ucyk7XG5cbmV4cG9ydCBjb25zdCBzcGVha0xvbmdDb250ZW50ID0gKHRleHQ6IHN0cmluZywgb3B0aW9ucz86IFRUU09wdGlvbnMpID0+IFxuICB0dHNTZXJ2aWNlLnNwZWFrTG9uZ1RleHQodGV4dCwgb3B0aW9ucyk7XG5cbmV4cG9ydCBjb25zdCBzdG9wU3BlYWtpbmcgPSAoKSA9PiB0dHNTZXJ2aWNlLnN0b3BBdWRpbygpO1xuZXhwb3J0IGNvbnN0IHBhdXNlU3BlYWtpbmcgPSAoKSA9PiB0dHNTZXJ2aWNlLnBhdXNlQXVkaW8oKTtcbmV4cG9ydCBjb25zdCByZXN1bWVTcGVha2luZyA9ICgpID0+IHR0c1NlcnZpY2UucmVzdW1lQXVkaW8oKTtcbmV4cG9ydCBjb25zdCBjbGVhclNwZWVjaFF1ZXVlID0gKCkgPT4gdHRzU2VydmljZS5jbGVhclF1ZXVlKCk7XG5leHBvcnQgY29uc3QgZ2V0U3BlZWNoU3RhdHVzID0gKCkgPT4gdHRzU2VydmljZS5nZXRTdGF0dXMoKTtcbmV4cG9ydCBjb25zdCBpc1RUU0F2YWlsYWJsZSA9ICgpID0+IHR0c1NlcnZpY2UuaXNBdmFpbGFibGUoKTtcblxuZXhwb3J0IGRlZmF1bHQgdHRzU2VydmljZTsiXSwibmFtZXMiOlsidG9hc3QiLCJheGlvcyIsInNldHVwQ2FjaGUiLCJUZXh0VG9TcGVlY2hTZXJ2aWNlIiwiZmV0Y2hWb2ljZUF1ZGlvQnVmZmVyIiwidGV4dCIsInZvaWNlSWQiLCJjb25zb2xlIiwibG9nIiwiYXBpUmVzcG9uc2UiLCJhcGkiLCJ1cmwiLCJtdXJmQXBpVXJsIiwibWV0aG9kIiwiaGVhZGVycyIsIkF1dGhvcml6YXRpb24iLCJtdXJmQXBpS2V5IiwiZGF0YSIsInRleHRUb1NwZWVjaCIsIm9wdGlvbnMiLCJhcGlLZXkiLCJFcnJvciIsInRyaW0iLCJ2b2ljZSIsImRlZmF1bHRWb2ljZXMiLCJuYXJyYXRvciIsIm1vZGVsIiwic3RhYmlsaXR5Iiwic2ltaWxhcml0eUJvb3N0Iiwic3R5bGUiLCJ1c2VTcGVha2VyQm9vc3QiLCJ2b2ljZVNldHRpbmdzIiwic2ltaWxhcml0eV9ib29zdCIsInVzZV9zcGVha2VyX2Jvb3N0IiwicmVzcG9uc2UiLCJmZXRjaCIsImJhc2VVcmwiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImNsZWFuVGV4dEZvclRUUyIsIm1vZGVsX2lkIiwidm9pY2Vfc2V0dGluZ3MiLCJvayIsImVycm9yVGV4dCIsInN0YXR1cyIsImFycmF5QnVmZmVyIiwiZXJyb3IiLCJwbGF5QXVkaW8iLCJhdWRpb0J1ZmZlciIsInF1ZXVlSWQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImN1cnJlbnRRdWV1ZUlkIiwiYmxvYiIsIkJsb2IiLCJ0eXBlIiwiYXVkaW9VcmwiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJzdG9wQXVkaW8iLCJjdXJyZW50QXVkaW8iLCJBdWRpbyIsInByZWxvYWQiLCJvbmxvYWRlZGRhdGEiLCJvbnBsYXkiLCJpc1BsYXlpbmciLCJvbmVuZGVkIiwicmV2b2tlT2JqZWN0VVJMIiwib25lcnJvciIsIm9ucGF1c2UiLCJwbGF5IiwiY2F0Y2giLCJzcGVhayIsInF1ZXVlSXRlbSIsImlkIiwiTWF0aCIsIkRhdGUiLCJub3ciLCJyYW5kb20iLCJxdWV1ZSIsInB1c2giLCJwcm9jZXNzUXVldWUiLCJzcGVha1dpdGhWb2ljZUlkIiwidm9pY2VPcHRpb25zIiwiaXNQcm9jZXNzaW5nIiwibGVuZ3RoIiwic2hpZnQiLCJsb2FkaW5nVG9hc3QiLCJsb2FkaW5nIiwiZHVyYXRpb24iLCJkaXNtaXNzIiwicGF1c2UiLCJjdXJyZW50VGltZSIsInBhdXNlQXVkaW8iLCJyZXN1bWVBdWRpbyIsImNsZWFyUXVldWUiLCJmb3JFYWNoIiwiZ2V0U3RhdHVzIiwicXVldWVMZW5ndGgiLCJyZXBsYWNlIiwic3BlYWtDbGVhbmVkIiwiY2xlYW5lZFRleHQiLCJzcGVha0xvbmdUZXh0IiwibWF4Q2h1bmtMZW5ndGgiLCJzZW50ZW5jZXMiLCJzcGxpdCIsImZpbHRlciIsInMiLCJjaHVua3MiLCJjdXJyZW50Q2h1bmsiLCJzZW50ZW5jZSIsInRyaW1tZWRTZW50ZW5jZSIsImNodW5rIiwiaXNBdmFpbGFibGUiLCJjb25zdHJ1Y3RvciIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19NVVJGX0FQSV9LRVkiLCJjcmVhdGUiLCJhZGFwdGVyIiwibWF4QWdlIiwidGVhY2hlciIsInN0dWRlbnQiLCJORVhUX1BVQkxJQ19FTEVWRU5MQUJTX0FQSV9LRVkiLCJ3YXJuIiwidHRzU2VydmljZSIsInNwZWFrVGV4dCIsInNwZWFrTG9uZ0NvbnRlbnQiLCJzdG9wU3BlYWtpbmciLCJwYXVzZVNwZWFraW5nIiwicmVzdW1lU3BlYWtpbmciLCJjbGVhclNwZWVjaFF1ZXVlIiwiZ2V0U3BlZWNoU3RhdHVzIiwiaXNUVFNBdmFpbGFibGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/textToSpeech.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/utils/tts.ts":
/*!**************************!*\
  !*** ./src/utils/tts.ts ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TTS: function() { return /* binding */ TTS; },\n/* harmony export */   TextNode: function() { return /* binding */ TextNode; }\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"(app-pages-browser)/./src/utils/constants.ts\");\n\nclass TextNode {\n    cleanTextForTTS(text) {\n        return text.replace(/\\*\\*(.*?)\\*\\*/g, \"$1\") // Remove markdown bold\n        .replace(/\\*(.*?)\\*/g, \"$1\") // Remove markdown italic\n        .replace(/`(.*?)`/g, \"$1\") // Remove code blocks\n        .replace(/#{1,6}\\s/g, \"\") // Remove markdown headers\n        .replace(/\\[([^\\]]+)\\]\\([^)]+\\)/g, \"$1\") // Convert links to text\n        .replace(/\\n{2,}/g, \". \") // Replace multiple newlines with periods\n        .replace(/\\n/g, \" \") // Replace single newlines with spaces\n        .replace(/\\s{2,}/g, \" \") // Replace multiple spaces with single space\n        .replace(/[^\\w\\s.,!?;:'\"()-]/g, \"\") // Remove special characters that might cause issues\n        .trim();\n    }\n    async fetchVoiceAudioBuffer() {\n        var _this_persona_voice;\n        console.log(\"Fetching audio buffer for: \\n\".concat(this.text, \" \\nVoice ID: \").concat((_this_persona_voice = this.persona.voice) === null || _this_persona_voice === void 0 ? void 0 : _this_persona_voice.id));\n        this.loading = true;\n        try {\n            var _this_persona_voice1;\n            var _this_persona_voice_id;\n            const apiResponse = await fetch(this.murfApiUrl, {\n                method: \"POST\",\n                headers: {\n                    \"api-key\": this.murfApiKey,\n                    \"Content-Type\": \"Application/json\"\n                },\n                body: JSON.stringify({\n                    text: this.cleanTextForTTS(this.text),\n                    voiceId: (_this_persona_voice_id = (_this_persona_voice1 = this.persona.voice) === null || _this_persona_voice1 === void 0 ? void 0 : _this_persona_voice1.id) !== null && _this_persona_voice_id !== void 0 ? _this_persona_voice_id : _constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_VOICE_ID\n                }),\n                cache: \"force-cache\"\n            });\n            if (!apiResponse.status.toString().startsWith(\"2\")) throw Error(\"Error fetching audio buffer\");\n            const resData = await apiResponse.json();\n            this.loading = false;\n            return resData === null || resData === void 0 ? void 0 : resData.audioFile;\n        } catch (err) {\n            this.loading = false;\n            throw Error(\"Error fetching audio buffer: \".concat(err));\n        }\n    }\n    async play() {\n        try {\n            this.playing = true;\n            if (!this.fetched || !this.data) {\n                await this.fetch();\n            }\n            console.log(\"After fetch in play:\", this.loading);\n            if (this.loading) return false;\n            if (this.audioRef.current && this.data) {\n                this.audioRef.current.src = this.data;\n                // Play audio\n                await this.audioRef.current.play();\n                // Wait for playback to finish\n                await new Promise((resolve, reject)=>{\n                    const audio = this.audioRef.current;\n                    audio.onended = null;\n                    audio.onerror = null;\n                    const onEnded = ()=>{\n                        cleanup();\n                        resolve();\n                    };\n                    const onError = (err)=>{\n                        cleanup();\n                        reject(err);\n                    };\n                    const cleanup = ()=>{\n                        audio.removeEventListener(\"ended\", onEnded);\n                        audio.removeEventListener(\"error\", onError);\n                    };\n                    audio.addEventListener(\"ended\", onEnded);\n                    audio.addEventListener(\"error\", onError);\n                });\n                this.played = true;\n                this.playing = false;\n                return true;\n            }\n            return false;\n        } catch (err) {\n            console.log(\"Error while playing audio: \".concat(err));\n            this.playing = false;\n            return false;\n        }\n    }\n    async fetch() {\n        const audioDataRes = await this.fetchVoiceAudioBuffer();\n        if (audioDataRes) {\n            this.data = audioDataRes;\n            this.fetched = true;\n        }\n    }\n    pause() {\n        var _this_audioRef_current;\n        (_this_audioRef_current = this.audioRef.current) === null || _this_audioRef_current === void 0 ? void 0 : _this_audioRef_current.pause();\n        this.played = true;\n        this.playing = false;\n    }\n    setNext(next) {\n        this.next = next;\n    }\n    getNext() {\n        return this.next;\n    }\n    constructor(id, text, persona, timestamp, audioRef, next = null, loading = false, playing = false, fetched = false, data = null, played = false, murfApiUrl = \"https://api.murf.ai/v1/speech/generate\", murfApiKey = \"ap2_5a73745b-600e-4343-8b1c-bd5f8034fdc5\"){\n        this.id = id;\n        this.text = text;\n        this.persona = persona;\n        this.timestamp = timestamp;\n        this.audioRef = audioRef;\n        this.next = next;\n        this.loading = loading;\n        this.playing = playing;\n        this.fetched = fetched;\n        this.data = data;\n        this.played = played;\n        this.murfApiUrl = murfApiUrl;\n        this.murfApiKey = murfApiKey;\n    }\n}\nclass TTS {\n    async autoplay() {\n        if (!this.autoplayon || !this.queue.length) return false;\n        this.current = this.queue[0];\n        await this.current.play();\n        const next = this.current.getNext();\n        while(this.autoplayon && next){\n            await next.play();\n        }\n    }\n    async playNode(node) {\n        await node.play();\n    }\n    stopPlay() {\n        var _this_audioRef_current;\n        const current = this.current;\n        (_this_audioRef_current = this.audioRef.current) === null || _this_audioRef_current === void 0 ? void 0 : _this_audioRef_current.pause();\n        if (current) {\n            var _this_current;\n            (_this_current = this.current) === null || _this_current === void 0 ? void 0 : _this_current.pause();\n            this.current = null;\n            return current;\n        }\n        return;\n    }\n    enqueue(d) {\n        const textNode = new TextNode(d._id, d.data, d.persona, d.timestamp, this.audioRef);\n        this.queue.push(textNode);\n        if (this.queue.length > 1) {\n            const prevNode = this.queue[this.queue.length - 2];\n            prevNode.setNext(textNode);\n        }\n        return textNode;\n    }\n    dequeue() {\n        return this.queue.pop();\n    }\n    seek(node) {\n        this.current = node;\n    }\n    constructor(data = [], current = null, queue = [], audioRef, autoplayon = true){\n        this.data = data;\n        this.current = current;\n        this.queue = queue;\n        this.audioRef = audioRef;\n        this.autoplayon = autoplayon;\n        this.data.map((d)=>{\n            const timestamp = new Date(d.createdAt);\n            return this.enqueue({\n                ...d !== null && d !== void 0 ? d : {},\n                data: d.body,\n                persona: d.persona,\n                timestamp\n            });\n        });\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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OlsiXG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xuaW1wb3J0IHsgc2V0dXBDYWNoZSB9IGZyb20gJ2F4aW9zLWNhY2hlLWFkYXB0ZXInO1xuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUNhbGxiYWNrLCB1c2VSZWYsIFJlZk9iamVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IE1lc3NhZ2UsIFBlcnNvbmEgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IERFRkFVTFRfVk9JQ0VfSUQgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBjbGFzcyBUZXh0Tm9kZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHB1YmxpYyByZWFkb25seSBpZDogc3RyaW5nLFxuICAgICAgICBwdWJsaWMgcmVhZG9ubHkgdGV4dDogc3RyaW5nLFxuICAgICAgICBwdWJsaWMgcmVhZG9ubHkgcGVyc29uYTogUGVyc29uYSxcbiAgICAgICAgcHVibGljIHJlYWRvbmx5IHRpbWVzdGFtcDogRGF0ZSxcbiAgICAgICAgcHVibGljIGF1ZGlvUmVmOiBSZWZPYmplY3Q8SFRNTEF1ZGlvRWxlbWVudD4sXG4gICAgICAgIHByaXZhdGUgbmV4dDogVGV4dE5vZGUgfCBudWxsID0gbnVsbCxcbiAgICAgICAgcHVibGljIGxvYWRpbmc6IGJvb2xlYW4gPSBmYWxzZSxcbiAgICAgICAgcHVibGljIHBsYXlpbmc6IGJvb2xlYW4gPSBmYWxzZSxcbiAgICAgICAgcHVibGljIGZldGNoZWQ6IGJvb2xlYW4gPSBmYWxzZSxcbiAgICAgICAgcHVibGljIGRhdGE6IHN0cmluZyB8IG51bGwgPSBudWxsLFxuICAgICAgICBwdWJsaWMgcGxheWVkOiBib29sZWFuID0gZmFsc2UsXG4gICAgICAgIHByaXZhdGUgbXVyZkFwaVVybDogc3RyaW5nID0gJ2h0dHBzOi8vYXBpLm11cmYuYWkvdjEvc3BlZWNoL2dlbmVyYXRlJyxcbiAgICAgICAgcHJpdmF0ZSBtdXJmQXBpS2V5OiBzdHJpbmcgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19NVVJGX0FQSV9LRVkhLFxuXG4gICAgKSB7IH1cblxuICAgIHByaXZhdGUgY2xlYW5UZXh0Rm9yVFRTKHRleHQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0ZXh0XG4gICAgICAgICAgICAucmVwbGFjZSgvXFwqXFwqKC4qPylcXCpcXCovZywgJyQxJykgLy8gUmVtb3ZlIG1hcmtkb3duIGJvbGRcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXCooLio/KVxcKi9nLCAnJDEnKSAvLyBSZW1vdmUgbWFya2Rvd24gaXRhbGljXG4gICAgICAgICAgICAucmVwbGFjZSgvYCguKj8pYC9nLCAnJDEnKSAvLyBSZW1vdmUgY29kZSBibG9ja3NcbiAgICAgICAgICAgIC5yZXBsYWNlKC8jezEsNn1cXHMvZywgJycpIC8vIFJlbW92ZSBtYXJrZG93biBoZWFkZXJzXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxbKFteXFxdXSspXFxdXFwoW14pXStcXCkvZywgJyQxJykgLy8gQ29udmVydCBsaW5rcyB0byB0ZXh0XG4gICAgICAgICAgICAucmVwbGFjZSgvXFxuezIsfS9nLCAnLiAnKSAvLyBSZXBsYWNlIG11bHRpcGxlIG5ld2xpbmVzIHdpdGggcGVyaW9kc1xuICAgICAgICAgICAgLnJlcGxhY2UoL1xcbi9nLCAnICcpIC8vIFJlcGxhY2Ugc2luZ2xlIG5ld2xpbmVzIHdpdGggc3BhY2VzXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxzezIsfS9nLCAnICcpIC8vIFJlcGxhY2UgbXVsdGlwbGUgc3BhY2VzIHdpdGggc2luZ2xlIHNwYWNlXG4gICAgICAgICAgICAucmVwbGFjZSgvW15cXHdcXHMuLCE/OzonXCIoKS1dL2csICcnKSAvLyBSZW1vdmUgc3BlY2lhbCBjaGFyYWN0ZXJzIHRoYXQgbWlnaHQgY2F1c2UgaXNzdWVzXG4gICAgICAgICAgICAudHJpbSgpO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoVm9pY2VBdWRpb0J1ZmZlcigpIHtcbiAgICAgICAgY29uc29sZS5sb2coYEZldGNoaW5nIGF1ZGlvIGJ1ZmZlciBmb3I6IFxcbiR7dGhpcy50ZXh0fSBcXG5Wb2ljZSBJRDogJHt0aGlzLnBlcnNvbmEudm9pY2U/LmlkfWApXG4gICAgICAgIHRoaXMubG9hZGluZyA9IHRydWVcbiAgICAgICAgdHJ5e1xuXG4gICAgICAgIGNvbnN0IGFwaVJlc3BvbnNlID0gYXdhaXQgZmV0Y2godGhpcy5tdXJmQXBpVXJsLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAnYXBpLWtleSc6IHRoaXMubXVyZkFwaUtleSxcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ0FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMuY2xlYW5UZXh0Rm9yVFRTKHRoaXMudGV4dCksXG4gICAgICAgICAgICAgICAgdm9pY2VJZDogdGhpcy5wZXJzb25hLnZvaWNlPy5pZCA/PyBERUZBVUxUX1ZPSUNFX0lEXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGNhY2hlOiAnZm9yY2UtY2FjaGUnLFxuICAgICAgICB9KVxuICAgICAgICBpZighYXBpUmVzcG9uc2Uuc3RhdHVzLnRvU3RyaW5nKCkuc3RhcnRzV2l0aCgnMicpKXRocm93IEVycm9yKCdFcnJvciBmZXRjaGluZyBhdWRpbyBidWZmZXInKVxuICAgICAgICBjb25zdCByZXNEYXRhID0gYXdhaXQgYXBpUmVzcG9uc2UuanNvbigpXG4gICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlXG4gICAgICAgIHJldHVybiByZXNEYXRhPy5hdWRpb0ZpbGU7XG4gICAgICAgIH1jYXRjaChlcnIpe1xuICAgICAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2VcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBFcnJvciBmZXRjaGluZyBhdWRpbyBidWZmZXI6ICR7ZXJyfWApXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBwbGF5KCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMucGxheWluZyA9IHRydWU7XG4gICAgICBcbiAgICAgICAgICBpZiAoIXRoaXMuZmV0Y2hlZCB8fCAhdGhpcy5kYXRhKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmZldGNoKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnNvbGUubG9nKCdBZnRlciBmZXRjaCBpbiBwbGF5OicsIHRoaXMubG9hZGluZylcbiAgICAgICAgICBpZih0aGlzLmxvYWRpbmcpcmV0dXJuIGZhbHNlXG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKHRoaXMuYXVkaW9SZWYuY3VycmVudCAmJiB0aGlzLmRhdGEpIHtcblxuICAgICAgICAgICAgdGhpcy5hdWRpb1JlZi5jdXJyZW50LnNyYyA9IHRoaXMuZGF0YTtcbiAgICAgIFxuICAgICAgICAgICAgLy8gUGxheSBhdWRpb1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hdWRpb1JlZi5jdXJyZW50LnBsYXkoKTtcbiAgICAgIFxuICAgICAgICAgICAgLy8gV2FpdCBmb3IgcGxheWJhY2sgdG8gZmluaXNoXG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGF1ZGlvID0gdGhpcy5hdWRpb1JlZi5jdXJyZW50ITtcbiAgICAgICAgICAgICAgYXVkaW8ub25lbmRlZCA9IG51bGw7XG4gICAgICAgICAgICAgIGF1ZGlvLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgICBcbiAgICAgIFxuICAgICAgICAgICAgICBjb25zdCBvbkVuZGVkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgIH07XG4gICAgICBcbiAgICAgICAgICAgICAgY29uc3Qgb25FcnJvciA9IChlcnI6IEV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgXG4gICAgICAgICAgICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgYXVkaW8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVuZGVkXCIsIG9uRW5kZWQpO1xuICAgICAgICAgICAgICAgIGF1ZGlvLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgIFxuICAgICAgICAgICAgICBhdWRpby5hZGRFdmVudExpc3RlbmVyKFwiZW5kZWRcIiwgb25FbmRlZCk7XG4gICAgICAgICAgICAgIGF1ZGlvLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvbkVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgXG4gICAgICAgICAgICB0aGlzLnBsYXllZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnBsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgIFxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYEVycm9yIHdoaWxlIHBsYXlpbmcgYXVkaW86ICR7ZXJyfWApO1xuICAgICAgICAgIHRoaXMucGxheWluZyA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG5cbiAgICBhc3luYyBmZXRjaCgpIHtcbiAgICAgICAgY29uc3QgYXVkaW9EYXRhUmVzID0gYXdhaXQgdGhpcy5mZXRjaFZvaWNlQXVkaW9CdWZmZXIoKVxuICAgICAgICBpZiAoYXVkaW9EYXRhUmVzKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBhdWRpb0RhdGFSZXNcbiAgICAgICAgICAgIHRoaXMuZmV0Y2hlZCA9IHRydWVcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHBhdXNlKCkge1xuICAgICAgICB0aGlzLmF1ZGlvUmVmLmN1cnJlbnQ/LnBhdXNlKClcbiAgICAgICAgdGhpcy5wbGF5ZWQgPSB0cnVlXG4gICAgICAgIHRoaXMucGxheWluZyA9IGZhbHNlXG4gICAgfVxuXG4gICAgc2V0TmV4dChuZXh0OiBUZXh0Tm9kZSkge1xuICAgICAgICB0aGlzLm5leHQgPSBuZXh0XG4gICAgfVxuXG4gICAgZ2V0TmV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dFxuICAgIH1cblxuXG59XG5cblxuZXhwb3J0IGNsYXNzIFRUUyB7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBkYXRhOiBNZXNzYWdlW10gPSBbXSxcbiAgICAgICAgcHJpdmF0ZSBjdXJyZW50OiBUZXh0Tm9kZSB8IG51bGwgPSBudWxsLFxuICAgICAgICBwdWJsaWMgcmVhZG9ubHkgcXVldWU6IFRleHROb2RlW10gPSBbXSxcbiAgICAgICAgcHVibGljIHJlYWRvbmx5IGF1ZGlvUmVmOiBSZWZPYmplY3Q8SFRNTEF1ZGlvRWxlbWVudD4sXG4gICAgICAgIHB1YmxpYyBhdXRvcGxheW9uOiBib29sZWFuID0gdHJ1ZSxcblxuICAgICkge1xuICAgICAgICB0aGlzLmRhdGEubWFwKChkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZShkLmNyZWF0ZWRBdClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVucXVldWUoeyAuLi4oZCA/PyB7fSksIGRhdGE6IGQuYm9keSwgcGVyc29uYTogZC5wZXJzb25hLCB0aW1lc3RhbXAsIH0pXG4gICAgICAgIH0pXG4gICAgfVxuXG5cbiAgICBhc3luYyBhdXRvcGxheSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmF1dG9wbGF5b24gfHwgIXRoaXMucXVldWUubGVuZ3RoKSByZXR1cm4gZmFsc2VcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy5xdWV1ZVswXVxuICAgICAgICBhd2FpdCB0aGlzLmN1cnJlbnQucGxheSgpXG4gICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLmN1cnJlbnQuZ2V0TmV4dCgpXG4gICAgICAgIHdoaWxlICh0aGlzLmF1dG9wbGF5b24gJiYgbmV4dCkge1xuICAgICAgICAgICAgYXdhaXQgbmV4dC5wbGF5KClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIHBsYXlOb2RlKG5vZGU6IFRleHROb2RlKSB7XG4gICAgICAgIGF3YWl0IG5vZGUucGxheSgpXG4gICAgfVxuXG4gICAgc3RvcFBsYXkoKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICAgIHRoaXMuYXVkaW9SZWYuY3VycmVudD8ucGF1c2UoKVxuICAgICAgICBpZihjdXJyZW50KXtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudD8ucGF1c2UoKVxuICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gbnVsbFxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICB9XG5cblxuXG4gICAgZW5xdWV1ZShkOiB7IF9pZDogc3RyaW5nLCBkYXRhOiBzdHJpbmcsIHBlcnNvbmE6IFBlcnNvbmEsIHRpbWVzdGFtcDogRGF0ZSB9KTogVGV4dE5vZGUge1xuICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9IG5ldyBUZXh0Tm9kZShkLl9pZCwgZC5kYXRhLCBkLnBlcnNvbmEsIGQudGltZXN0YW1wLCB0aGlzLmF1ZGlvUmVmKVxuICAgICAgICB0aGlzLnF1ZXVlLnB1c2godGV4dE5vZGUpXG4gICAgICAgIGlmICh0aGlzLnF1ZXVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXZOb2RlID0gdGhpcy5xdWV1ZVt0aGlzLnF1ZXVlLmxlbmd0aCAtIDJdXG4gICAgICAgICAgICBwcmV2Tm9kZS5zZXROZXh0KHRleHROb2RlKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0Tm9kZVxuICAgIH1cblxuICAgIGRlcXVldWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXVlLnBvcCgpXG4gICAgfVxuXG4gICAgc2Vlayhub2RlOiBUZXh0Tm9kZSkge1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBub2RlXG4gICAgfVxuXG59XG4iXSwibmFtZXMiOlsiREVGQVVMVF9WT0lDRV9JRCIsIlRleHROb2RlIiwiY2xlYW5UZXh0Rm9yVFRTIiwidGV4dCIsInJlcGxhY2UiLCJ0cmltIiwiZmV0Y2hWb2ljZUF1ZGlvQnVmZmVyIiwiY29uc29sZSIsImxvZyIsInBlcnNvbmEiLCJ2b2ljZSIsImlkIiwibG9hZGluZyIsImFwaVJlc3BvbnNlIiwiZmV0Y2giLCJtdXJmQXBpVXJsIiwibWV0aG9kIiwiaGVhZGVycyIsIm11cmZBcGlLZXkiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInZvaWNlSWQiLCJjYWNoZSIsInN0YXR1cyIsInRvU3RyaW5nIiwic3RhcnRzV2l0aCIsIkVycm9yIiwicmVzRGF0YSIsImpzb24iLCJhdWRpb0ZpbGUiLCJlcnIiLCJwbGF5IiwicGxheWluZyIsImZldGNoZWQiLCJkYXRhIiwiYXVkaW9SZWYiLCJjdXJyZW50Iiwic3JjIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJhdWRpbyIsIm9uZW5kZWQiLCJvbmVycm9yIiwib25FbmRlZCIsImNsZWFudXAiLCJvbkVycm9yIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJwbGF5ZWQiLCJhdWRpb0RhdGFSZXMiLCJwYXVzZSIsInNldE5leHQiLCJuZXh0IiwiZ2V0TmV4dCIsImNvbnN0cnVjdG9yIiwidGltZXN0YW1wIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX01VUkZfQVBJX0tFWSIsIlRUUyIsImF1dG9wbGF5IiwiYXV0b3BsYXlvbiIsInF1ZXVlIiwibGVuZ3RoIiwicGxheU5vZGUiLCJub2RlIiwic3RvcFBsYXkiLCJlbnF1ZXVlIiwiZCIsInRleHROb2RlIiwiX2lkIiwicHVzaCIsInByZXZOb2RlIiwiZGVxdWV1ZSIsInBvcCIsInNlZWsiLCJtYXAiLCJEYXRlIiwiY3JlYXRlZEF0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/tts.ts\n"));

/***/ })

});